THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ConfigurationCommandLineHandler class>>load
26 October 2015 12:19:35.023435 am

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

ConfigurationCommandLineHandler class(Object)>>doesNotUnderstand: #load
	Receiver: ConfigurationCommandLineHandler
	Arguments and temporary variables: 
		aMessage: 	load
		exception: 	MessageNotUnderstood: ConfigurationCommandLineHandler class>>load
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->ConfigurationCommandLineHandler>>#act...etc...
		format: 	144
		layout: 	a FixedLayout
		instanceVariables: 	#('version' 'repositoryURL' 'configurationName')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConfigurationCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ConfigurationCommandLineHandler-Core'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'ConfigurationCommandLineHandler load.'
		itsSelection: 	a Text for 'ConfigurationCommandLineHandler load.'
		itsSelectionString: 	'ConfigurationCommandLineHandler load.'
	Receiver's instance variables: 
		ast: 	DoIt
	^ ConfigurationCommandLineHandler load
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(797179904)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(797179904)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>evaluateSelection
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(797179904)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>doIt
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(797179904)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>doIt:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(797179904)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildPatchShortcutsForDoItInWindowsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(797179904)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#selectorChooser #notificationStrategy)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Core'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(797179904)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildPatchShortcutsForDoItInWindowsOn:
		startpc: 	90
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(797179904)
		secondArg: 	a RubEditingArea(797179904)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildPatchShortcutsForDoItInWindowsOn:
		startpc: 	90
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(797179904)
		secondArg: 	a RubEditingArea(797179904)
		thirdArg: 	[keystroke '<Ctrl-end>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildPatchShortcutsForDoItInWindowsOn:
		startpc: 	90
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doItPatchForWindows on Ctrl + END do [ :target | target editor doIt: ...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-end>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(797179904)
		category: 	a KMCategory
		morph: 	a RubEditingArea(797179904)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doItPatchForWindows on Ctrl + END do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-end>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doItPatchForWindows
		shortcut: 	Ctrl + END
		defaultShortcut: 	Ctrl + END
		description: 	'Do it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doItPatchForWindows on Ctrl + END do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-end>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doItPatchForWindows
		shortcut: 	Ctrl + END
		defaultShortcut: 	Ctrl + END
		description: 	'Do it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doItPatchForWindows on Ctrl + END do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-end>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doItPatchForWindows
		shortcut: 	Ctrl + END
		defaultShortcut: 	Ctrl + END
		description: 	'Do it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-end>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doItPatchForWindows on Ctrl + END do [ :target | target editor doIt: ni...etc...
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Windows->a KMStorage #all->a KMSt...etc...


Set>>do:
	Receiver: a Set(#doIt on Ctrl + D do [ :target | target editor doIt: nil ]
 #debugItCommand on Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	36
		each: 	#doItPatchForWindows on Ctrl + END do [ :target | target editor doIt: nil...etc...
	Receiver's instance variables: 
		tally: 	20
		array: 	an Array(#doIt on Ctrl + D do [ :target | target editor doIt: nil ]
 nil...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-end>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Windows->a KMStorage #all->a KMSt...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-end>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(797179904)
		category: 	a KMCategory
		morph: 	a RubEditingArea(797179904)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-end>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a RubEditingArea(797179904)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-end>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a RubEditingArea(797179904)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-end>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(797179904)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-end>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-end>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-end>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a RubEditingArea(797179904)
		directKeymaps: 	a KMCategory


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(797179904)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-end>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@69)
		owner: 	a TransformWithLayoutMorph(1058275328)
		submorphs: 	an Array(a RubPrimarySelectionMorph(326369280) a RubCursor(73400320)...etc...
		fullBounds: 	(0@0) corner: (580@69)
		color: 	Color transparent
		extension: 	a MorphExtension (159383552) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(1020002304)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(73400320)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(797179904)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-end>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@69)
		owner: 	a TransformWithLayoutMorph(1058275328)
		submorphs: 	an Array(a RubPrimarySelectionMorph(326369280) a RubCursor(73400320)...etc...
		fullBounds: 	(0@0) corner: (580@69)
		color: 	Color transparent
		extension: 	a MorphExtension (159383552) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(1020002304)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(73400320)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-end>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(797179904)
	Receiver's instance variables: 
		timeStamp: 	998936
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(335@32)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	4
		charCode: 	4
		scanCode: 	68


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(797179904)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-end>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@69)
		owner: 	a TransformWithLayoutMorph(1058275328)
		submorphs: 	an Array(a RubPrimarySelectionMorph(326369280) a RubCursor(73400320)...etc...
		fullBounds: 	(0@0) corner: (580@69)
		color: 	Color transparent
		extension: 	a MorphExtension (159383552) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(1020002304)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(73400320)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(797179904)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-end>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@69)
		owner: 	a TransformWithLayoutMorph(1058275328)
		submorphs: 	an Array(a RubPrimarySelectionMorph(326369280) a RubCursor(73400320)...etc...
		fullBounds: 	(0@0) corner: (580@69)
		color: 	Color transparent
		extension: 	a MorphExtension (159383552) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(1020002304)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(73400320)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-end>']
		focusHolder: 	a RubEditingArea(797179904)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(656@128) corner: (672@144)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(656@128) corner: (672@144)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(797179904)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(664@137) mouseOver nil nil]
		targetOffset: 	(335@32)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 997579 664 137 0 0 1 1)
		lastKeyScanCode: 	68
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1440@838)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(182190080) a Na...etc...
		fullBounds: 	(0@0) corner: (1440@838)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-end>']
		focusHolder: 	a RubEditingArea(797179904)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(656@128) corner: (672@144)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(656@128) corner: (672@144)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(797179904)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(664@137) mouseOver nil nil]
		targetOffset: 	(335@32)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 997579 664 137 0 0 1 1)
		lastKeyScanCode: 	68
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-end>']
		focusHolder: 	a RubEditingArea(797179904)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(656@128) corner: (672@144)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(656@128) corner: (672@144)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(797179904)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(664@137) mouseOver nil nil]
		targetOffset: 	(335@32)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 997579 664 137 0 0 1 1)
		lastKeyScanCode: 	68
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
ConfigurationCommandLineHandler class(Object)>>doesNotUnderstand: #load
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>evaluateSelectionAndDo:
RubSmalltalkEditor>>evaluateSelection
RubSmalltalkEditor>>doIt
RubSmalltalkEditor>>doIt:
[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildPatchShortcutsForDoItInWindowsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
InvalidGlobalName: NameOfSubclass: NameOfSubclass is not a valid class name
30 October 2015 11:44:15.210991 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

SlotClassBuilder>>validateClassName
	Receiver: a SlotClassBuilder
	Arguments and temporary variables: 

	Receiver's instance variables: 
		installer: 	a PharoClassInstaller
		oldClasses: 	an OrderedCollection()
		newClasses: 	an OrderedCollection()
		classSlots: 	#()
		category: 	nil
		superclass: 	Object
		name: 	#NameOfSubclass
		layoutClass: 	nil
		slots: 	#()
		traitComposition: 	{}
		classTraitComposition: 	{}
		result: 	nil
		sharedPoolsString: 	''
		sharedVariables: 	#()
		comment: 	nil
		commentStamp: 	nil


SlotClassBuilder>>name:
	Receiver: a SlotClassBuilder
	Arguments and temporary variables: 
		aName: 	#NameOfSubclass
	Receiver's instance variables: 
		installer: 	a PharoClassInstaller
		oldClasses: 	an OrderedCollection()
		newClasses: 	an OrderedCollection()
		classSlots: 	#()
		category: 	nil
		superclass: 	Object
		name: 	#NameOfSubclass
		layoutClass: 	nil
		slots: 	#()
		traitComposition: 	{}
		classTraitComposition: 	{}
		result: 	nil
		sharedPoolsString: 	''
		sharedVariables: 	#()
		comment: 	nil
		commentStamp: 	nil


[ :builder | 
builder
	superclass: superClass;
	name: name;
	layoutClass: (self layoutForType: type);
	slots: instanceVariablesString asSlotCollection;
	sharedVariablesFromString: classVariablesString;
	sharedPools: sharedPoolsString;
	category: category;
	environment: environment;
	copyTraitCompositionFromExistingClass;
	copyClassSlotsFromExistingClass ] in OldClassBuilderAdapter>>name:inEnvironment:subclassOf:type:instanceVariableNames:classVariableNames:poolDictionaries:category:
	Receiver: an OldClassBuilderAdapter
	Arguments and temporary variables: 
		name: 	#NameOfSubclass
		environment: 	a SystemDictionary(lots of globals)
		superClass: 	Object
		type: 	#normal
		instanceVariablesString: 	'stream'
		classVariablesString: 	''
		sharedPoolsString: 	''
		category: 	'SmaCC-Tutorial'
		builder: 	a SlotClassBuilder
	Receiver's instance variables: 
an OldClassBuilderAdapter

PharoClassInstaller class(AbstractClassInstaller class)>>make:
	Receiver: PharoClassInstaller
	Arguments and temporary variables: 
		aBlock: 	[ :builder | 
builder
	superclass: superClass;
	name: name;
	layoutClas...etc...
		builder: 	a SlotClassBuilder
	Receiver's instance variables: 
		superclass: 	AbstractClassInstaller
		methodDict: 	a MethodDictionary(#basicClassDefinitionChangedFrom:to:using:->Phar...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#('environment' 'instanceModification' 'methodUpdateStrategy...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoClassInstaller
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Slot-ClassBuilder'
		traitComposition: 	{}
		localSelectors: 	nil


OldClassBuilderAdapter>>name:inEnvironment:subclassOf:type:instanceVariableNames:classVariableNames:poolDictionaries:category:
	Receiver: an OldClassBuilderAdapter
	Arguments and temporary variables: 
		name: 	#NameOfSubclass
		environment: 	a SystemDictionary(lots of globals)
		superClass: 	Object
		type: 	#normal
		instanceVariablesString: 	'stream'
		classVariablesString: 	''
		sharedPoolsString: 	''
		category: 	'SmaCC-Tutorial'
	Receiver's instance variables: 
an OldClassBuilderAdapter

OldClassBuilderAdapter>>superclass:subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
	Receiver: an OldClassBuilderAdapter
	Arguments and temporary variables: 
		newSuper: 	Object
		t: 	#NameOfSubclass
		f: 	'stream'
		d: 	''
		s: 	''
		cat: 	'SmaCC-Tutorial'
	Receiver's instance variables: 
an OldClassBuilderAdapter

Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
	Receiver: Object
	Arguments and temporary variables: 
		t: 	#NameOfSubclass
		f: 	'stream'
		d: 	''
		s: 	''
		cat: 	'SmaCC-Tutorial'
		class: 	nil
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 382)
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{BalloonState. UndefinedObject. Boolean. FillStyle. ConnectionQueue...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary(a GLMGen...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'
		traitComposition: 	{}
		localSelectors: 	nil


Object class(Class)>>subclass:instanceVariableNames:classVariableNames:category:
	Receiver: Object
	Arguments and temporary variables: 
		aSubclassSymbol: 	#NameOfSubclass
		instVarNames: 	'stream'
		classVarNames: 	''
		aCategorySymbol: 	'SmaCC-Tutorial'
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 382)
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{BalloonState. UndefinedObject. Boolean. FillStyle. ConnectionQueue...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary(a GLMGen...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Object
		subclass: #NameOfSubclass
		instanceVariableNames: 'strea...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'Object subclass: #NameOfSubclass
	instanceVariableNames: ''stream''
	...etc...
		aController: 	a PluggableTextMorphWithLimits(1035206656)
		aClass: 	nil
		oldClass: 	nil
		class: 	nil
		newClassName: 	'NameOfSubclass'
		defTokens: 	an OrderedCollection('Object' 'subclass:' '#NameOfSubclass' 'instanc...etc...
		keywdIx: 	2
		envt: 	a SystemDictionary(lots of globals)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'smaCC-Tuto'


PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'Object subclass: #NameOfSubclass
	instanceVariableNames: ''stream''
	...etc...
		aController: 	a PluggableTextMorphWithLimits(1035206656)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'smaCC-Tuto'


ClassDefinitionAcceptor>>accept:notifying:
	Receiver: a ClassDefinitionAcceptor
	Arguments and temporary variables: 
		aText: 	'Object subclass: #NameOfSubclass
	instanceVariableNames: ''stream''
	cl...etc...
		aController: 	a PluggableTextMorphWithLimits(1035206656)
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for 'Object subclass: #NameOfSubclass
	instanceVariableNames: ''s...etc...
		aController: 	a PluggableTextMorphWithLimits(1035206656)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'smaCC-Tuto'


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'Object subclass: #NameOfSubclass
	instanceVariableNam...etc...
	Receiver's instance variables: 
		bounds: 	(115.0@356.0) corner: (931.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(115@356) corner: (931@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(65 to: 64)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	64
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'Object subclass: #NameOfSubclass
	instanceVariableNam...etc...
	Receiver's instance variables: 
		bounds: 	(115.0@356.0) corner: (931.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(115@356) corner: (931@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(65 to: 64)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(65 to: 64)
		saveScrollerOffset: 	(-3.0@0.0)
	Receiver's instance variables: 
		bounds: 	(115.0@356.0) corner: (931.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(115@356) corner: (931@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(65 to: 64)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(115.0@356.0) corner: (931.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(115@356) corner: (931@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(65 to: 64)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(115.0@356.0) corner: (931.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(115@356) corner: (931@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(65 to: 64)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView>>acceptContents
	Receiver: a TextMorphForEditView(549715968)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@78)
		owner: 	a TransformMorph(700448768)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@78)
		color: 	Color black
		extension: 	a MorphExtension (601620480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'Object subclass: #NameOfSubclass
	instanceVariableNames: ''st...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(1035206656)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
	Receiver: TextMorph
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a TextMorphForEditView(549715968)
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(size 206)
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#textStyle #text #wrapFlag #paragraph #editor #container #...etc...
		organization: 	a ClassOrganization
		subclasses: 	{StringMorphEditor. TextMorphForEditView. GrowlMorph}
		name: 	#TextMorph
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-Basic'
		traitComposition: 	TAbleToRotate
		localSelectors: 	a Set(#editorClass #setTextStyle: #setFirstCharacter: #margins:...etc...
		announcer: 	nil


BlockClosure>>cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		anArg: 	a TextMorphForEditView(549715968)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	56
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(549715968)
		secondArg: 	a TextMorphForEditView(549715968)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	56
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(549715968)
		secondArg: 	a TextMorphForEditView(549715968)
		thirdArg: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	56
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		aKeymap: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(549715968)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(549715968)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		l: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#accept on Ctrl + S do [ :morph | morph acceptContents ]
)
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	4
		each: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil nil #accept on Ctrl + S do [ :morph | morph acceptConte...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(549715968)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(549715968)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(549715968)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	3


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(549715968)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a TextMorphForEditView(549715968)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher



--- The full stack ---
SlotClassBuilder>>validateClassName
SlotClassBuilder>>name:
[ :builder | 
builder
	superclass: superClass;
	name: name;
	layoutClass: (self layoutForType: type);
	slots: instanceVariablesString asSlotCollection;
	sharedVariablesFromString: classVariablesString;
	sharedPools: sharedPoolsString;
	category: category;
	environment: environment;
	copyTraitCompositionFromExistingClass;
	copyClassSlotsFromExistingClass ] in OldClassBuilderAdapter>>name:inEnvironment:subclassOf:type:instanceVariableNames:classVariableNames:poolDictionaries:category:
PharoClassInstaller class(AbstractClassInstaller class)>>make:
OldClassBuilderAdapter>>name:inEnvironment:subclassOf:type:instanceVariableNames:classVariableNames:poolDictionaries:category:
OldClassBuilderAdapter>>superclass:subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:category:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
ClassDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
TextMorphForEditView>>acceptContents
[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Calculator class>>visitCalcAddExprNode:
30 October 2015 11:50:28.437991 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

Calculator class(Object)>>doesNotUnderstand: #visitCalcAddExprNode:
	Receiver: Calculator
	Arguments and temporary variables: 
		aMessage: 	visitCalcAddExprNode: a CalcAddExprNode
		exception: 	MessageNotUnderstood: Calculator class>>visitCalcAddExprNode:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#visitCalcAddExprNode:->Calculator>>#visitCalcAd...etc...
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Calculator
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'SmaCC-Tutorial'
		traitComposition: 	{}
		localSelectors: 	nil


CalcAddExprNode>>accept:
	Receiver: a CalcAddExprNode
	Arguments and temporary variables: 
		aVisitor: 	Calculator
	Receiver's instance variables: 
		arg1: 	a CalcAddExprNode
		arg2: 	a CalcNumberNode


CalcAddExprNode>>DoIt
	Receiver: a CalcAddExprNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		arg1: 	a CalcAddExprNode
		arg2: 	a CalcNumberNode


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'self accept: Calculator.new'
		itsSelection: 	a Text for 'self accept: Calculator.new'
		itsSelectionString: 	'self accept: Calculator.new'
	Receiver's instance variables: 
		ast: 	DoIt
	self accept: Calculator.
	^ new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a CalcAddExprNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a CalcAddExprNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(117440512)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(117440512)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(522977280)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(117440512)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (570@50)
		owner: 	a TransformWithLayoutMorph(644612096)
		submorphs: 	an Array(a RubPrimarySelectionMorph(959709184) a RubCursor(539754496...etc...
		fullBounds: 	(0@0) corner: (570@50)
		color: 	Color transparent
		extension: 	a MorphExtension (655884288) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(606339072)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(539754496)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(893911040))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(522977280)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	1306169
		lastStepMessage: 	nil
		lastCycleTime: 	1306169
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(539754496)))
		lastAlarmTime: 	1306169
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(957612032) a St...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	1306169
		lastStepMessage: 	nil
		lastCycleTime: 	1306169
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(539754496)))
		lastAlarmTime: 	1306169
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	1306169
		lastStepMessage: 	nil
		lastCycleTime: 	1306169
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(539754496)))
		lastAlarmTime: 	1306169
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(957612032) a St...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Calculator class(Object)>>doesNotUnderstand: #visitCalcAddExprNode:
CalcAddExprNode>>accept:
CalcAddExprNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniVoidScope class>>default
5 November 2015 11:31:20.564231 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScope class(Object)>>doesNotUnderstand: #default
	Receiver: MiniVoidScope
	Arguments and temporary variables: 
		aMessage: 	default
		exception: 	MessageNotUnderstood: MiniVoidScope class>>default
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	MiniScope
		methodDict: 	a MethodDictionary()
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MiniVoidScope
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil
		default: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ MiniVoidScope default
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(742916096)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(742916096)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(572260352)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(742916096)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(705953792)
		submorphs: 	an Array(a RubPrimarySelectionMorph(364118016) a RubCursor(73400320)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (105119744) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(673710080)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(73400320)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(876085248))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(572260352)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(481820672))(a DropList...etc...
		lastStepTime: 	2010009
		lastStepMessage: 	nil
		lastCycleTime: 	2010029
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(73400320)))
		lastAlarmTime: 	2010009
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1366@705)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(279969792) a Na...etc...
		fullBounds: 	(0@0) corner: (1366@705)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(481820672))(a DropList...etc...
		lastStepTime: 	2010009
		lastStepMessage: 	nil
		lastCycleTime: 	2010029
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(73400320)))
		lastAlarmTime: 	2010009
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(481820672))(a DropList...etc...
		lastStepTime: 	2010009
		lastStepMessage: 	nil
		lastCycleTime: 	2010029
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(73400320)))
		lastAlarmTime: 	2010009
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1366@705)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(279969792) a Na...etc...
		fullBounds: 	(0@0) corner: (1366@705)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniVoidScope class(Object)>>doesNotUnderstand: #default
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ShouldNotImplement: MiniVoidScope is a singleton!
5 November 2015 11:35:03.574231 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScope class>>new
	Receiver: MiniVoidScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	MiniScope
		methodDict: 	a MethodDictionary()
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MiniVoidScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil
		default: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ MiniVoidScope new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(330039296)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(330039296)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(173277184)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(330039296)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(294912000)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1062469632) a RubCursor(72823603...etc...
		fullBounds: 	(0@0) corner: (580@31)
		color: 	Color transparent
		extension: 	a MorphExtension (772014080) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(256638976)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(728236032)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(998506496))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(173277184)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(481820672))(a DropList...etc...
		lastStepTime: 	2233150
		lastStepMessage: 	nil
		lastCycleTime: 	2233149
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(728236032)))
		lastAlarmTime: 	2233150
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1366@705)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(455344128) a Na...etc...
		fullBounds: 	(0@0) corner: (1366@705)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(481820672))(a DropList...etc...
		lastStepTime: 	2233150
		lastStepMessage: 	nil
		lastCycleTime: 	2233149
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(728236032)))
		lastAlarmTime: 	2233150
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(481820672))(a DropList...etc...
		lastStepTime: 	2233150
		lastStepMessage: 	nil
		lastCycleTime: 	2233149
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(728236032)))
		lastAlarmTime: 	2233150
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1366@705)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(455344128) a Na...etc...
		fullBounds: 	(0@0) corner: (1366@705)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniVoidScope class>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
5 November 2015 11:35:30.291231 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ MiniVoidScope halt default
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(330039296)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(330039296)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(173277184)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(330039296)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(294912000)
		submorphs: 	an Array(a RubPrimarySelectionMorph(858521600) a RubCursor(728236032...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (772014080) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(256638976)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(728236032)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(233046016))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(173277184)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#browseClassVars 892076032))(...etc...
		lastStepTime: 	2259798
		lastStepMessage: 	nil
		lastCycleTime: 	2259820
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(728236032)))
		lastAlarmTime: 	2259798
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1366@705)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(455344128) a Na...etc...
		fullBounds: 	(0@0) corner: (1366@705)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#browseClassVars 892076032))(...etc...
		lastStepTime: 	2259798
		lastStepMessage: 	nil
		lastCycleTime: 	2259820
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(728236032)))
		lastAlarmTime: 	2259798
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#browseClassVars 892076032))(...etc...
		lastStepTime: 	2259798
		lastStepMessage: 	nil
		lastCycleTime: 	2259820
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(728236032)))
		lastAlarmTime: 	2259798
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1366@705)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(455344128) a Na...etc...
		fullBounds: 	(0@0) corner: (1366@705)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
5 November 2015 11:35:39.496231 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ MiniVoidScope halt default
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(330039296)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(330039296)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(173277184)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(330039296)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(294912000)
		submorphs: 	an Array(a RubPrimarySelectionMorph(858521600) a RubCursor(728236032...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (772014080) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(256638976)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(728236032)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(613679104))
		getMenuPolicy: 	a RubEditingArea(330039296)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(173277184)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#browseClassVars 892076032))(...etc...
		lastStepTime: 	2269003
		lastStepMessage: 	nil
		lastCycleTime: 	2269027
		alarms: 	a Heap()
		lastAlarmTime: 	2269003
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1366@705)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(455344128) a Na...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#browseClassVars 892076032))(...etc...
		lastStepTime: 	2269003
		lastStepMessage: 	nil
		lastCycleTime: 	2269027
		alarms: 	a Heap()
		lastAlarmTime: 	2269003
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#browseClassVars 892076032))(...etc...
		lastStepTime: 	2269003
		lastStepMessage: 	nil
		lastCycleTime: 	2269027
		alarms: 	a Heap()
		lastAlarmTime: 	2269003
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneSubCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		currentHand: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#browseClassVars 892076032))(...etc...
		lastStepTime: 	2269003
		lastStepMessage: 	nil
		lastCycleTime: 	2269027
		alarms: 	a Heap()
		lastAlarmTime: 	2269003
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneSubCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1366@705)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(455344128) a Na...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


MenuMorph>>invokeModalAt:in:allowKeyboard:
	Receiver: a MenuMorph(1046478848)
	Arguments and temporary variables: 
		aPoint: 	(328@253.0)
		aWorld: 	a WorldMorph(511705088) [world]
		aBoolean: 	true
		w: 	a WorldMorph(511705088) [world]
		originalFocusHolder: 	a RubEditingArea(330039296)
	Receiver's instance variables: 
		bounds: 	(326.0@245.0) corner: (518.0@479.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(804782080)'Do it and go' a ToggleMenu...etc...
		fullBounds: 	(326.0@245.0) corner: (518.0@479.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (21757952) [other:  (basicColor -> (Color r: 0.8230...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(414711808)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(804782080)'Do it and go' ...etc...
		basicColor: 	nil


MenuMorph>>invokeModal:
	Receiver: a MenuMorph(1046478848)
	Arguments and temporary variables: 
		allowKeyboardControl: 	true
	Receiver's instance variables: 
		bounds: 	(326.0@245.0) corner: (518.0@479.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(804782080)'Do it and go' a ToggleMenu...etc...
		fullBounds: 	(326.0@245.0) corner: (518.0@479.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (21757952) [other:  (basicColor -> (Color r: 0.8230...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(414711808)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(804782080)'Do it and go' ...etc...
		basicColor: 	nil


MenuMorph>>invokeModal
	Receiver: a MenuMorph(1046478848)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(326.0@245.0) corner: (518.0@479.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(804782080)'Do it and go' a ToggleMenu...etc...
		fullBounds: 	(326.0@245.0) corner: (518.0@479.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (21757952) [other:  (basicColor -> (Color r: 0.8230...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(414711808)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(804782080)'Do it and go' ...etc...
		basicColor: 	nil


[ :menu | 
menu setInvokingView: self editor.
menu invokeModal.
self changed.
^ true ] in RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
	Receiver: a RubEditingArea(330039296)
	Arguments and temporary variables: 
		shiftKeyState: 	false
		menu: 	a MenuMorph(1046478848)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(294912000)
		submorphs: 	an Array(a RubPrimarySelectionMorph(858521600) a RubCursor(728236032...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (772014080) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(256638976)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(728236032)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(613679104))
		getMenuPolicy: 	a RubEditingArea(330039296)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


MenuMorph(Object)>>ifNotNilDo:
	Receiver: a MenuMorph(1046478848)
	Arguments and temporary variables: 
		aBlock: 	[ :menu | 
menu setInvokingView: self editor.
menu invokeModal.
self ch...etc...
	Receiver's instance variables: 
		bounds: 	(326.0@245.0) corner: (518.0@479.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(804782080)'Do it and go' a ToggleMenu...etc...
		fullBounds: 	(326.0@245.0) corner: (518.0@479.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (21757952) [other:  (basicColor -> (Color r: 0.8230...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(414711808)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(804782080)'Do it and go' ...etc...
		basicColor: 	nil


RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
	Receiver: a RubEditingArea(330039296)
	Arguments and temporary variables: 
		shiftKeyState: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(294912000)
		submorphs: 	an Array(a RubPrimarySelectionMorph(858521600) a RubCursor(728236032...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (772014080) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(256638976)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(728236032)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(613679104))
		getMenuPolicy: 	a RubEditingArea(330039296)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>mouseDown:
	Receiver: a RubEditingArea(330039296)
	Arguments and temporary variables: 
		evt: 	[(163@20) mouseDown yellow 339870890 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(294912000)
		submorphs: 	an Array(a RubPrimarySelectionMorph(858521600) a RubCursor(728236032...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (772014080) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(256638976)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(728236032)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(613679104))
		getMenuPolicy: 	a RubEditingArea(330039296)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>handleMouseDown:
	Receiver: a RubEditingArea(330039296)
	Arguments and temporary variables: 
		anEvent: 	[(163@20) mouseDown yellow 339870890 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(294912000)
		submorphs: 	an Array(a RubPrimarySelectionMorph(858521600) a RubCursor(728236032...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (772014080) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(256638976)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(728236032)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(613679104))
		getMenuPolicy: 	a RubEditingArea(330039296)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


MouseButtonEvent>>sentTo:
	Receiver: [(163@20) mouseDown yellow 339870890 nil]
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(330039296)
	Receiver's instance variables: 
		timeStamp: 	339870890
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	2
		position: 	(163@20)
		handler: 	a RubEditingArea(330039296)
		wasHandled: 	true
		whichButton: 	2


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(330039296)
	Arguments and temporary variables: 
		anEvent: 	[(163@20) mouseDown yellow 339870890 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(294912000)
		submorphs: 	an Array(a RubPrimarySelectionMorph(858521600) a RubCursor(728236032...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (772014080) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(256638976)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(728236032)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(613679104))
		getMenuPolicy: 	a RubEditingArea(330039296)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(163@20) mouseDown yellow 339870890 nil]
		aMorph: 	a RubEditingArea(330039296)
		globalPt: 	(163@20)
		localEvt: 	[(163@20) mouseDown yellow 339870890 nil]
		index: 	3
		child: 	a RubCursor(728236032)
		morphs: 	an Array(a RubPrimarySelectionMorph(858521600) a RubCursor(728236032))
		handler: 	a RubEditingArea(330039296)
		inside: 	nil
		lastHandler: 	a RubScrolledTextMorph(173277184)
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseDown:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(163@20) mouseDown yellow 339870890 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(163@20) mouseDown yellow 339870890 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	339870890
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	2
		position: 	(163@20)
		handler: 	a RubEditingArea(330039296)
		wasHandled: 	true
		whichButton: 	2


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(163@20) mouseDown yellow 339870890 nil]
		aMorph: 	a RubEditingArea(330039296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(163@20) mouseDown yellow 339870890 nil]
		aMorph: 	a RubEditingArea(330039296)
	Receiver's instance variables: 
		morph: 	nil


RubEditingArea(Morph)>>processEvent:using:
	Receiver: a RubEditingArea(330039296)
	Arguments and temporary variables: 
		anEvent: 	[(163@20) mouseDown yellow 339870890 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(294912000)
		submorphs: 	an Array(a RubPrimarySelectionMorph(858521600) a RubCursor(728236032...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (772014080) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(256638976)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(728236032)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(613679104))
		getMenuPolicy: 	a RubEditingArea(330039296)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(328@253) mouseDown yellow 339870890 nil]
		aMorph: 	a TransformWithLayoutMorph(294912000)
		globalPt: 	(328@253)
		localEvt: 	[(163@20) mouseDown yellow 339870890 nil]
		index: 	1
		child: 	a RubEditingArea(330039296)
		morphs: 	an Array(a RubEditingArea(330039296))
		handler: 	nil
		inside: 	nil
		lastHandler: 	a RubScrolledTextMorph(173277184)
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseDown:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(328@253) mouseDown yellow 339870890 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(328@253) mouseDown yellow 339870890 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	339870890
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	2
		position: 	(328@253)
		handler: 	a RubScrolledTextMorph(173277184)
		wasHandled: 	false
		whichButton: 	2


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(328@253) mouseDown yellow 339870890 nil]
		aMorph: 	a TransformWithLayoutMorph(294912000)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(328@253) mouseDown yellow 339870890 nil]
		aMorph: 	a TransformWithLayoutMorph(294912000)
	Receiver's instance variables: 
		morph: 	nil


TransformWithLayoutMorph(Morph)>>processEvent:using:
	Receiver: a TransformWithLayoutMorph(294912000)
	Arguments and temporary variables: 
		anEvent: 	[(328@253) mouseDown yellow 339870890 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(165@233) corner: (745@571)
		owner: 	a RubTextScrollPane(256638976)
		submorphs: 	an Array(a RubEditingArea(330039296))
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (330563584) [other:  (kmDispatcher -> a KMDispatche...etc...
		transform: 	a MorphicTransform(angle = 0.0; scale = 1.0; offset = (-165@ -233))
		smoothing: 	1
		localBounds: 	nil


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(328@253) mouseDown yellow 339870890 nil]
		aMorph: 	a RubTextScrollPane(256638976)
		globalPt: 	(328@253)
		localEvt: 	[(328@253) mouseDown yellow 339870890 nil]
		index: 	1
		child: 	a TransformWithLayoutMorph(294912000)
		morphs: 	an Array(a TransformWithLayoutMorph(294912000))
		handler: 	nil
		inside: 	nil
		lastHandler: 	a RubScrolledTextMorph(173277184)
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseDown:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(328@253) mouseDown yellow 339870890 nil]
	Receiver's instance variables: 
		morph: 	nil



--- The full stack ---
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldState>>doOneSubCycleFor:
WorldMorph>>doOneSubCycle
MenuMorph>>invokeModalAt:in:allowKeyboard:
MenuMorph>>invokeModal:
MenuMorph>>invokeModal
[ :menu | 
menu setInvokingView: self editor.
menu invokeModal.
self changed.
^ true ] in RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
MenuMorph(Object)>>ifNotNilDo:
RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
RubEditingArea(RubAbstractTextArea)>>mouseDown:
RubEditingArea(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubEditingArea(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubTextScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubScrolledTextMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
LazyTabGroupMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
GLMMorphBrick(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
GLMScrollPaneBandBrick(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
GLMPagerScrollBrick(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
GLMPagerBrick(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
GLMFoundationBrick(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
GLMSystemWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniVoidScope class>>globalScope
5 November 2015 11:40:02.532231 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScope class(Object)>>doesNotUnderstand: #globalScope
	Receiver: MiniVoidScope
	Arguments and temporary variables: 
		aMessage: 	globalScope
		exception: 	MessageNotUnderstood: MiniVoidScope class>>globalScope
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	MiniScope
		methodDict: 	a MethodDictionary()
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MiniVoidScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil
		default: 	a MiniVoidScope


[ MiniVoidScope globalScope ] in MiniVoidScopeTestCase>>testForbiddenMethods
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 
		aBlock: 	[ MiniVoidScope globalScope ]
		anExceptionalEvent: 	ShouldNotImplement
	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>on:do:
	Receiver: [ 
aBlock value.
false ]
	Arguments and temporary variables: 
		exception: 	ShouldNotImplement
		handlerAction: 	[ :ex | ex return: true ]
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
		startpc: 	26
		numArgs: 	0


MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 
		aBlock: 	[ MiniVoidScope globalScope ]
		anExceptionalEvent: 	ShouldNotImplement
	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestAsserter)>>should:raise:
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 
		aBlock: 	[ MiniVoidScope globalScope ]
		anExceptionalEvent: 	ShouldNotImplement
	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testForbiddenMethods
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testForbiddenMethods
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testForbiddenMethods)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testForbiddenMethods)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testForbiddenMethods)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testForbiddenMethods)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase MiniEnvironmentTestCase MiniScopeT...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnvi...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194368
		result: 	15 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 15 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	15 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 15 err...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase MiniEnvironmentTestCase MiniScopeT...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnvi...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194368
		result: 	15 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 15 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase MiniEnvironmentTestCase MiniScopeT...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnvi...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194368
		result: 	15 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 15 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase MiniEnvironmentTestCase MiniScopeT...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnvi...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194368
		result: 	15 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 15 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testForbiddenMethods
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase MiniEnvironmentTestCase MiniScopeT...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnvi...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194368
		result: 	15 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 15 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	8
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase MiniEnvironmentTestCase MiniScopeT...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnvi...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194368
		result: 	15 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 15 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	8
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a ScrollBar(729284608) a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(669@532) mouseUp 340138312 nil]
		row: 	8
		mdr: 	8
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a ScrollBar(729284608) a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(669@532) mouseUp 340138312 nil]
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a ScrollBar(729284608) a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(669@532) mouseUp 340138312 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a ScrollBar(729284608) a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(669@532) mouseUp 340138312 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	340138312
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(669@532)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(669@532) mouseUp 340138312 nil]
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a ScrollBar(729284608) a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(669@532) mouseUp 340138312 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(669@532) mouseUp 340138312 nil]
		index: 	3
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a ScrollBar(729284608) a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(669@532) mouseUp 340138312 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(669@532) mouseUp 340138312 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	340138312
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(669@532)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(669@532) mouseUp 340138312 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0



--- The full stack ---
MiniVoidScope class(Object)>>doesNotUnderstand: #globalScope
[ MiniVoidScope globalScope ] in MiniVoidScopeTestCase>>testForbiddenMethods
[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
BlockClosure>>on:do:
MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
MiniVoidScopeTestCase(TestAsserter)>>should:raise:
MiniVoidScopeTestCase>>testForbiddenMethods
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniVoidScope class>>globalScope
5 November 2015 11:40:15.615231 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScope class(Object)>>doesNotUnderstand: #globalScope
	Receiver: MiniVoidScope
	Arguments and temporary variables: 
		aMessage: 	globalScope
		exception: 	MessageNotUnderstood: MiniVoidScope class>>globalScope
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	MiniScope
		methodDict: 	a MethodDictionary()
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MiniVoidScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil
		default: 	a MiniVoidScope


[ MiniVoidScope globalScope ] in MiniVoidScopeTestCase>>testForbiddenMethods
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 
		aBlock: 	[ MiniVoidScope globalScope ]
		anExceptionalEvent: 	ShouldNotImplement
	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>on:do:
	Receiver: [ 
aBlock value.
false ]
	Arguments and temporary variables: 
		exception: 	ShouldNotImplement
		handlerAction: 	[ :ex | ex return: true ]
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
		startpc: 	26
		numArgs: 	0


MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 
		aBlock: 	[ MiniVoidScope globalScope ]
		anExceptionalEvent: 	ShouldNotImplement
	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestAsserter)>>should:raise:
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 
		aBlock: 	[ MiniVoidScope globalScope ]
		anExceptionalEvent: 	ShouldNotImplement
	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testForbiddenMethods
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testForbiddenMethods
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testForbiddenMethods)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testForbiddenMethods)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testForbiddenMethods)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testForbiddenMethods)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods MiniVoidScopeT...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194414
		result: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods MiniVoidScopeT...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194414
		result: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods MiniVoidScopeT...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194414
		result: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods MiniVoidScopeT...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194414
		result: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testForbiddenMethods
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods MiniVoidScopeT...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194414
		result: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods MiniVoidScopeT...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194414
		result: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testForbiddenMethods' 'MiniVoidScopeTestCase>>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(603@410) mouseUp 340151421 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testForbiddenMethods' 'MiniVoidScopeTestCase>>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(603@410) mouseUp 340151421 nil]
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testForbiddenMethods' 'MiniVoidScopeTestCase>>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(603@410) mouseUp 340151421 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testForbiddenMethods' 'MiniVoidScopeTestCase>>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(603@410) mouseUp 340151421 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	340151421
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(603@410)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(603@410) mouseUp 340151421 nil]
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testForbiddenMethods' 'MiniVoidScopeTestCase>>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(603@410) mouseUp 340151421 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(603@410) mouseUp 340151421 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(603@410) mouseUp 340151421 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(603@410) mouseUp 340151421 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	340151421
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(603@410)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(603@410) mouseUp 340151421 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0



--- The full stack ---
MiniVoidScope class(Object)>>doesNotUnderstand: #globalScope
[ MiniVoidScope globalScope ] in MiniVoidScopeTestCase>>testForbiddenMethods
[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
BlockClosure>>on:do:
MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
MiniVoidScopeTestCase(TestAsserter)>>should:raise:
MiniVoidScopeTestCase>>testForbiddenMethods
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniVoidScope class>>newScopeIn:
5 November 2015 11:42:42.048231 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScope class(Object)>>doesNotUnderstand: #newScopeIn:
	Receiver: MiniVoidScope
	Arguments and temporary variables: 
		aMessage: 	newScopeIn: a MiniScope
		exception: 	MessageNotUnderstood: MiniVoidScope class>>newScopeIn:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	MiniScope
		methodDict: 	a MethodDictionary()
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MiniVoidScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil
		default: 	a MiniVoidScope


[ MiniVoidScope newScopeIn: MiniScope new ] in MiniVoidScopeTestCase>>testForbiddenMethods
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 
		aBlock: 	[ MiniVoidScope newScopeIn: MiniScope new ]
		anExceptionalEvent: 	ShouldNotImplement
	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>on:do:
	Receiver: [ 
aBlock value.
false ]
	Arguments and temporary variables: 
		exception: 	ShouldNotImplement
		handlerAction: 	[ :ex | ex return: true ]
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
		startpc: 	26
		numArgs: 	0


MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 
		aBlock: 	[ MiniVoidScope newScopeIn: MiniScope new ]
		anExceptionalEvent: 	ShouldNotImplement
	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestAsserter)>>should:raise:
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 
		aBlock: 	[ MiniVoidScope newScopeIn: MiniScope new ]
		anExceptionalEvent: 	ShouldNotImplement
	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testForbiddenMethods
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testForbiddenMethods
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testForbiddenMethods)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testForbiddenMethods)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testForbiddenMethods)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testForbiddenMethods)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods MiniVoidScopeT...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194560
		result: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods MiniVoidScopeT...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194560
		result: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods MiniVoidScopeT...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194560
		result: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods MiniVoidScopeT...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194560
		result: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testForbiddenMethods
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods MiniVoidScopeT...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194560
		result: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods MiniVoidScopeT...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194560
		result: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testForbiddenMethods' 'MiniVoidScopeTestCase>>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(588@412) mouseUp 340297859 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testForbiddenMethods' 'MiniVoidScopeTestCase>>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(588@412) mouseUp 340297859 nil]
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testForbiddenMethods' 'MiniVoidScopeTestCase>>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(588@412) mouseUp 340297859 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testForbiddenMethods' 'MiniVoidScopeTestCase>>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(588@412) mouseUp 340297859 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	340297859
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(588@412)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(588@412) mouseUp 340297859 nil]
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testForbiddenMethods' 'MiniVoidScopeTestCase>>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(588@412) mouseUp 340297859 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(588@412) mouseUp 340297859 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(588@412) mouseUp 340297859 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(588@412) mouseUp 340297859 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	340297859
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(588@412)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(588@412) mouseUp 340297859 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0



--- The full stack ---
MiniVoidScope class(Object)>>doesNotUnderstand: #newScopeIn:
[ MiniVoidScope newScopeIn: MiniScope new ] in MiniVoidScopeTestCase>>testForbiddenMethods
[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
BlockClosure>>on:do:
MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
MiniVoidScopeTestCase(TestAsserter)>>should:raise:
MiniVoidScopeTestCase>>testForbiddenMethods
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniVoidScope class>>newScopeIn:
5 November 2015 11:42:43.177231 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScope class(Object)>>doesNotUnderstand: #newScopeIn:
	Receiver: MiniVoidScope
	Arguments and temporary variables: 
		aMessage: 	newScopeIn: a MiniScope
		exception: 	MessageNotUnderstood: MiniVoidScope class>>newScopeIn:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	MiniScope
		methodDict: 	a MethodDictionary()
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MiniVoidScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil
		default: 	a MiniVoidScope


[ MiniVoidScope newScopeIn: MiniScope new ] in MiniVoidScopeTestCase>>testForbiddenMethods
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 
		aBlock: 	[ MiniVoidScope newScopeIn: MiniScope new ]
		anExceptionalEvent: 	ShouldNotImplement
	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>on:do:
	Receiver: [ 
aBlock value.
false ]
	Arguments and temporary variables: 
		exception: 	ShouldNotImplement
		handlerAction: 	[ :ex | ex return: true ]
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
		startpc: 	26
		numArgs: 	0


MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 
		aBlock: 	[ MiniVoidScope newScopeIn: MiniScope new ]
		anExceptionalEvent: 	ShouldNotImplement
	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestAsserter)>>should:raise:
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 
		aBlock: 	[ MiniVoidScope newScopeIn: MiniScope new ]
		anExceptionalEvent: 	ShouldNotImplement
	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testForbiddenMethods
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testForbiddenMethods
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testForbiddenMethods
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testForbiddenMethods
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testForbiddenMethods)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testForbiddenMethods)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testForbiddenMethods)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testForbiddenMethods)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods MiniVoidScopeT...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194560
		result: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods MiniVoidScopeT...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194560
		result: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods MiniVoidScopeT...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194560
		result: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods MiniVoidScopeT...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194560
		result: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testForbiddenMethods
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods MiniVoidScopeT...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194560
		result: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testForbiddenMethods MiniVoidScopeT...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testForbiddenMethods
		lastUpdate: 	3624194560
		result: 	8 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 8 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testForbiddenMethods' 'MiniVoidScopeTestCase>>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(588@412) mouseUp 340298984 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testForbiddenMethods' 'MiniVoidScopeTestCase>>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(588@412) mouseUp 340298984 nil]
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testForbiddenMethods' 'MiniVoidScopeTestCase>>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(588@412) mouseUp 340298984 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testForbiddenMethods' 'MiniVoidScopeTestCase>>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(588@412) mouseUp 340298984 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	340298984
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(588@412)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(588@412) mouseUp 340298984 nil]
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testForbiddenMethods' 'MiniVoidScopeTestCase>>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(588@412) mouseUp 340298984 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(588@412) mouseUp 340298984 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(588@412) mouseUp 340298984 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(588@412) mouseUp 340298984 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	340298984
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(588@412)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(588@412) mouseUp 340298984 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0



--- The full stack ---
MiniVoidScope class(Object)>>doesNotUnderstand: #newScopeIn:
[ MiniVoidScope newScopeIn: MiniScope new ] in MiniVoidScopeTestCase>>testForbiddenMethods
[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
BlockClosure>>on:do:
MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
MiniVoidScopeTestCase(TestAsserter)>>should:raise:
MiniVoidScopeTestCase>>testForbiddenMethods
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniVoidScope>>bind:to:
5 November 2015 11:43:36.735231 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScope(Object)>>doesNotUnderstand: #bind:to:
	Receiver: a MiniVoidScope
	Arguments and temporary variables: 
		aMessage: 	bind: 'foo' to: 7
		exception: 	MessageNotUnderstood: MiniVoidScope>>bind:to:
		resumeValue: 	nil
	Receiver's instance variables: 
		outerScope: 	nil
		bindings: 	nil


[ self voidScope bind: 'foo' to: 7 ] in MiniVoidScopeTestCase>>testVoidScopeBindTo
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope bind: 'foo' to: 7 ]
		anExceptionalEvent: 	nil
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>on:do:
	Receiver: [ 
aBlock value.
false ]
	Arguments and temporary variables: 
		exception: 	nil
		handlerAction: 	[ :ex | ex return: true ]
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
		startpc: 	26
		numArgs: 	0


MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope bind: 'foo' to: 7 ]
		anExceptionalEvent: 	nil
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestAsserter)>>should:raise:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope bind: 'foo' to: 7 ]
		anExceptionalEvent: 	nil
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeBindTo
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindTo)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindTo)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindTo nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindTo)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindTo)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindTo MiniVoidScopeTe...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindTo
		lastUpdate: 	3624194601
		result: 	8 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 7 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 7 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindTo MiniVoidScopeTe...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindTo
		lastUpdate: 	3624194601
		result: 	8 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 7 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindTo MiniVoidScopeTe...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindTo
		lastUpdate: 	3624194601
		result: 	8 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 7 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindTo MiniVoidScopeTe...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindTo
		lastUpdate: 	3624194601
		result: 	8 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 7 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindTo MiniVoidScopeTe...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindTo
		lastUpdate: 	3624194601
		result: 	8 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 7 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindTo MiniVoidScopeTe...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindTo
		lastUpdate: 	3624194601
		result: 	8 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 7 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindTo' 'MiniVoidScopeTestCase>>#...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(582@409) mouseUp 340352531 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindTo' 'MiniVoidScopeTestCase>>#...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(582@409) mouseUp 340352531 nil]
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindTo' 'MiniVoidScopeTestCase>>#...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(582@409) mouseUp 340352531 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindTo' 'MiniVoidScopeTestCase>>#...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(582@409) mouseUp 340352531 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	340352531
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(582@409)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(582@409) mouseUp 340352531 nil]
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindTo' 'MiniVoidScopeTestCase>>#...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(582@409) mouseUp 340352531 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(582@409) mouseUp 340352531 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(582@409) mouseUp 340352531 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(582@409) mouseUp 340352531 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	340352531
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(582@409)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(582@409) mouseUp 340352531 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0



--- The full stack ---
MiniVoidScope(Object)>>doesNotUnderstand: #bind:to:
[ self voidScope bind: 'foo' to: 7 ] in MiniVoidScopeTestCase>>testVoidScopeBindTo
[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
BlockClosure>>on:do:
MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
MiniVoidScopeTestCase(TestAsserter)>>should:raise:
MiniVoidScopeTestCase>>testVoidScopeBindTo
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniVoidScope>>bind:to:
5 November 2015 11:48:42.118231 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScope(Object)>>doesNotUnderstand: #bind:to:
	Receiver: a MiniVoidScope
	Arguments and temporary variables: 
		aMessage: 	bind: 'foo' to: 7
		exception: 	MessageNotUnderstood: MiniVoidScope>>bind:to:
		resumeValue: 	nil
	Receiver's instance variables: 
		outerScope: 	nil
		bindings: 	nil


[ self voidScope bind: 'foo' to: 7 ] in MiniVoidScopeTestCase>>testVoidScopeBindTo
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope bind: 'foo' to: 7 ]
		anExceptionalEvent: 	MiniVoidScopeError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>on:do:
	Receiver: [ 
aBlock value.
false ]
	Arguments and temporary variables: 
		exception: 	MiniVoidScopeError
		handlerAction: 	[ :ex | ex return: true ]
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
		startpc: 	26
		numArgs: 	0


MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope bind: 'foo' to: 7 ]
		anExceptionalEvent: 	MiniVoidScopeError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestAsserter)>>should:raise:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope bind: 'foo' to: 7 ]
		anExceptionalEvent: 	MiniVoidScopeError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeBindTo
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindTo
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindTo)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindTo)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindTo nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindTo)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindTo)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindTo MiniVoidScopeTe...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindTo
		lastUpdate: 	3624194918
		result: 	8 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 7 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 7 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindTo MiniVoidScopeTe...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindTo
		lastUpdate: 	3624194918
		result: 	8 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 7 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindTo MiniVoidScopeTe...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindTo
		lastUpdate: 	3624194918
		result: 	8 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 7 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindTo MiniVoidScopeTe...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindTo
		lastUpdate: 	3624194918
		result: 	8 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 7 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeBindTo
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindTo MiniVoidScopeTe...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindTo
		lastUpdate: 	3624194918
		result: 	8 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 7 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindTo MiniVoidScopeTe...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindTo
		lastUpdate: 	3624194918
		result: 	8 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 7 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindTo' 'MiniVoidScopeTestCase>>#...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(606@405) mouseUp 340657937 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindTo' 'MiniVoidScopeTestCase>>#...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(606@405) mouseUp 340657937 nil]
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindTo' 'MiniVoidScopeTestCase>>#...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(606@405) mouseUp 340657937 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindTo' 'MiniVoidScopeTestCase>>#...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(606@405) mouseUp 340657937 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	340657937
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(606@405)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(606@405) mouseUp 340657937 nil]
	Receiver's instance variables: 
		bounds: 	(434.0@400.0) corner: (775.0@599.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(434@400) corner: (775@599)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindTo' 'MiniVoidScopeTestCase>>#...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(606@405) mouseUp 340657937 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(606@405) mouseUp 340657937 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(606@405) mouseUp 340657937 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(606@405) mouseUp 340657937 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	340657937
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(606@405)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(606@405) mouseUp 340657937 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0



--- The full stack ---
MiniVoidScope(Object)>>doesNotUnderstand: #bind:to:
[ self voidScope bind: 'foo' to: 7 ] in MiniVoidScopeTestCase>>testVoidScopeBindTo
[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
BlockClosure>>on:do:
MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
MiniVoidScopeTestCase(TestAsserter)>>should:raise:
MiniVoidScopeTestCase>>testVoidScopeBindTo
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: CalcTimesNode class>>arg1:arg:
6 November 2015 11:00:49.372969 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

CalcTimesNode class(Object)>>doesNotUnderstand: #arg1:arg:
	Receiver: CalcTimesNode
	Arguments and temporary variables: 
		aMessage: 	arg1: a CalcNumberNode arg: a CalcNumberNode
		exception: 	MessageNotUnderstood: CalcTimesNode class>>arg1:arg:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	CalcBinaryOpNode
		methodDict: 	a MethodDictionary(#accept:->CalcTimesNode>>#accept: )
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CalcTimesNode
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'SmaCC-Tutorial'
		traitComposition: 	{}
		localSelectors: 	nil


CalcParser>>reduceActionForTerm2:
	Receiver: a CalcParser
	Arguments and temporary variables: 
		nodes: 	an Array(a CalcNumberNode {*(3,3,#(2))} a CalcNumberNode)
	Receiver's instance variables: 
		scanner: 	a CalcScanner
		currentToken: 	{+(7,7,#(1))}
		errorToken: 	nil
		stateStack: 	an OrderedCollection(1)
		nodeStack: 	an OrderedCollection()


CalcParser(SmaCCParser)>>performReduceMethod:with:
	Receiver: a CalcParser
	Arguments and temporary variables: 
		aSymbol: 	#reduceActionForTerm2:
		items: 	an Array(a CalcNumberNode {*(3,3,#(2))} a CalcNumberNode)
	Receiver's instance variables: 
		scanner: 	a CalcScanner
		currentToken: 	{+(7,7,#(1))}
		errorToken: 	nil
		stateStack: 	an OrderedCollection(1)
		nodeStack: 	an OrderedCollection()


CalcParser(SmaCCParser)>>reduce:
	Receiver: a CalcParser
	Arguments and temporary variables: 
		anInteger: 	7
		reduceEntry: 	#(10 3 #reduceActionForTerm2:)
		items: 	an Array(a CalcNumberNode {*(3,3,#(2))} a CalcNumberNode)
		size: 	3
	Receiver's instance variables: 
		scanner: 	a CalcScanner
		currentToken: 	{+(7,7,#(1))}
		errorToken: 	nil
		stateStack: 	an OrderedCollection(1)
		nodeStack: 	an OrderedCollection()


CalcParser(SmaCCParser)>>performAction:
	Receiver: a CalcParser
	Arguments and temporary variables: 
		action: 	30
		value: 	7
		actionType: 	2
	Receiver's instance variables: 
		scanner: 	a CalcScanner
		currentToken: 	{+(7,7,#(1))}
		errorToken: 	nil
		stateStack: 	an OrderedCollection(1)
		nodeStack: 	an OrderedCollection()


CalcParser(SmaCCParser)>>performParsingLoop
	Receiver: a CalcParser
	Arguments and temporary variables: 
		action: 	30
	Receiver's instance variables: 
		scanner: 	a CalcScanner
		currentToken: 	{+(7,7,#(1))}
		errorToken: 	nil
		stateStack: 	an OrderedCollection(1)
		nodeStack: 	an OrderedCollection()


CalcParser(SmaCCParser)>>parse
	Receiver: a CalcParser
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		scanner: 	a CalcScanner
		currentToken: 	{+(7,7,#(1))}
		errorToken: 	nil
		stateStack: 	an OrderedCollection(1)
		nodeStack: 	an OrderedCollection()


CalcParser class(SmaCCParser class)>>parseStream:startingAt:
	Receiver: CalcParser
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		anInteger: 	1
		parser: 	a CalcParser
	Receiver's instance variables: 
		superclass: 	SmaCCParser
		methodDict: 	a MethodDictionary(#reduceActionForExpr2:->CalcParser>>#reduceActio...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CalcParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'SmaCC-Tutorial'
		traitComposition: 	{}
		localSelectors: 	nil


CalcParser class(SmaCCParser class)>>parse:startingAt:
	Receiver: CalcParser
	Arguments and temporary variables: 
		aString: 	a Text for '3 * 2 + 7'
		anInteger: 	1
		value: 	nil
	Receiver's instance variables: 
		superclass: 	SmaCCParser
		methodDict: 	a MethodDictionary(#reduceActionForExpr2:->CalcParser>>#reduceActio...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CalcParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'SmaCC-Tutorial'
		traitComposition: 	{}
		localSelectors: 	nil


CalcParser class(SmaCCParser class)>>parse:
	Receiver: CalcParser
	Arguments and temporary variables: 
		aString: 	a Text for '3 * 2 + 7'
	Receiver's instance variables: 
		superclass: 	SmaCCParser
		methodDict: 	a MethodDictionary(#reduceActionForExpr2:->CalcParser>>#reduceActio...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CalcParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'SmaCC-Tutorial'
		traitComposition: 	{}
		localSelectors: 	nil


[ self parse: aString ] in CalcParser class(SmaCCParser class)>>parse:onError:
	Receiver: CalcParser
	Arguments and temporary variables: 
		aString: 	a Text for '3 * 2 + 7'
		aBlock: 	[ :aString :position | 
self displayError: aString at: position notifyi...etc...
	Receiver's instance variables: 
		superclass: 	SmaCCParser
		methodDict: 	a MethodDictionary(#reduceActionForExpr2:->CalcParser>>#reduceActio...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CalcParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'SmaCC-Tutorial'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>on:do:
	Receiver: [ self parse: aString ]
	Arguments and temporary variables: 
		exception: 	SmaCCParserError
		handlerAction: 	[ :ex | 
| returnValue |
returnValue := aBlock argumentCount = 3...etc...
	Receiver's instance variables: 
		outerContext: 	CalcParser class(SmaCCParser class)>>parse:onError:
		startpc: 	34
		numArgs: 	0


CalcParser class(SmaCCParser class)>>parse:onError:
	Receiver: CalcParser
	Arguments and temporary variables: 
		aString: 	a Text for '3 * 2 + 7'
		aBlock: 	[ :aString :position | 
self displayError: aString at: position notifyi...etc...
	Receiver's instance variables: 
		superclass: 	SmaCCParser
		methodDict: 	a MethodDictionary(#reduceActionForExpr2:->CalcParser>>#reduceActio...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CalcParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'SmaCC-Tutorial'
		traitComposition: 	{}
		localSelectors: 	nil


[ 
aBlock
	value:
		(class
			parse: self testText
			onError: [ :aString :position | 
				self displayError: aString at: position notifying: self testCodeHolder contentsMorph.
				self testCodeHolder contentsMorph hasUnacceptedEdits: true.
				self testCodeHolder contentsMorph takeKeyboardFocus.
				^ false ]) ] in SmaCCDevelopmentUI>>parseAndEvaluate:
	Receiver: a SmaCCDevelopmentUI
	Arguments and temporary variables: 
		aBlock: 	[ :each | each inspect ]
		class: 	CalcParser
	Receiver's instance variables: 
		tabList: 	a TabGroupMorph(608174080)
		parserClassMorph: 	a TextMorph(213385216)
		scannerClassMorph: 	a TextMorph(386138112)
		packageMorph: 	a TextMorph(675807232)
		findScannerClassButton: 	nil
		findParserClassButton: 	nil
		conflicts: 	a Text for ''
		ignoreCase: 	nil
		mainWindow: 	a StandardWindow(627834880)
		definitionCodeHolder: 	a SmaCCCodeHolder
		testCodeHolder: 	a SmaCCCodeHolder
		conflictTextMorph: 	a PluggableTextMorph(672661504)
		isGLR: 	nil
		itemsTextMorph: 	a PluggableTextMorph(343408640)
		symbolsTextMorph: 	a PluggableTextMorph(574095360)
		grammarCompiler: 	a SmaCCGrammarCompiler


BlockClosure>>ensure:
	Receiver: [ 
aBlock
	value:
		(class
			parse: self testText
			onError: [ :aString :position | 
			...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SmaCCDevelopmentUI>>parseAndEvaluate:
		startpc: 	124
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r111111111111110000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
aBlock
	value:
		(class
			parse: self testText
			onError: [ :aStri...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


SmaCCDevelopmentUI>>parseAndEvaluate:
	Receiver: a SmaCCDevelopmentUI
	Arguments and temporary variables: 
		aBlock: 	[ :each | each inspect ]
		class: 	CalcParser
	Receiver's instance variables: 
		tabList: 	a TabGroupMorph(608174080)
		parserClassMorph: 	a TextMorph(213385216)
		scannerClassMorph: 	a TextMorph(386138112)
		packageMorph: 	a TextMorph(675807232)
		findScannerClassButton: 	nil
		findParserClassButton: 	nil
		conflicts: 	a Text for ''
		ignoreCase: 	nil
		mainWindow: 	a StandardWindow(627834880)
		definitionCodeHolder: 	a SmaCCCodeHolder
		testCodeHolder: 	a SmaCCCodeHolder
		conflictTextMorph: 	a PluggableTextMorph(672661504)
		isGLR: 	nil
		itemsTextMorph: 	a PluggableTextMorph(343408640)
		symbolsTextMorph: 	a PluggableTextMorph(574095360)
		grammarCompiler: 	a SmaCCGrammarCompiler


SmaCCDevelopmentUI>>parseAndInspect
	Receiver: a SmaCCDevelopmentUI
	Arguments and temporary variables: 

	Receiver's instance variables: 
		tabList: 	a TabGroupMorph(608174080)
		parserClassMorph: 	a TextMorph(213385216)
		scannerClassMorph: 	a TextMorph(386138112)
		packageMorph: 	a TextMorph(675807232)
		findScannerClassButton: 	nil
		findParserClassButton: 	nil
		conflicts: 	a Text for ''
		ignoreCase: 	nil
		mainWindow: 	a StandardWindow(627834880)
		definitionCodeHolder: 	a SmaCCCodeHolder
		testCodeHolder: 	a SmaCCCodeHolder
		conflictTextMorph: 	a PluggableTextMorph(672661504)
		isGLR: 	nil
		itemsTextMorph: 	a PluggableTextMorph(343408640)
		symbolsTextMorph: 	a PluggableTextMorph(574095360)
		grammarCompiler: 	a SmaCCGrammarCompiler


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(327155712)
	Arguments and temporary variables: 
		event: 	[(883@635) mouseUp 424184921 nil]
	Receiver's instance variables: 
		bounds: 	(802.0@623.0) corner: (1064.0@647.0)
		owner: 	an AlignmentMorph(792985600)
		submorphs: 	an Array(an AlignmentMorph(182976512))
		fullBounds: 	(802@623) corner: (1064@647)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (394526720) [other:  (lastState -> false) (mouseEnt...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SmaCCDevelopmentUI
		label: 	'Parse and inspect'
		getStateSelector: 	nil
		actionSelector: 	#parseAndInspect
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		lastColor: 	nil
		labelMorph: 	a LabelMorph(289144832)'Parse and inspect'


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(327155712)
	Arguments and temporary variables: 
		evt: 	[(883@635) mouseUp 424184921 nil]
		all: 	an Array(a PluggableButtonMorph(58195968) a PluggableButtonMorph(327155712...etc...
		m: 	a PluggableButtonMorph(327155712)
	Receiver's instance variables: 
		bounds: 	(802.0@623.0) corner: (1064.0@647.0)
		owner: 	an AlignmentMorph(792985600)
		submorphs: 	an Array(an AlignmentMorph(182976512))
		fullBounds: 	(802@623) corner: (1064@647)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (394526720) [other:  (lastState -> false) (mouseEnt...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SmaCCDevelopmentUI
		label: 	'Parse and inspect'
		getStateSelector: 	nil
		actionSelector: 	#parseAndInspect
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		lastColor: 	nil
		labelMorph: 	a LabelMorph(289144832)'Parse and inspect'


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(58195968) a PluggableButtonMorph(327155712) a PluggableBut...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(58195968) a PluggableButtonMorph(327155712) a PluggableBut...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(327155712)
	Arguments and temporary variables: 
		evt: 	[(883@635) mouseUp 424184921 nil]
		all: 	an Array(a PluggableButtonMorph(58195968) a PluggableButtonMorph(327155712...etc...
	Receiver's instance variables: 
		bounds: 	(802.0@623.0) corner: (1064.0@647.0)
		owner: 	an AlignmentMorph(792985600)
		submorphs: 	an Array(an AlignmentMorph(182976512))
		fullBounds: 	(802@623) corner: (1064@647)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (394526720) [other:  (lastState -> false) (mouseEnt...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SmaCCDevelopmentUI
		label: 	'Parse and inspect'
		getStateSelector: 	nil
		actionSelector: 	#parseAndInspect
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		lastColor: 	nil
		labelMorph: 	a LabelMorph(289144832)'Parse and inspect'


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(327155712)
	Arguments and temporary variables: 
		anEvent: 	[(883@635) mouseUp 424184921 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(802.0@623.0) corner: (1064.0@647.0)
		owner: 	an AlignmentMorph(792985600)
		submorphs: 	an Array(an AlignmentMorph(182976512))
		fullBounds: 	(802@623) corner: (1064@647)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (394526720) [other:  (lastState -> false) (mouseEnt...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SmaCCDevelopmentUI
		label: 	'Parse and inspect'
		getStateSelector: 	nil
		actionSelector: 	#parseAndInspect
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		lastColor: 	nil
		labelMorph: 	a LabelMorph(289144832)'Parse and inspect'


MouseButtonEvent>>sentTo:
	Receiver: [(883@635) mouseUp 424184921 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(327155712)
	Receiver's instance variables: 
		timeStamp: 	424184921
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(883@635)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(327155712)
	Arguments and temporary variables: 
		anEvent: 	[(883@635) mouseUp 424184921 nil]
	Receiver's instance variables: 
		bounds: 	(802.0@623.0) corner: (1064.0@647.0)
		owner: 	an AlignmentMorph(792985600)
		submorphs: 	an Array(an AlignmentMorph(182976512))
		fullBounds: 	(802@623) corner: (1064@647)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (394526720) [other:  (lastState -> false) (mouseEnt...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SmaCCDevelopmentUI
		label: 	'Parse and inspect'
		getStateSelector: 	nil
		actionSelector: 	#parseAndInspect
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		lastColor: 	nil
		labelMorph: 	a LabelMorph(289144832)'Parse and inspect'


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(327155712)
	Arguments and temporary variables: 
		anEvent: 	[(883@635) mouseUp 424184921 nil]
	Receiver's instance variables: 
		bounds: 	(802.0@623.0) corner: (1064.0@647.0)
		owner: 	an AlignmentMorph(792985600)
		submorphs: 	an Array(an AlignmentMorph(182976512))
		fullBounds: 	(802@623) corner: (1064@647)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (394526720) [other:  (lastState -> false) (mouseEnt...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SmaCCDevelopmentUI
		label: 	'Parse and inspect'
		getStateSelector: 	nil
		actionSelector: 	#parseAndInspect
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		lastColor: 	nil
		labelMorph: 	a LabelMorph(289144832)'Parse and inspect'


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(883@635) mouseUp 424184921 nil]
		focusHolder: 	a PluggableButtonMorph(327155712)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(883@635.0) corner: (899@651.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(883@635.0) corner: (899@651.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(1051197440)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(883@635) mouseOver nil nil]
		targetOffset: 	(81.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 424184921 883 635 0 0 1 1)
		lastKeyScanCode: 	55
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(883@635) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1366@705)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a StandardWindow(627834880) a Nau...etc...
		fullBounds: 	(0@0) corner: (1366@705)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(883@635) mouseUp 424184921 nil]
		focusHolder: 	a PluggableButtonMorph(327155712)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(883@635.0) corner: (899@651.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(883@635.0) corner: (899@651.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(1051197440)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(883@635) mouseOver nil nil]
		targetOffset: 	(81.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 424184921 883 635 0 0 1 1)
		lastKeyScanCode: 	55
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(883@635) mouseUp 424184921 nil]
		focusHolder: 	a PluggableButtonMorph(327155712)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(883@635.0) corner: (899@651.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(883@635.0) corner: (899@651.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(1051197440)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(883@635) mouseOver nil nil]
		targetOffset: 	(81.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 424184921 883 635 0 0 1 1)
		lastKeyScanCode: 	55
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(883@635) mouseUp 424184921 nil]
	Receiver's instance variables: 
		bounds: 	(883@635.0) corner: (899@651.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(883@635.0) corner: (899@651.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(1051197440)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(883@635) mouseOver nil nil]
		targetOffset: 	(81.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 424184921 883 635 0 0 1 1)
		lastKeyScanCode: 	55
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(883@635) mouseUp 424184921 nil]
		evt: 	[(883@635) mouseUp 424184921 nil]
	Receiver's instance variables: 
		bounds: 	(883@635.0) corner: (899@651.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(883@635.0) corner: (899@651.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(1051197440)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(883@635) mouseOver nil nil]
		targetOffset: 	(81.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 424184921 883 635 0 0 1 1)
		lastKeyScanCode: 	55
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(883@635) mouseUp 424184921 nil]
		evtBuf: 	#(1 424184921 883 635 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(883@635.0) corner: (899@651.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(883@635.0) corner: (899@651.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(1051197440)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(883@635) mouseOver nil nil]
		targetOffset: 	(81.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 424184921 883 635 0 0 1 1)
		lastKeyScanCode: 	55
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(733216768))(a SearchMorp...etc...
		lastStepTime: 	268392
		lastStepMessage: 	nil
		lastCycleTime: 	268392
		alarms: 	a Heap()
		lastAlarmTime: 	268392
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(733216768))(a SearchMorp...etc...
		lastStepTime: 	268392
		lastStepMessage: 	nil
		lastCycleTime: 	268392
		alarms: 	a Heap()
		lastAlarmTime: 	268392
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(733216768))(a SearchMorp...etc...
		lastStepTime: 	268392
		lastStepMessage: 	nil
		lastCycleTime: 	268392
		alarms: 	a Heap()
		lastAlarmTime: 	268392
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(733216768))(a SearchMorp...etc...
		lastStepTime: 	268392
		lastStepMessage: 	nil
		lastCycleTime: 	268392
		alarms: 	a Heap()
		lastAlarmTime: 	268392
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 



--- The full stack ---
CalcTimesNode class(Object)>>doesNotUnderstand: #arg1:arg:
CalcParser>>reduceActionForTerm2:
CalcParser(SmaCCParser)>>performReduceMethod:with:
CalcParser(SmaCCParser)>>reduce:
CalcParser(SmaCCParser)>>performAction:
CalcParser(SmaCCParser)>>performParsingLoop
CalcParser(SmaCCParser)>>parse
CalcParser class(SmaCCParser class)>>parseStream:startingAt:
CalcParser class(SmaCCParser class)>>parse:startingAt:
CalcParser class(SmaCCParser class)>>parse:
[ self parse: aString ] in CalcParser class(SmaCCParser class)>>parse:onError:
BlockClosure>>on:do:
CalcParser class(SmaCCParser class)>>parse:onError:
[ 
aBlock
	value:
		(class
			parse: self testText
			onError: [ :aString :position | 
				self displayError: aString at: position notifying: self testCodeHolder contentsMorph.
				self testCodeHolder contentsMorph hasUnacceptedEdits: true.
				self testCodeHolder contentsMorph takeKeyboardFocus.
				^ false ]) ] in SmaCCDevelopmentUI>>parseAndEvaluate:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
SmaCCDevelopmentUI>>parseAndEvaluate:
SmaCCDevelopmentUI>>parseAndInspect
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: CalcTimesNode class>>arg1:arg:
6 November 2015 11:01:33.669969 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

CalcTimesNode class(Object)>>doesNotUnderstand: #arg1:arg:
	Receiver: CalcTimesNode
	Arguments and temporary variables: 
		aMessage: 	arg1: a CalcNumberNode arg: a CalcNumberNode
		exception: 	MessageNotUnderstood: CalcTimesNode class>>arg1:arg:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	CalcBinaryOpNode
		methodDict: 	a MethodDictionary(#accept:->CalcTimesNode>>#accept: )
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CalcTimesNode
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'SmaCC-Tutorial'
		traitComposition: 	{}
		localSelectors: 	nil


CalcParser>>reduceActionForTerm2:
	Receiver: a CalcParser
	Arguments and temporary variables: 
		nodes: 	an Array(a CalcNumberNode {*(3,3,#(2))} a CalcNumberNode)
	Receiver's instance variables: 
		scanner: 	a CalcScanner
		currentToken: 	{+(7,7,#(1))}
		errorToken: 	nil
		stateStack: 	an OrderedCollection(1)
		nodeStack: 	an OrderedCollection()


CalcParser(SmaCCParser)>>performReduceMethod:with:
	Receiver: a CalcParser
	Arguments and temporary variables: 
		aSymbol: 	#reduceActionForTerm2:
		items: 	an Array(a CalcNumberNode {*(3,3,#(2))} a CalcNumberNode)
	Receiver's instance variables: 
		scanner: 	a CalcScanner
		currentToken: 	{+(7,7,#(1))}
		errorToken: 	nil
		stateStack: 	an OrderedCollection(1)
		nodeStack: 	an OrderedCollection()


CalcParser(SmaCCParser)>>reduce:
	Receiver: a CalcParser
	Arguments and temporary variables: 
		anInteger: 	7
		reduceEntry: 	#(10 3 #reduceActionForTerm2:)
		items: 	an Array(a CalcNumberNode {*(3,3,#(2))} a CalcNumberNode)
		size: 	3
	Receiver's instance variables: 
		scanner: 	a CalcScanner
		currentToken: 	{+(7,7,#(1))}
		errorToken: 	nil
		stateStack: 	an OrderedCollection(1)
		nodeStack: 	an OrderedCollection()


CalcParser(SmaCCParser)>>performAction:
	Receiver: a CalcParser
	Arguments and temporary variables: 
		action: 	30
		value: 	7
		actionType: 	2
	Receiver's instance variables: 
		scanner: 	a CalcScanner
		currentToken: 	{+(7,7,#(1))}
		errorToken: 	nil
		stateStack: 	an OrderedCollection(1)
		nodeStack: 	an OrderedCollection()


CalcParser(SmaCCParser)>>performParsingLoop
	Receiver: a CalcParser
	Arguments and temporary variables: 
		action: 	30
	Receiver's instance variables: 
		scanner: 	a CalcScanner
		currentToken: 	{+(7,7,#(1))}
		errorToken: 	nil
		stateStack: 	an OrderedCollection(1)
		nodeStack: 	an OrderedCollection()


CalcParser(SmaCCParser)>>parse
	Receiver: a CalcParser
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		scanner: 	a CalcScanner
		currentToken: 	{+(7,7,#(1))}
		errorToken: 	nil
		stateStack: 	an OrderedCollection(1)
		nodeStack: 	an OrderedCollection()


CalcParser class(SmaCCParser class)>>parseStream:startingAt:
	Receiver: CalcParser
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		anInteger: 	1
		parser: 	a CalcParser
	Receiver's instance variables: 
		superclass: 	SmaCCParser
		methodDict: 	a MethodDictionary(#reduceActionForExpr2:->CalcParser>>#reduceActio...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CalcParser
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'SmaCC-Tutorial'
		traitComposition: 	{}
		localSelectors: 	nil


CalcParser class(SmaCCParser class)>>parse:startingAt:
	Receiver: CalcParser
	Arguments and temporary variables: 
		aString: 	a Text for '3 * 2 + 7'
		anInteger: 	1
		value: 	nil
	Receiver's instance variables: 
		superclass: 	SmaCCParser
		methodDict: 	a MethodDictionary(#reduceActionForExpr2:->CalcParser>>#reduceActio...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CalcParser
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'SmaCC-Tutorial'
		traitComposition: 	{}
		localSelectors: 	nil


CalcParser class(SmaCCParser class)>>parse:
	Receiver: CalcParser
	Arguments and temporary variables: 
		aString: 	a Text for '3 * 2 + 7'
	Receiver's instance variables: 
		superclass: 	SmaCCParser
		methodDict: 	a MethodDictionary(#reduceActionForExpr2:->CalcParser>>#reduceActio...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CalcParser
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'SmaCC-Tutorial'
		traitComposition: 	{}
		localSelectors: 	nil


[ self parse: aString ] in CalcParser class(SmaCCParser class)>>parse:onError:
	Receiver: CalcParser
	Arguments and temporary variables: 
		aString: 	a Text for '3 * 2 + 7'
		aBlock: 	[ :aString :position | 
self displayError: aString at: position notifyi...etc...
	Receiver's instance variables: 
		superclass: 	SmaCCParser
		methodDict: 	a MethodDictionary(#reduceActionForExpr2:->CalcParser>>#reduceActio...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CalcParser
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'SmaCC-Tutorial'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>on:do:
	Receiver: [ self parse: aString ]
	Arguments and temporary variables: 
		exception: 	SmaCCParserError
		handlerAction: 	[ :ex | 
| returnValue |
returnValue := aBlock argumentCount = 3...etc...
	Receiver's instance variables: 
		outerContext: 	CalcParser class(SmaCCParser class)>>parse:onError:
		startpc: 	34
		numArgs: 	0


CalcParser class(SmaCCParser class)>>parse:onError:
	Receiver: CalcParser
	Arguments and temporary variables: 
		aString: 	a Text for '3 * 2 + 7'
		aBlock: 	[ :aString :position | 
self displayError: aString at: position notifyi...etc...
	Receiver's instance variables: 
		superclass: 	SmaCCParser
		methodDict: 	a MethodDictionary(#reduceActionForExpr2:->CalcParser>>#reduceActio...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CalcParser
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'SmaCC-Tutorial'
		traitComposition: 	{}
		localSelectors: 	nil


[ 
aBlock
	value:
		(class
			parse: self testText
			onError: [ :aString :position | 
				self displayError: aString at: position notifying: self testCodeHolder contentsMorph.
				self testCodeHolder contentsMorph hasUnacceptedEdits: true.
				self testCodeHolder contentsMorph takeKeyboardFocus.
				^ false ]) ] in SmaCCDevelopmentUI>>parseAndEvaluate:
	Receiver: a SmaCCDevelopmentUI
	Arguments and temporary variables: 
		aBlock: 	[ :each | each inspect ]
		class: 	CalcParser
	Receiver's instance variables: 
		tabList: 	a TabGroupMorph(608174080)
		parserClassMorph: 	a TextMorph(213385216)
		scannerClassMorph: 	a TextMorph(386138112)
		packageMorph: 	a TextMorph(675807232)
		findScannerClassButton: 	nil
		findParserClassButton: 	nil
		conflicts: 	a Text for ''
		ignoreCase: 	nil
		mainWindow: 	a StandardWindow(627834880)
		definitionCodeHolder: 	a SmaCCCodeHolder
		testCodeHolder: 	a SmaCCCodeHolder
		conflictTextMorph: 	a PluggableTextMorph(672661504)
		isGLR: 	nil
		itemsTextMorph: 	a PluggableTextMorph(343408640)
		symbolsTextMorph: 	a PluggableTextMorph(574095360)
		grammarCompiler: 	a SmaCCGrammarCompiler


BlockClosure>>ensure:
	Receiver: [ 
aBlock
	value:
		(class
			parse: self testText
			onError: [ :aString :position | 
			...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SmaCCDevelopmentUI>>parseAndEvaluate:
		startpc: 	124
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r111111111111110000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
aBlock
	value:
		(class
			parse: self testText
			onError: [ :aStri...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


SmaCCDevelopmentUI>>parseAndEvaluate:
	Receiver: a SmaCCDevelopmentUI
	Arguments and temporary variables: 
		aBlock: 	[ :each | each inspect ]
		class: 	CalcParser
	Receiver's instance variables: 
		tabList: 	a TabGroupMorph(608174080)
		parserClassMorph: 	a TextMorph(213385216)
		scannerClassMorph: 	a TextMorph(386138112)
		packageMorph: 	a TextMorph(675807232)
		findScannerClassButton: 	nil
		findParserClassButton: 	nil
		conflicts: 	a Text for ''
		ignoreCase: 	nil
		mainWindow: 	a StandardWindow(627834880)
		definitionCodeHolder: 	a SmaCCCodeHolder
		testCodeHolder: 	a SmaCCCodeHolder
		conflictTextMorph: 	a PluggableTextMorph(672661504)
		isGLR: 	nil
		itemsTextMorph: 	a PluggableTextMorph(343408640)
		symbolsTextMorph: 	a PluggableTextMorph(574095360)
		grammarCompiler: 	a SmaCCGrammarCompiler


SmaCCDevelopmentUI>>parseAndInspect
	Receiver: a SmaCCDevelopmentUI
	Arguments and temporary variables: 

	Receiver's instance variables: 
		tabList: 	a TabGroupMorph(608174080)
		parserClassMorph: 	a TextMorph(213385216)
		scannerClassMorph: 	a TextMorph(386138112)
		packageMorph: 	a TextMorph(675807232)
		findScannerClassButton: 	nil
		findParserClassButton: 	nil
		conflicts: 	a Text for ''
		ignoreCase: 	nil
		mainWindow: 	a StandardWindow(627834880)
		definitionCodeHolder: 	a SmaCCCodeHolder
		testCodeHolder: 	a SmaCCCodeHolder
		conflictTextMorph: 	a PluggableTextMorph(672661504)
		isGLR: 	nil
		itemsTextMorph: 	a PluggableTextMorph(343408640)
		symbolsTextMorph: 	a PluggableTextMorph(574095360)
		grammarCompiler: 	a SmaCCGrammarCompiler


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(327155712)
	Arguments and temporary variables: 
		event: 	[(915@633) mouseUp 424229484 nil]
	Receiver's instance variables: 
		bounds: 	(802.0@623.0) corner: (1064.0@647.0)
		owner: 	an AlignmentMorph(792985600)
		submorphs: 	an Array(an AlignmentMorph(182976512))
		fullBounds: 	(802@623) corner: (1064@647)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (394526720) [other:  (lastState -> false) (mouseEnt...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SmaCCDevelopmentUI
		label: 	'Parse and inspect'
		getStateSelector: 	nil
		actionSelector: 	#parseAndInspect
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		lastColor: 	nil
		labelMorph: 	a LabelMorph(289144832)'Parse and inspect'


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(327155712)
	Arguments and temporary variables: 
		evt: 	[(915@633) mouseUp 424229484 nil]
		all: 	an Array(a PluggableButtonMorph(58195968) a PluggableButtonMorph(327155712...etc...
		m: 	a PluggableButtonMorph(327155712)
	Receiver's instance variables: 
		bounds: 	(802.0@623.0) corner: (1064.0@647.0)
		owner: 	an AlignmentMorph(792985600)
		submorphs: 	an Array(an AlignmentMorph(182976512))
		fullBounds: 	(802@623) corner: (1064@647)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (394526720) [other:  (lastState -> false) (mouseEnt...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SmaCCDevelopmentUI
		label: 	'Parse and inspect'
		getStateSelector: 	nil
		actionSelector: 	#parseAndInspect
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		lastColor: 	nil
		labelMorph: 	a LabelMorph(289144832)'Parse and inspect'


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(58195968) a PluggableButtonMorph(327155712) a PluggableBut...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(58195968) a PluggableButtonMorph(327155712) a PluggableBut...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(327155712)
	Arguments and temporary variables: 
		evt: 	[(915@633) mouseUp 424229484 nil]
		all: 	an Array(a PluggableButtonMorph(58195968) a PluggableButtonMorph(327155712...etc...
	Receiver's instance variables: 
		bounds: 	(802.0@623.0) corner: (1064.0@647.0)
		owner: 	an AlignmentMorph(792985600)
		submorphs: 	an Array(an AlignmentMorph(182976512))
		fullBounds: 	(802@623) corner: (1064@647)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (394526720) [other:  (lastState -> false) (mouseEnt...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SmaCCDevelopmentUI
		label: 	'Parse and inspect'
		getStateSelector: 	nil
		actionSelector: 	#parseAndInspect
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		lastColor: 	nil
		labelMorph: 	a LabelMorph(289144832)'Parse and inspect'


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(327155712)
	Arguments and temporary variables: 
		anEvent: 	[(915@633) mouseUp 424229484 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(802.0@623.0) corner: (1064.0@647.0)
		owner: 	an AlignmentMorph(792985600)
		submorphs: 	an Array(an AlignmentMorph(182976512))
		fullBounds: 	(802@623) corner: (1064@647)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (394526720) [other:  (lastState -> false) (mouseEnt...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SmaCCDevelopmentUI
		label: 	'Parse and inspect'
		getStateSelector: 	nil
		actionSelector: 	#parseAndInspect
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		lastColor: 	nil
		labelMorph: 	a LabelMorph(289144832)'Parse and inspect'


MouseButtonEvent>>sentTo:
	Receiver: [(915@633) mouseUp 424229484 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(327155712)
	Receiver's instance variables: 
		timeStamp: 	424229484
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(915@633)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(327155712)
	Arguments and temporary variables: 
		anEvent: 	[(915@633) mouseUp 424229484 nil]
	Receiver's instance variables: 
		bounds: 	(802.0@623.0) corner: (1064.0@647.0)
		owner: 	an AlignmentMorph(792985600)
		submorphs: 	an Array(an AlignmentMorph(182976512))
		fullBounds: 	(802@623) corner: (1064@647)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (394526720) [other:  (lastState -> false) (mouseEnt...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SmaCCDevelopmentUI
		label: 	'Parse and inspect'
		getStateSelector: 	nil
		actionSelector: 	#parseAndInspect
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		lastColor: 	nil
		labelMorph: 	a LabelMorph(289144832)'Parse and inspect'


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(327155712)
	Arguments and temporary variables: 
		anEvent: 	[(915@633) mouseUp 424229484 nil]
	Receiver's instance variables: 
		bounds: 	(802.0@623.0) corner: (1064.0@647.0)
		owner: 	an AlignmentMorph(792985600)
		submorphs: 	an Array(an AlignmentMorph(182976512))
		fullBounds: 	(802@623) corner: (1064@647)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (394526720) [other:  (lastState -> false) (mouseEnt...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SmaCCDevelopmentUI
		label: 	'Parse and inspect'
		getStateSelector: 	nil
		actionSelector: 	#parseAndInspect
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		lastColor: 	nil
		labelMorph: 	a LabelMorph(289144832)'Parse and inspect'


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(915@633) mouseUp 424229484 nil]
		focusHolder: 	a PluggableButtonMorph(327155712)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(915@633.0) corner: (931@649.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(915@633.0) corner: (931@649.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(895746048)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(915@633) mouseOver nil nil]
		targetOffset: 	(113.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 424229484 915 633 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(915@633) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1366@705)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a StandardWindow(627834880) a Nau...etc...
		fullBounds: 	(0@0) corner: (1366@705)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(915@633) mouseUp 424229484 nil]
		focusHolder: 	a PluggableButtonMorph(327155712)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(915@633.0) corner: (931@649.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(915@633.0) corner: (931@649.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(895746048)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(915@633) mouseOver nil nil]
		targetOffset: 	(113.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 424229484 915 633 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(915@633) mouseUp 424229484 nil]
		focusHolder: 	a PluggableButtonMorph(327155712)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(915@633.0) corner: (931@649.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(915@633.0) corner: (931@649.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(895746048)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(915@633) mouseOver nil nil]
		targetOffset: 	(113.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 424229484 915 633 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(915@633) mouseUp 424229484 nil]
	Receiver's instance variables: 
		bounds: 	(915@633.0) corner: (931@649.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(915@633.0) corner: (931@649.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(895746048)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(915@633) mouseOver nil nil]
		targetOffset: 	(113.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 424229484 915 633 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(915@633) mouseUp 424229484 nil]
		evt: 	[(915@633) mouseUp 424229484 nil]
	Receiver's instance variables: 
		bounds: 	(915@633.0) corner: (931@649.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(915@633.0) corner: (931@649.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(895746048)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(915@633) mouseOver nil nil]
		targetOffset: 	(113.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 424229484 915 633 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(915@633) mouseUp 424229484 nil]
		evtBuf: 	#(1 424229484 915 633 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(915@633.0) corner: (931@649.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(915@633.0) corner: (931@649.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(895746048)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(915@633) mouseOver nil nil]
		targetOffset: 	(113.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 424229484 915 633 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(36700160))(a SearchMorph...etc...
		lastStepTime: 	312616
		lastStepMessage: 	nil
		lastCycleTime: 	312616
		alarms: 	a Heap()
		lastAlarmTime: 	312616
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(36700160))(a SearchMorph...etc...
		lastStepTime: 	312616
		lastStepMessage: 	nil
		lastCycleTime: 	312616
		alarms: 	a Heap()
		lastAlarmTime: 	312616
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(36700160))(a SearchMorph...etc...
		lastStepTime: 	312616
		lastStepMessage: 	nil
		lastCycleTime: 	312616
		alarms: 	a Heap()
		lastAlarmTime: 	312616
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(36700160))(a SearchMorph...etc...
		lastStepTime: 	312616
		lastStepMessage: 	nil
		lastCycleTime: 	312616
		alarms: 	a Heap()
		lastAlarmTime: 	312616
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 



--- The full stack ---
CalcTimesNode class(Object)>>doesNotUnderstand: #arg1:arg:
CalcParser>>reduceActionForTerm2:
CalcParser(SmaCCParser)>>performReduceMethod:with:
CalcParser(SmaCCParser)>>reduce:
CalcParser(SmaCCParser)>>performAction:
CalcParser(SmaCCParser)>>performParsingLoop
CalcParser(SmaCCParser)>>parse
CalcParser class(SmaCCParser class)>>parseStream:startingAt:
CalcParser class(SmaCCParser class)>>parse:startingAt:
CalcParser class(SmaCCParser class)>>parse:
[ self parse: aString ] in CalcParser class(SmaCCParser class)>>parse:onError:
BlockClosure>>on:do:
CalcParser class(SmaCCParser class)>>parse:onError:
[ 
aBlock
	value:
		(class
			parse: self testText
			onError: [ :aString :position | 
				self displayError: aString at: position notifying: self testCodeHolder contentsMorph.
				self testCodeHolder contentsMorph hasUnacceptedEdits: true.
				self testCodeHolder contentsMorph takeKeyboardFocus.
				^ false ]) ] in SmaCCDevelopmentUI>>parseAndEvaluate:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
SmaCCDevelopmentUI>>parseAndEvaluate:
SmaCCDevelopmentUI>>parseAndInspect
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniVoidScope>>bindingFor:
9 November 2015 9:07:29.419862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScope(Object)>>doesNotUnderstand: #bindingFor:
	Receiver: a MiniVoidScope
	Arguments and temporary variables: 
		aMessage: 	bindingFor: 'foo'
		exception: 	MessageNotUnderstood: MiniVoidScope>>bindingFor:
		resumeValue: 	nil
	Receiver's instance variables: 
		outerScope: 	nil
		bindings: 	nil


[ self voidScope bindingFor: 'foo' ] in MiniVoidScopeTestCase>>testVoidScopeBindingFor
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope bindingFor: 'foo' ]
		anExceptionalEvent: 	MiniUndeclaredError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>on:do:
	Receiver: [ 
aBlock value.
false ]
	Arguments and temporary variables: 
		exception: 	MiniUndeclaredError
		handlerAction: 	[ :ex | ex return: true ]
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
		startpc: 	26
		numArgs: 	0


MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope bindingFor: 'foo' ]
		anExceptionalEvent: 	MiniUndeclaredError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestAsserter)>>should:raise:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope bindingFor: 'foo' ]
		anExceptionalEvent: 	MiniUndeclaredError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeBindingFor
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindingFor)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindingFor)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindingFor)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindingFor)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor MiniVoidSco...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
		lastUpdate: 	3624195023
		result: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor MiniVoidSco...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
		lastUpdate: 	3624195023
		result: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor MiniVoidSco...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
		lastUpdate: 	3624195023
		result: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor MiniVoidSco...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
		lastUpdate: 	3624195023
		result: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor MiniVoidSco...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
		lastUpdate: 	3624195023
		result: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor MiniVoidSco...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
		lastUpdate: 	3624195023
		result: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384.0@390.0) corner: (725.0@589.0)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindingFor' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(583@397) mouseUp 139713931 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384.0@390.0) corner: (725.0@589.0)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindingFor' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(583@397) mouseUp 139713931 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384.0@390.0) corner: (725.0@589.0)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindingFor' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(583@397) mouseUp 139713931 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384.0@390.0) corner: (725.0@589.0)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindingFor' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(583@397) mouseUp 139713931 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	139713931
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(583@397)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(583@397) mouseUp 139713931 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384.0@390.0) corner: (725.0@589.0)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindingFor' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(583@397) mouseUp 139713931 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(583@397) mouseUp 139713931 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(583@397) mouseUp 139713931 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(583@397) mouseUp 139713931 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	139713931
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(583@397)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(583@397) mouseUp 139713931 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0



--- The full stack ---
MiniVoidScope(Object)>>doesNotUnderstand: #bindingFor:
[ self voidScope bindingFor: 'foo' ] in MiniVoidScopeTestCase>>testVoidScopeBindingFor
[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
BlockClosure>>on:do:
MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
MiniVoidScopeTestCase(TestAsserter)>>should:raise:
MiniVoidScopeTestCase>>testVoidScopeBindingFor
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniVoidScope>>bindingFor:
9 November 2015 9:07:58.301862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScope(Object)>>doesNotUnderstand: #bindingFor:
	Receiver: a MiniVoidScope
	Arguments and temporary variables: 
		aMessage: 	bindingFor: 'foo'
		exception: 	MessageNotUnderstood: MiniVoidScope>>bindingFor:
		resumeValue: 	nil
	Receiver's instance variables: 
		outerScope: 	nil
		bindings: 	nil


[ self voidScope bindingFor: 'foo' ] in MiniVoidScopeTestCase>>testVoidScopeBindingFor
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope bindingFor: 'foo' ]
		anExceptionalEvent: 	MiniUndeclaredError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>on:do:
	Receiver: [ 
aBlock value.
false ]
	Arguments and temporary variables: 
		exception: 	MiniUndeclaredError
		handlerAction: 	[ :ex | ex return: true ]
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
		startpc: 	26
		numArgs: 	0


MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope bindingFor: 'foo' ]
		anExceptionalEvent: 	MiniUndeclaredError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestAsserter)>>should:raise:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope bindingFor: 'foo' ]
		anExceptionalEvent: 	MiniUndeclaredError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeBindingFor
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindingFor)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindingFor)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindingFor)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindingFor)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor MiniVoidSco...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
		lastUpdate: 	3624195023
		result: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor MiniVoidSco...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
		lastUpdate: 	3624195023
		result: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor MiniVoidSco...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
		lastUpdate: 	3624195023
		result: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor MiniVoidSco...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
		lastUpdate: 	3624195023
		result: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor MiniVoidSco...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
		lastUpdate: 	3624195023
		result: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor MiniVoidSco...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
		lastUpdate: 	3624195023
		result: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384.0@390.0) corner: (725.0@589.0)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindingFor' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(530@403) mouseUp 139743197 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384.0@390.0) corner: (725.0@589.0)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindingFor' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(530@403) mouseUp 139743197 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384.0@390.0) corner: (725.0@589.0)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindingFor' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(530@403) mouseUp 139743197 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384.0@390.0) corner: (725.0@589.0)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindingFor' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(530@403) mouseUp 139743197 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	139743197
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(530@403)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(530@403) mouseUp 139743197 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384.0@390.0) corner: (725.0@589.0)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindingFor' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(530@403) mouseUp 139743197 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(530@403) mouseUp 139743197 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(530@403) mouseUp 139743197 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(530@403) mouseUp 139743197 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	139743197
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(530@403)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(530@403) mouseUp 139743197 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0



--- The full stack ---
MiniVoidScope(Object)>>doesNotUnderstand: #bindingFor:
[ self voidScope bindingFor: 'foo' ] in MiniVoidScopeTestCase>>testVoidScopeBindingFor
[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
BlockClosure>>on:do:
MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
MiniVoidScopeTestCase(TestAsserter)>>should:raise:
MiniVoidScopeTestCase>>testVoidScopeBindingFor
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniVoidScope>>bindingFor:
9 November 2015 9:07:59.464862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScope(Object)>>doesNotUnderstand: #bindingFor:
	Receiver: a MiniVoidScope
	Arguments and temporary variables: 
		aMessage: 	bindingFor: 'foo'
		exception: 	MessageNotUnderstood: MiniVoidScope>>bindingFor:
		resumeValue: 	nil
	Receiver's instance variables: 
		outerScope: 	nil
		bindings: 	nil


[ self voidScope bindingFor: 'foo' ] in MiniVoidScopeTestCase>>testVoidScopeBindingFor
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope bindingFor: 'foo' ]
		anExceptionalEvent: 	MiniUndeclaredError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>on:do:
	Receiver: [ 
aBlock value.
false ]
	Arguments and temporary variables: 
		exception: 	MiniUndeclaredError
		handlerAction: 	[ :ex | ex return: true ]
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
		startpc: 	26
		numArgs: 	0


MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope bindingFor: 'foo' ]
		anExceptionalEvent: 	MiniUndeclaredError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestAsserter)>>should:raise:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope bindingFor: 'foo' ]
		anExceptionalEvent: 	MiniUndeclaredError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeBindingFor
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeBindingFor
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindingFor)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindingFor)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindingFor)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeBindingFor)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor MiniVoidSco...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
		lastUpdate: 	3624195023
		result: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor MiniVoidSco...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
		lastUpdate: 	3624195023
		result: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor MiniVoidSco...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
		lastUpdate: 	3624195023
		result: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor MiniVoidSco...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
		lastUpdate: 	3624195023
		result: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor MiniVoidSco...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
		lastUpdate: 	3624195023
		result: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeBindingFor MiniVoidSco...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeBindingFor
		lastUpdate: 	3624195023
		result: 	8 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 6 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384.0@390.0) corner: (725.0@589.0)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindingFor' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(530@402) mouseUp 139744353 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384.0@390.0) corner: (725.0@589.0)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindingFor' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(530@402) mouseUp 139744353 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384.0@390.0) corner: (725.0@589.0)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindingFor' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(530@402) mouseUp 139744353 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384.0@390.0) corner: (725.0@589.0)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindingFor' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(530@402) mouseUp 139744353 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	139744353
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(530@402)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(530@402) mouseUp 139744353 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384.0@390.0) corner: (725.0@589.0)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeBindingFor' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(530@402) mouseUp 139744353 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(530@402) mouseUp 139744353 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(530@402) mouseUp 139744353 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(530@402) mouseUp 139744353 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	139744353
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(530@402)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(530@402) mouseUp 139744353 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0



--- The full stack ---
MiniVoidScope(Object)>>doesNotUnderstand: #bindingFor:
[ self voidScope bindingFor: 'foo' ] in MiniVoidScopeTestCase>>testVoidScopeBindingFor
[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
BlockClosure>>on:do:
MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
MiniVoidScopeTestCase(TestAsserter)>>should:raise:
MiniVoidScopeTestCase>>testVoidScopeBindingFor
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
9 November 2015 9:12:03.446862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScopeTestCase(TestAsserter)>>assert:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeOuterScope
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor MiniVoid...etc...
		errorSelected: 	nil
		lastUpdate: 	3624531114
		result: 	8 run, 3 passes, 0 skipped, 0 expected failures, 3 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 3 passes, 0 skipped, 0 expected failures, 3 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor MiniVoid...etc...
		errorSelected: 	nil
		lastUpdate: 	3624531114
		result: 	8 run, 3 passes, 0 skipped, 0 expected failures, 3 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor MiniVoid...etc...
		errorSelected: 	nil
		lastUpdate: 	3624531114
		result: 	8 run, 3 passes, 0 skipped, 0 expected failures, 3 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor MiniVoid...etc...
		errorSelected: 	nil
		lastUpdate: 	3624531114
		result: 	8 run, 3 passes, 0 skipped, 0 expected failures, 3 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor MiniVoid...etc...
		errorSelected: 	nil
		lastUpdate: 	3624531114
		result: 	8 run, 3 passes, 0 skipped, 0 expected failures, 3 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor MiniVoid...etc...
		errorSelected: 	nil
		lastUpdate: 	3624531114
		result: 	8 run, 3 passes, 0 skipped, 0 expected failures, 3 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		event: 	[(664@229) mouseUp 139988353 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		evt: 	[(664@229) mouseUp 139988353 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(664@229) mouseUp 139988353 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(664@229) mouseUp 139988353 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		timeStamp: 	139988353
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(664@229)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(664@229) mouseUp 139988353 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(664@229) mouseUp 139988353 nil]
		aMorph: 	a PluggableListMorph(99352576)
		localEvt: 	[(664@229) mouseUp 139988353 nil]
		index: 	2
		child: 	a TransformMorph(214171648)
		morphs: 	an Array(a TransformMorph(214171648))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(664@229) mouseUp 139988353 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(664@229) mouseUp 139988353 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	139988353
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(664@229)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(664@229) mouseUp 139988353 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(664@229) mouseUp 139988353 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(664@229) mouseUp 139988353 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(664@229) mouseUp 139988353 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(664@229) mouseUp 139988353 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(664@229) mouseUp 139988353 nil]
		focusHolder: 	a PluggableListMorph(99352576)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(664@229.0) corner: (680@245.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(664@229.0) corner: (680@245.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(99352576)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(664@229) mouseUp 139988353 nil]
		targetOffset: 	(280.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 139988353 664 229 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniVoidScopeTestCase(TestAsserter)>>assert:
MiniVoidScopeTestCase>>testVoidScopeOuterScope
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniVoidScope>>hasBindingFor:
9 November 2015 9:12:12.088862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScope(Object)>>doesNotUnderstand: #hasBindingFor:
	Receiver: a MiniVoidScope
	Arguments and temporary variables: 
		aMessage: 	hasBindingFor: 'foo'
		exception: 	MessageNotUnderstood: MiniVoidScope>>hasBindingFor:
		resumeValue: 	nil
	Receiver's instance variables: 
		outerScope: 	a MiniScope
		bindings: 	a Dictionary()


MiniVoidScopeTestCase>>testVoidScopeHasBindingFor
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeHasBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeHasBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeHasBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeHasBindingFor
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeHasBindingFor
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeHasBindingFor
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor)...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor nil nil nil ...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor)...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor)...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor MiniVoid...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor
		lastUpdate: 	3624531114
		result: 	8 run, 3 passes, 0 skipped, 0 expected failures, 3 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 3 passes, 0 skipped, 0 expected failures, 3 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor MiniVoid...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor
		lastUpdate: 	3624531114
		result: 	8 run, 3 passes, 0 skipped, 0 expected failures, 3 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor MiniVoid...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor
		lastUpdate: 	3624531114
		result: 	8 run, 3 passes, 0 skipped, 0 expected failures, 3 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor MiniVoid...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor
		lastUpdate: 	3624531114
		result: 	8 run, 3 passes, 0 skipped, 0 expected failures, 3 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor MiniVoid...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor
		lastUpdate: 	3624531114
		result: 	8 run, 3 passes, 0 skipped, 0 expected failures, 3 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor MiniVoid...etc...
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor
		lastUpdate: 	3624531114
		result: 	8 run, 3 passes, 0 skipped, 0 expected failures, 3 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor' 'MiniVoidScopeTest...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(611@397) mouseUp 139996978 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor' 'MiniVoidScopeTest...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(611@397) mouseUp 139996978 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor' 'MiniVoidScopeTest...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(611@397) mouseUp 139996978 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor' 'MiniVoidScopeTest...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(611@397) mouseUp 139996978 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	139996978
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(611@397)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(611@397) mouseUp 139996978 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor' 'MiniVoidScopeTest...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(611@397) mouseUp 139996978 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(611@397) mouseUp 139996978 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(611@397) mouseUp 139996978 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(611@397) mouseUp 139996978 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	139996978
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(611@397)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(611@397) mouseUp 139996978 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(611@397) mouseUp 139996978 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(611@397) mouseUp 139996978 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor' 'MiniVoidScopeTest...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(611@397) mouseUp 139996978 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor' 'MiniVoidScopeTest...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(611@397) mouseUp 139996978 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeHasBindingFor' 'MiniVoidScopeTest...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(611@397) mouseUp 139996978 nil]
		focusHolder: 	a PluggableListMorph(696778752)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(611@397.0) corner: (627@413.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(611@397.0) corner: (627@413.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(696778752)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(611@397) mouseUp 139996978 nil]
		targetOffset: 	(227.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 139996978 611 397 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniVoidScope(Object)>>doesNotUnderstand: #hasBindingFor:
MiniVoidScopeTestCase>>testVoidScopeHasBindingFor
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniVoidScope>>rebind:to:
9 November 2015 9:13:06.645862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScope(Object)>>doesNotUnderstand: #rebind:to:
	Receiver: a MiniVoidScope
	Arguments and temporary variables: 
		aMessage: 	rebind: 'foo' to: 9
		exception: 	MessageNotUnderstood: MiniVoidScope>>rebind:to:
		resumeValue: 	nil
	Receiver's instance variables: 
		outerScope: 	a MiniScope
		bindings: 	a Dictionary()


[ self voidScope rebind: 'foo' to: 9 ] in MiniVoidScopeTestCase>>testVoidScopeRebindTo
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope rebind: 'foo' to: 9 ]
		anExceptionalEvent: 	MiniVoidScopeError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>on:do:
	Receiver: [ 
aBlock value.
false ]
	Arguments and temporary variables: 
		exception: 	MiniVoidScopeError
		handlerAction: 	[ :ex | ex return: true ]
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
		startpc: 	26
		numArgs: 	0


MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope rebind: 'foo' to: 9 ]
		anExceptionalEvent: 	MiniVoidScopeError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestAsserter)>>should:raise:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope rebind: 'foo' to: 9 ]
		anExceptionalEvent: 	MiniVoidScopeError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeRebindTo
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeRebindTo nil nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeRebindTo
		lastUpdate: 	3624531185
		result: 	8 run, 4 passes, 0 skipped, 0 expected failures, 3 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 4 passes, 0 skipped, 0 expected failures, 3 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeRebindTo
		lastUpdate: 	3624531185
		result: 	8 run, 4 passes, 0 skipped, 0 expected failures, 3 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeRebindTo
		lastUpdate: 	3624531185
		result: 	8 run, 4 passes, 0 skipped, 0 expected failures, 3 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeRebindTo
		lastUpdate: 	3624531185
		result: 	8 run, 4 passes, 0 skipped, 0 expected failures, 3 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeRebindTo
		lastUpdate: 	3624531185
		result: 	8 run, 4 passes, 0 skipped, 0 expected failures, 3 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeRebindTo
		lastUpdate: 	3624531185
		result: 	8 run, 4 passes, 0 skipped, 0 expected failures, 3 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeRebindTo')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(596@406) mouseUp 140051541 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeRebindTo')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(596@406) mouseUp 140051541 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeRebindTo')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(596@406) mouseUp 140051541 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeRebindTo')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(596@406) mouseUp 140051541 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	140051541
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(596@406)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(596@406) mouseUp 140051541 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeRebindTo')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(596@406) mouseUp 140051541 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(596@406) mouseUp 140051541 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(596@406) mouseUp 140051541 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(596@406) mouseUp 140051541 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	140051541
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(596@406)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(596@406) mouseUp 140051541 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0



--- The full stack ---
MiniVoidScope(Object)>>doesNotUnderstand: #rebind:to:
[ self voidScope rebind: 'foo' to: 9 ] in MiniVoidScopeTestCase>>testVoidScopeRebindTo
[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
BlockClosure>>on:do:
MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
MiniVoidScopeTestCase(TestAsserter)>>should:raise:
MiniVoidScopeTestCase>>testVoidScopeRebindTo
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniVoidScope>>rebind:to:
9 November 2015 9:13:07.716862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScope(Object)>>doesNotUnderstand: #rebind:to:
	Receiver: a MiniVoidScope
	Arguments and temporary variables: 
		aMessage: 	rebind: 'foo' to: 9
		exception: 	MessageNotUnderstood: MiniVoidScope>>rebind:to:
		resumeValue: 	nil
	Receiver's instance variables: 
		outerScope: 	a MiniScope
		bindings: 	a Dictionary()


[ self voidScope rebind: 'foo' to: 9 ] in MiniVoidScopeTestCase>>testVoidScopeRebindTo
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope rebind: 'foo' to: 9 ]
		anExceptionalEvent: 	MiniVoidScopeError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>on:do:
	Receiver: [ 
aBlock value.
false ]
	Arguments and temporary variables: 
		exception: 	MiniVoidScopeError
		handlerAction: 	[ :ex | ex return: true ]
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
		startpc: 	26
		numArgs: 	0


MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope rebind: 'foo' to: 9 ]
		anExceptionalEvent: 	MiniVoidScopeError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestAsserter)>>should:raise:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope rebind: 'foo' to: 9 ]
		anExceptionalEvent: 	MiniVoidScopeError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeRebindTo
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeRebindTo
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeRebindTo nil nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeRebindTo
		lastUpdate: 	3624531185
		result: 	8 run, 4 passes, 0 skipped, 0 expected failures, 3 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 4 passes, 0 skipped, 0 expected failures, 3 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeRebindTo
		lastUpdate: 	3624531185
		result: 	8 run, 4 passes, 0 skipped, 0 expected failures, 3 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeRebindTo
		lastUpdate: 	3624531185
		result: 	8 run, 4 passes, 0 skipped, 0 expected failures, 3 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeRebindTo
		lastUpdate: 	3624531185
		result: 	8 run, 4 passes, 0 skipped, 0 expected failures, 3 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeRebindTo
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeRebindTo
		lastUpdate: 	3624531185
		result: 	8 run, 4 passes, 0 skipped, 0 expected failures, 3 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	nil
		errorList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeRebindTo)
		errorSelected: 	MiniVoidScopeTestCase>>#testVoidScopeRebindTo
		lastUpdate: 	3624531185
		result: 	8 run, 4 passes, 0 skipped, 0 expected failures, 3 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeRebindTo')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(596@406) mouseUp 140052603 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeRebindTo')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(596@406) mouseUp 140052603 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeRebindTo')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(596@406) mouseUp 140052603 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeRebindTo')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(596@406) mouseUp 140052603 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	140052603
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(596@406)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(596@406) mouseUp 140052603 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeRebindTo')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(596@406) mouseUp 140052603 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(596@406) mouseUp 140052603 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(596@406) mouseUp 140052603 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(596@406) mouseUp 140052603 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	140052603
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(596@406)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(596@406) mouseUp 140052603 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0



--- The full stack ---
MiniVoidScope(Object)>>doesNotUnderstand: #rebind:to:
[ self voidScope rebind: 'foo' to: 9 ] in MiniVoidScopeTestCase>>testVoidScopeRebindTo
[ 
aBlock value.
false ] in MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
BlockClosure>>on:do:
MiniVoidScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
MiniVoidScopeTestCase(TestAsserter)>>should:raise:
MiniVoidScopeTestCase>>testVoidScopeRebindTo
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
9 November 2015 9:15:02.694862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScopeTestCase(TestAsserter)>>assert:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeOuterScope
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624531234
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624531234
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624531234
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624531234
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624531234
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624531234
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		event: 	[(622@223) mouseUp 140167603 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		evt: 	[(622@223) mouseUp 140167603 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(622@223) mouseUp 140167603 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(622@223) mouseUp 140167603 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		timeStamp: 	140167603
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(622@223)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(622@223) mouseUp 140167603 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(622@223) mouseUp 140167603 nil]
		aMorph: 	a PluggableListMorph(99352576)
		localEvt: 	[(622@223) mouseUp 140167603 nil]
		index: 	2
		child: 	a TransformMorph(214171648)
		morphs: 	an Array(a TransformMorph(214171648))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(622@223) mouseUp 140167603 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(622@223) mouseUp 140167603 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	140167603
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(622@223)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(622@223) mouseUp 140167603 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(622@223) mouseUp 140167603 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(622@223) mouseUp 140167603 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(622@223) mouseUp 140167603 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(622@223) mouseUp 140167603 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(622@223) mouseUp 140167603 nil]
		focusHolder: 	a PluggableListMorph(99352576)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(622@223.0) corner: (638@239.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(622@223.0) corner: (638@239.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(99352576)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(622@223) mouseUp 140167603 nil]
		targetOffset: 	(238.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 140167603 622 223 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniVoidScopeTestCase(TestAsserter)>>assert:
MiniVoidScopeTestCase>>testVoidScopeOuterScope
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
9 November 2015 9:39:34.228862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScopeTestCase(TestAsserter)>>assert:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeOuterScope
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624532771
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624532771
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624532771
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624532771
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624532771
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624532771
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		event: 	[(477@223) mouseUp 141639119 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		evt: 	[(477@223) mouseUp 141639119 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(477@223) mouseUp 141639119 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(477@223) mouseUp 141639119 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		timeStamp: 	141639119
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(477@223)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(477@223) mouseUp 141639119 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@223) mouseUp 141639119 nil]
		aMorph: 	a PluggableListMorph(99352576)
		localEvt: 	[(477@223) mouseUp 141639119 nil]
		index: 	2
		child: 	a TransformMorph(214171648)
		morphs: 	an Array(a TransformMorph(214171648))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@223) mouseUp 141639119 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(477@223) mouseUp 141639119 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	141639119
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(477@223)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@223) mouseUp 141639119 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@223) mouseUp 141639119 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(477@223) mouseUp 141639119 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(477@223) mouseUp 141639119 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(477@223) mouseUp 141639119 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(477@223) mouseUp 141639119 nil]
		focusHolder: 	a PluggableListMorph(99352576)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(477@223.0) corner: (493@239.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(477@223.0) corner: (493@239.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(99352576)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(477@223) mouseOver nil nil]
		targetOffset: 	(93.0@4.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 141639119 477 223 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniVoidScopeTestCase(TestAsserter)>>assert:
MiniVoidScopeTestCase>>testVoidScopeOuterScope
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
9 November 2015 9:41:50.746862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScopeTestCase(TestAsserter)>>assert:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeOuterScope
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624532771
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624532771
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624532771
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624532771
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624532771
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624532771
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		event: 	[(484@228) mouseUp 141775634 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		evt: 	[(484@228) mouseUp 141775634 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(484@228) mouseUp 141775634 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(484@228) mouseUp 141775634 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		timeStamp: 	141775634
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(484@228)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(484@228) mouseUp 141775634 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(484@228) mouseUp 141775634 nil]
		aMorph: 	a PluggableListMorph(99352576)
		localEvt: 	[(484@228) mouseUp 141775634 nil]
		index: 	2
		child: 	a TransformMorph(214171648)
		morphs: 	an Array(a TransformMorph(214171648))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(484@228) mouseUp 141775634 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(484@228) mouseUp 141775634 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	141775634
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(484@228)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(484@228) mouseUp 141775634 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(484@228) mouseUp 141775634 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(484@228) mouseUp 141775634 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(484@228) mouseUp 141775634 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(484@228) mouseUp 141775634 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(484@228) mouseUp 141775634 nil]
		focusHolder: 	a PluggableListMorph(99352576)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(485@227.0) corner: (501@243.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(485@227.0) corner: (501@243.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(99352576)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(485@227) mouseOver nil nil]
		targetOffset: 	(99.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 141775681 484 227 0 0 1 1)
		lastKeyScanCode: 	90
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniVoidScopeTestCase(TestAsserter)>>assert:
MiniVoidScopeTestCase>>testVoidScopeOuterScope
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
9 November 2015 9:42:04.496862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScopeTestCase(TestAsserter)>>assert:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeOuterScope
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624532920
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624532920
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624532920
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	nil
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624532920
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	nil
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624532920
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	nil
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624532920
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		event: 	[(470@226) mouseUp 141789384 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		evt: 	[(470@226) mouseUp 141789384 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(470@226) mouseUp 141789384 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(470@226) mouseUp 141789384 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		timeStamp: 	141789384
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(470@226)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(470@226) mouseUp 141789384 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(470@226) mouseUp 141789384 nil]
		aMorph: 	a PluggableListMorph(99352576)
		localEvt: 	[(470@226) mouseUp 141789384 nil]
		index: 	2
		child: 	a TransformMorph(214171648)
		morphs: 	an Array(a TransformMorph(214171648))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(470@226) mouseUp 141789384 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(470@226) mouseUp 141789384 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	141789384
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(470@226)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(470@226) mouseUp 141789384 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(470@226) mouseUp 141789384 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(470@226) mouseUp 141789384 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(470@226) mouseUp 141789384 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(470@226) mouseUp 141789384 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(470@226) mouseUp 141789384 nil]
		focusHolder: 	a PluggableListMorph(99352576)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(470@226.0) corner: (486@242.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(470@226.0) corner: (486@242.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(99352576)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(470@226) mouseOver nil nil]
		targetOffset: 	(86.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 141789463 470 226 0 0 2 1)
		lastKeyScanCode: 	90
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniVoidScopeTestCase(TestAsserter)>>assert:
MiniVoidScopeTestCase>>testVoidScopeOuterScope
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
9 November 2015 9:43:46.544862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScopeTestCase(TestAsserter)>>assert:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeOuterScope
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624533024
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624533024
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624533024
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624533024
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624533024
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624533024
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		event: 	[(607@228) mouseUp 141891416 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		evt: 	[(607@228) mouseUp 141891416 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(607@228) mouseUp 141891416 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(607@228) mouseUp 141891416 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		timeStamp: 	141891416
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(607@228)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(607@228) mouseUp 141891416 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(607@228) mouseUp 141891416 nil]
		aMorph: 	a PluggableListMorph(99352576)
		localEvt: 	[(607@228) mouseUp 141891416 nil]
		index: 	2
		child: 	a TransformMorph(214171648)
		morphs: 	an Array(a TransformMorph(214171648))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(607@228) mouseUp 141891416 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(607@228) mouseUp 141891416 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	141891416
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(607@228)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(607@228) mouseUp 141891416 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(607@228) mouseUp 141891416 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(607@228) mouseUp 141891416 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(607@228) mouseUp 141891416 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(607@228) mouseUp 141891416 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(607@228) mouseUp 141891416 nil]
		focusHolder: 	a PluggableListMorph(99352576)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(607@228.0) corner: (623@244.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(607@228.0) corner: (623@244.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(99352576)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(607@228) mouseOver nil nil]
		targetOffset: 	(223.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 141891416 607 228 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniVoidScopeTestCase(TestAsserter)>>assert:
MiniVoidScopeTestCase>>testVoidScopeOuterScope
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
9 November 2015 9:45:17.601862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScopeTestCase(TestAsserter)>>assert:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeOuterScope
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624533112
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624533112
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624533112
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624533112
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624533112
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624533112
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		event: 	[(548@229) mouseUp 141982463 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		evt: 	[(548@229) mouseUp 141982463 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(548@229) mouseUp 141982463 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(548@229) mouseUp 141982463 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		timeStamp: 	141982463
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(548@229)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(548@229) mouseUp 141982463 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(548@229) mouseUp 141982463 nil]
		aMorph: 	a PluggableListMorph(99352576)
		localEvt: 	[(548@229) mouseUp 141982463 nil]
		index: 	2
		child: 	a TransformMorph(214171648)
		morphs: 	an Array(a TransformMorph(214171648))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(548@229) mouseUp 141982463 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(548@229) mouseUp 141982463 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	141982463
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(548@229)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(548@229) mouseUp 141982463 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(548@229) mouseUp 141982463 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(548@229) mouseUp 141982463 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(548@229) mouseUp 141982463 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(548@229) mouseUp 141982463 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(548@229) mouseUp 141982463 nil]
		focusHolder: 	a PluggableListMorph(99352576)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(548@229.0) corner: (564@245.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(548@229.0) corner: (564@245.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	a PluggableListMorph(99352576)
		keyboardFocus: 	a PluggableListMorph(99352576)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickDown]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(548@229) mouseOver red nil nil]
		targetOffset: 	(164.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 141982509 548 229 4 0 1 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniVoidScopeTestCase(TestAsserter)>>assert:
MiniVoidScopeTestCase>>testVoidScopeOuterScope
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
9 November 2015 9:50:11.335862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScopeTestCase(TestAsserter)>>assert:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeOuterScope
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624533112
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624533112
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624533112
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624533112
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624533112
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624533112
		result: 	8 run, 5 passes, 0 skipped, 0 expected failures, 3 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		event: 	[(429@229) mouseUp 142276228 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		evt: 	[(429@229) mouseUp 142276228 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(429@229) mouseUp 142276228 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(429@229) mouseUp 142276228 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		timeStamp: 	142276228
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(429@229)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(429@229) mouseUp 142276228 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(429@229) mouseUp 142276228 nil]
		aMorph: 	a PluggableListMorph(99352576)
		localEvt: 	[(429@229) mouseUp 142276228 nil]
		index: 	2
		child: 	a TransformMorph(214171648)
		morphs: 	an Array(a TransformMorph(214171648))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(429@229) mouseUp 142276228 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(429@229) mouseUp 142276228 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	142276228
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(429@229)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(429@229) mouseUp 142276228 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(429@229) mouseUp 142276228 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(429@229) mouseUp 142276228 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(429@229) mouseUp 142276228 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(429@229) mouseUp 142276228 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(429@229) mouseUp 142276228 nil]
		focusHolder: 	a PluggableListMorph(99352576)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(429@229.0) corner: (445@245.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(99352576)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(429@229) mouseOver nil nil]
		targetOffset: 	(45.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 142276025 429 229 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniVoidScopeTestCase(TestAsserter)>>assert:
MiniVoidScopeTestCase>>testVoidScopeOuterScope
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
9 November 2015 10:04:20.352862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScopeTestCase(TestAsserter)>>assert:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeSetBindings
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeSetBindings
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestAsserter)>>should:raise:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeSetBindings
	Arguments and temporary variables: 
		aBlock: 	[ self voidScope bindings: Dictionary new ]
		anExceptionalEvent: 	MiniVoidScopeError
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeSetBindings
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeSetBindings
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeSetBindings
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeSetBindings
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeSetBindings
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeSetBindings
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeSetBindings
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeSetBindings
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeSetBindings
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeSetBindings
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeSetBindings
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeSetBindings
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeSetBindings
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeSetBindings
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeSetBindings
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeSetBindings)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeSetBindings)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeSetBindings nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeSetBindings)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeSetBindings)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeSetBindings
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624534258
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 2 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 6 passes, 0 skipped, 0 expected failures, 2 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeSetBindings
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624534258
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 2 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeSetBindings
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624534258
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 2 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeSetBindings
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624534258
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 2 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeSetBindings
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeSetBindings
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624534258
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 2 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	2
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeSetBindings
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624534258
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 2 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anInteger: 	2
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		event: 	[(527@246) mouseUp 143125259 nil]
		row: 	2
		mdr: 	2
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		evt: 	[(527@246) mouseUp 143125259 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(527@246) mouseUp 143125259 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(527@246) mouseUp 143125259 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		timeStamp: 	143125259
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(527@246)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(527@246) mouseUp 143125259 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(527@246) mouseUp 143125259 nil]
		aMorph: 	a PluggableListMorph(99352576)
		localEvt: 	[(527@246) mouseUp 143125259 nil]
		index: 	2
		child: 	a TransformMorph(214171648)
		morphs: 	an Array(a TransformMorph(214171648))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(527@246) mouseUp 143125259 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(527@246) mouseUp 143125259 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	143125259
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(527@246)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(527@246) mouseUp 143125259 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(527@246) mouseUp 143125259 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(527@246) mouseUp 143125259 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(527@246) mouseUp 143125259 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(527@246) mouseUp 143125259 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
MiniVoidScopeTestCase(TestAsserter)>>assert:
MiniVoidScopeTestCase(TestAsserter)>>should:raise:
MiniVoidScopeTestCase>>testVoidScopeSetBindings
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
9 November 2015 10:17:07.697862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScopeTestCase(TestAsserter)>>assert:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeOuterScope
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624534876
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624534876
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624534876
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624534876
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624534876
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624534876
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		event: 	[(512@227) mouseUp 143892603 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		evt: 	[(512@227) mouseUp 143892603 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(512@227) mouseUp 143892603 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(512@227) mouseUp 143892603 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		timeStamp: 	143892603
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(512@227)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(512@227) mouseUp 143892603 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(512@227) mouseUp 143892603 nil]
		aMorph: 	a PluggableListMorph(99352576)
		localEvt: 	[(512@227) mouseUp 143892603 nil]
		index: 	2
		child: 	a TransformMorph(214171648)
		morphs: 	an Array(a TransformMorph(214171648))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(512@227) mouseUp 143892603 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(512@227) mouseUp 143892603 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	143892603
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(512@227)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(512@227) mouseUp 143892603 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(512@227) mouseUp 143892603 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(512@227) mouseUp 143892603 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(512@227) mouseUp 143892603 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(512@227) mouseUp 143892603 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(512@227) mouseUp 143892603 nil]
		focusHolder: 	a PluggableListMorph(99352576)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(512@227.0) corner: (528@243.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(512@227.0) corner: (528@243.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(99352576)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(512@227) mouseOver nil nil]
		targetOffset: 	(128.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 143892603 512 227 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniVoidScopeTestCase(TestAsserter)>>assert:
MiniVoidScopeTestCase>>testVoidScopeOuterScope
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScope class>>outerScope
9 November 2015 11:07:07.737862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScope class(Object)>>doesNotUnderstand: #outerScope
	Receiver: MiniScope
	Arguments and temporary variables: 
		aMessage: 	outerScope
		exception: 	MessageNotUnderstood: MiniScope class>>outerScope
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bind:to:->MiniScope>>#bind:to: #bindings->MiniS...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#outerScope #bindings)
		organization: 	a ClassOrganization
		subclasses: 	{MiniVoidScope}
		name: 	#MiniScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil


MiniScopeTestCase>>testGlobalScope
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aScope: 	MiniScope
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testGlobalScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538025
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538025
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538025
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538025
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538025
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538025
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(648@405) mouseUp 146892509 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(648@405) mouseUp 146892509 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(648@405) mouseUp 146892509 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(648@405) mouseUp 146892509 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	146892509
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(648@405)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(648@405) mouseUp 146892509 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(648@405) mouseUp 146892509 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(648@405) mouseUp 146892509 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(648@405) mouseUp 146892509 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(648@405) mouseUp 146892509 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	146892509
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(648@405)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(648@405) mouseUp 146892509 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(648@405) mouseUp 146892509 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(648@405) mouseUp 146892509 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(648@405) mouseUp 146892509 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(648@405) mouseUp 146892509 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(648@405) mouseUp 146892509 nil]
		focusHolder: 	a PluggableListMorph(696778752)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(617@455.0) corner: (633@471.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(617@455.0) corner: (633@471.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(696778752)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(617@455) mouseOver nil nil]
		targetOffset: 	(264.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 146892775 606 469 0 0 1 1)
		lastKeyScanCode: 	18
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScope class(Object)>>doesNotUnderstand: #outerScope
MiniScopeTestCase>>testGlobalScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
KeyNotFound: key 'foo' not found in Dictionary
9 November 2015 11:08:29.399862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

Dictionary>>errorKeyNotFound:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		aKey: 	'foo'
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


[ self errorKeyNotFound: key ] in Dictionary>>associationAt:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		key: 	'foo'
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


Dictionary>>associationAt:ifAbsent:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		key: 	'foo'
		aBlock: 	[ self errorKeyNotFound: key ]
		index: 	3
		assoc: 	nil
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


Dictionary>>associationAt:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		key: 	'foo'
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


MiniScope>>hasBindingFor:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aName: 	'foo'
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary()


MiniScopeTestCase>>testGlobalScope
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aScope: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testGlobalScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538106
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538106
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538106
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538106
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538106
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538106
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(604@405) mouseUp 146974244 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(604@405) mouseUp 146974244 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(604@405) mouseUp 146974244 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(604@405) mouseUp 146974244 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	146974244
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(604@405)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(604@405) mouseUp 146974244 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(604@405) mouseUp 146974244 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(604@405) mouseUp 146974244 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(604@405) mouseUp 146974244 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(604@405) mouseUp 146974244 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	146974244
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(604@405)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(604@405) mouseUp 146974244 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(604@405) mouseUp 146974244 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil



--- The full stack ---
Dictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>associationAt:
Dictionary>>associationAt:ifAbsent:
Dictionary>>associationAt:
MiniScope>>hasBindingFor:
MiniScopeTestCase>>testGlobalScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Dictionary>>at:ifAbsent:ifPresent:
9 November 2015 11:10:47.092862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

Dictionary(Object)>>doesNotUnderstand: #at:ifAbsent:ifPresent:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		aMessage: 	at: 'foo' ifAbsent: [ ^ false ] ifPresent: [ ^ true ]
		exception: 	MessageNotUnderstood: Dictionary>>at:ifAbsent:ifPresent:
		resumeValue: 	nil
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


MiniScope>>hasBindingFor:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aName: 	'foo'
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary()


MiniScopeTestCase>>testGlobalScope
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aScope: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testGlobalScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538245
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538245
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538245
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538245
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538245
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538245
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(569@398) mouseUp 147111994 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(569@398) mouseUp 147111994 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(569@398) mouseUp 147111994 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(569@398) mouseUp 147111994 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	147111994
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(569@398)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(569@398) mouseUp 147111994 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(569@398) mouseUp 147111994 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(569@398) mouseUp 147111994 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(569@398) mouseUp 147111994 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(569@398) mouseUp 147111994 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	147111994
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(569@398)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(569@398) mouseUp 147111994 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(569@398) mouseUp 147111994 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(569@398) mouseUp 147111994 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(569@398) mouseUp 147111994 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(569@398) mouseUp 147111994 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
Dictionary(Object)>>doesNotUnderstand: #at:ifAbsent:ifPresent:
MiniScope>>hasBindingFor:
MiniScopeTestCase>>testGlobalScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Dictionary>>at:ifAbsent:ifPresent:
9 November 2015 11:10:48.167862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

Dictionary(Object)>>doesNotUnderstand: #at:ifAbsent:ifPresent:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		aMessage: 	at: 'foo' ifAbsent: [ ^ false ] ifPresent: [ ^ true ]
		exception: 	MessageNotUnderstood: Dictionary>>at:ifAbsent:ifPresent:
		resumeValue: 	nil
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


MiniScope>>hasBindingFor:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aName: 	'foo'
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary()


MiniScopeTestCase>>testGlobalScope
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aScope: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testGlobalScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538245
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538245
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538245
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538245
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538245
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538245
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(569@398) mouseUp 147113072 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(569@398) mouseUp 147113072 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(569@398) mouseUp 147113072 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(569@398) mouseUp 147113072 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	147113072
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(569@398)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(569@398) mouseUp 147113072 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(569@398) mouseUp 147113072 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(569@398) mouseUp 147113072 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(569@398) mouseUp 147113072 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(569@398) mouseUp 147113072 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	147113072
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(569@398)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(569@398) mouseUp 147113072 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(569@398) mouseUp 147113072 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(569@398) mouseUp 147113072 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(569@398) mouseUp 147113072 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(569@398) mouseUp 147113072 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
Dictionary(Object)>>doesNotUnderstand: #at:ifAbsent:ifPresent:
MiniScope>>hasBindingFor:
MiniScopeTestCase>>testGlobalScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
KeyNotFound: key 'foo' not found in Dictionary
9 November 2015 11:11:18.144862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

Dictionary>>errorKeyNotFound:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		aKey: 	'foo'
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


[ self errorKeyNotFound: key ] in Dictionary>>at:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		key: 	'foo'
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


Dictionary>>at:ifAbsent:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		key: 	'foo'
		aBlock: 	[ self errorKeyNotFound: key ]
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


Dictionary>>at:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		key: 	'foo'
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


MiniScope>>hasBindingFor:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aName: 	'foo'
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary()


MiniScopeTestCase>>testGlobalScope
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aScope: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testGlobalScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538276
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538276
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538276
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538276
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538276
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624538276
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(470@395) mouseUp 147143025 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(470@395) mouseUp 147143025 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(470@395) mouseUp 147143025 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(470@395) mouseUp 147143025 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	147143025
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(470@395)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(470@395) mouseUp 147143025 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(470@395) mouseUp 147143025 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(470@395) mouseUp 147143025 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(470@395) mouseUp 147143025 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(470@395) mouseUp 147143025 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	147143025
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(470@395)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(470@395) mouseUp 147143025 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(470@395) mouseUp 147143025 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil



--- The full stack ---
Dictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at:
Dictionary>>at:ifAbsent:
Dictionary>>at:
MiniScope>>hasBindingFor:
MiniScopeTestCase>>testGlobalScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
9 November 2015 11:34:24.984862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScopeTestCase(TestAsserter)>>assert:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeOuterScope
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624539274
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624539274
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624539274
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624539274
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624539274
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	3
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624539274
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		event: 	[(400@369) mouseUp 148529884 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		evt: 	[(400@369) mouseUp 148529884 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(400@369) mouseUp 148529884 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(400@369) mouseUp 148529884 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		timeStamp: 	148529884
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(400@369)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(400@369) mouseUp 148529884 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(400@369) mouseUp 148529884 nil]
		aMorph: 	a PluggableListMorph(99352576)
		localEvt: 	[(400@369) mouseUp 148529884 nil]
		index: 	2
		child: 	a TransformMorph(214171648)
		morphs: 	an Array(a TransformMorph(214171648))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(400@369) mouseUp 148529884 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(400@369) mouseUp 148529884 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	148529884
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(400@369)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(400@369) mouseUp 148529884 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(400@369) mouseUp 148529884 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(400@369) mouseUp 148529884 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(400@369) mouseUp 148529884 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(400@369) mouseUp 148529884 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(400@369) mouseUp 148529884 nil]
		focusHolder: 	a PluggableListMorph(99352576)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(400@369.0) corner: (416@385.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(400@369.0) corner: (416@385.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(99352576)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(400@369) mouseUp 148529884 nil]
		targetOffset: 	(16.0@151.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 148529884 400 369 0 0 1 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniVoidScopeTestCase(TestAsserter)>>assert:
MiniVoidScopeTestCase>>testVoidScopeOuterScope
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
9 November 2015 11:36:31.191862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScopeTestCase(TestAsserter)>>assert:
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase>>testVoidScopeOuterScope
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


MiniVoidScopeTestCase(TestCase)>>performTest
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>runCase
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	nil
		voidScope: 	a MiniVoidScope


[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniVoidScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniVoidScopeTestCase(TestCase)>>debug
	Receiver: MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVoidScopeOuterScope
		expectedFails: 	#()
		voidScope: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniVoidScopeTestCase>>#testVoidScopeOuterScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624539788
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 2 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 6 passes, 0 skipped, 0 expected failures, 2 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624539788
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 2 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624539788
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 2 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624539788
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 2 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624539788
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 2 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniVoidScopeTestCase)
		failedList: 	an Array(MiniVoidScopeTestCase>>#testVoidScopeOuterScope MiniVoidSc...etc...
		failedSelected: 	MiniVoidScopeTestCase>>#testVoidScopeOuterScope
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3624539788
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 2 failures, 0 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		event: 	[(651@227) mouseUp 148656088 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		evt: 	[(651@227) mouseUp 148656088 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(651@227) mouseUp 148656088 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(651@227) mouseUp 148656088 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		timeStamp: 	148656088
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(651@227)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(651@227) mouseUp 148656088 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(651@227) mouseUp 148656088 nil]
		aMorph: 	a PluggableListMorph(99352576)
		localEvt: 	[(651@227) mouseUp 148656088 nil]
		index: 	2
		child: 	a TransformMorph(214171648)
		morphs: 	an Array(a TransformMorph(214171648))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(651@227) mouseUp 148656088 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(651@227) mouseUp 148656088 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	148656088
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(651@227)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(651@227) mouseUp 148656088 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(651@227) mouseUp 148656088 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(651@227) mouseUp 148656088 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(651@227) mouseUp 148656088 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(651@227) mouseUp 148656088 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniVoidScopeTestCase>>#testVoidScopeOuterScope' 'MiniVoidScopeTestCas...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(651@227) mouseUp 148656088 nil]
		focusHolder: 	a PluggableListMorph(99352576)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(651@227.0) corner: (667@243.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(651@227.0) corner: (667@243.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(99352576)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(651@227) mouseOver nil nil]
		targetOffset: 	(266.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 148656088 651 227 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniVoidScopeTestCase(TestAsserter)>>assert:
MiniVoidScopeTestCase>>testVoidScopeOuterScope
MiniVoidScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniVoidScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniVoidScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniVoidScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScope class>>newScopeIn:
9 November 2015 11:38:50.063862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScope class(Object)>>doesNotUnderstand: #newScopeIn:
	Receiver: MiniScope
	Arguments and temporary variables: 
		aMessage: 	newScopeIn: a MiniScope
		exception: 	MessageNotUnderstood: MiniScope class>>newScopeIn:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bind:to:->MiniScope>>#bind:to: #bindings->MiniS...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#outerScope #bindings)
		organization: 	a ClassOrganization
		subclasses: 	{MiniVoidScope}
		name: 	#MiniScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	nil
		scopeB: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624539927
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624539927
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624539927
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624539927
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624539927
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	2
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624539927
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	2
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(606@408) mouseUp 148794963 nil]
		row: 	2
		mdr: 	2
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(606@408) mouseUp 148794963 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(606@408) mouseUp 148794963 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(606@408) mouseUp 148794963 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	148794963
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(606@408)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(606@408) mouseUp 148794963 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(606@408) mouseUp 148794963 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(606@408) mouseUp 148794963 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(606@408) mouseUp 148794963 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(606@408) mouseUp 148794963 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	148794963
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(606@408)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(606@408) mouseUp 148794963 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(606@408) mouseUp 148794963 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(606@408) mouseUp 148794963 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(606@408) mouseUp 148794963 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(606@408) mouseUp 148794963 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(606@408) mouseUp 148794963 nil]
		focusHolder: 	a PluggableListMorph(696778752)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(607@404.0) corner: (623@420.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(607@404.0) corner: (623@420.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(696778752)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(607@404) mouseOver nil nil]
		targetOffset: 	(221.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 148795181 607 404 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScope class(Object)>>doesNotUnderstand: #newScopeIn:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
KeyNotFound: key 'foo' not found in Dictionary
9 November 2015 11:38:50.739862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

Dictionary>>errorKeyNotFound:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		aKey: 	'foo'
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


[ self errorKeyNotFound: key ] in Dictionary>>at:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		key: 	'foo'
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


Dictionary>>at:ifAbsent:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		key: 	'foo'
		aBlock: 	[ self errorKeyNotFound: key ]
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


Dictionary>>at:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		key: 	'foo'
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


MiniScope>>hasBindingFor:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aName: 	'foo'
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary()


MiniScopeTestCase>>testGlobalScope
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aScope: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testGlobalScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624539927
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624539927
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624539927
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624539927
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624539927
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624539927
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(611@393) mouseUp 148795634 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(611@393) mouseUp 148795634 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(611@393) mouseUp 148795634 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(611@393) mouseUp 148795634 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	148795634
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(611@393)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(611@393) mouseUp 148795634 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(611@393) mouseUp 148795634 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(611@393) mouseUp 148795634 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(611@393) mouseUp 148795634 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(611@393) mouseUp 148795634 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	148795634
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(611@393)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(611@393) mouseUp 148795634 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(611@393) mouseUp 148795634 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil



--- The full stack ---
Dictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at:
Dictionary>>at:ifAbsent:
Dictionary>>at:
MiniScope>>hasBindingFor:
MiniScopeTestCase>>testGlobalScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
KeyNotFound: key 'foo' not found in Dictionary
9 November 2015 11:46:47.215862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

Dictionary>>errorKeyNotFound:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		aKey: 	'foo'
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


[ self errorKeyNotFound: key ] in Dictionary>>at:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		key: 	'foo'
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


Dictionary>>at:ifAbsent:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		key: 	'foo'
		aBlock: 	[ self errorKeyNotFound: key ]
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


Dictionary>>at:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		key: 	'foo'
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


MiniScope>>hasBindingFor:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aName: 	'foo'
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary()


MiniScopeTestCase>>testGlobalScope
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aScope: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testGlobalScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624540405
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624540405
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624540405
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624540405
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624540405
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624540405
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(552@400) mouseUp 149272041 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(552@400) mouseUp 149272041 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(552@400) mouseUp 149272041 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(552@400) mouseUp 149272041 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	149272041
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(552@400)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(552@400) mouseUp 149272041 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(552@400) mouseUp 149272041 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(552@400) mouseUp 149272041 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(552@400) mouseUp 149272041 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(552@400) mouseUp 149272041 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	149272041
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(552@400)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(552@400) mouseUp 149272041 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(552@400) mouseUp 149272041 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil



--- The full stack ---
Dictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at:
Dictionary>>at:ifAbsent:
Dictionary>>at:
MiniScope>>hasBindingFor:
MiniScopeTestCase>>testGlobalScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScope>>bindingFor:
9 November 2015 11:50:06.034862 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScope(Object)>>doesNotUnderstand: #bindingFor:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aMessage: 	bindingFor: 'foo'
		exception: 	MessageNotUnderstood: MiniScope>>bindingFor:
		resumeValue: 	nil
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary('foo'->nil )


MiniScopeTestCase>>testGlobalScope
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aScope: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testGlobalScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624540602
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624540602
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624540602
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624540602
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624540602
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624540602
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(609@397) mouseUp 149470869 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(609@397) mouseUp 149470869 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(609@397) mouseUp 149470869 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(609@397) mouseUp 149470869 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	149470869
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(609@397)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(609@397) mouseUp 149470869 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(609@397) mouseUp 149470869 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(609@397) mouseUp 149470869 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(609@397) mouseUp 149470869 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(609@397) mouseUp 149470869 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	149470869
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(609@397)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(609@397) mouseUp 149470869 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(609@397) mouseUp 149470869 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(609@397) mouseUp 149470869 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(609@397) mouseUp 149470869 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(609@397) mouseUp 149470869 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(609@397) mouseUp 149470869 nil]
		focusHolder: 	a PluggableListMorph(696778752)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(609@397.0) corner: (625@413.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(609@397.0) corner: (625@413.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	a PluggableListMorph(696778752)
		keyboardFocus: 	a PluggableListMorph(696778752)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickDown]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(609@397) mouseOver red nil nil]
		targetOffset: 	(225.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 149470947 609 397 4 0 2 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScope(Object)>>doesNotUnderstand: #bindingFor:
MiniScopeTestCase>>testGlobalScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
9 November 2015 12:03:45.990862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScopeTestCase(TestAsserter)>>assert:
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase>>testGlobalScope
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aScope: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testGlobalScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testGlobalScope)
		failedSelected: 	MiniScopeTestCase>>#testGlobalScope
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	nil
		lastUpdate: 	3624541423
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testGlobalScope)
		failedSelected: 	MiniScopeTestCase>>#testGlobalScope
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	nil
		lastUpdate: 	3624541423
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testGlobalScope)
		failedSelected: 	MiniScopeTestCase>>#testGlobalScope
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	nil
		lastUpdate: 	3624541423
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testGlobalScope)
		failedSelected: 	MiniScopeTestCase>>#testGlobalScope
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	nil
		lastUpdate: 	3624541423
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testGlobalScope)
		failedSelected: 	MiniScopeTestCase>>#testGlobalScope
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	nil
		lastUpdate: 	3624541423
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testGlobalScope)
		failedSelected: 	MiniScopeTestCase>>#testGlobalScope
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	nil
		lastUpdate: 	3624541423
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniScopeTestCase>>#testGlobalScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		event: 	[(626@228) mouseUp 150290759 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniScopeTestCase>>#testGlobalScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		evt: 	[(626@228) mouseUp 150290759 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniScopeTestCase>>#testGlobalScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(626@228) mouseUp 150290759 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniScopeTestCase>>#testGlobalScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(626@228) mouseUp 150290759 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		timeStamp: 	150290759
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(626@228)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(626@228) mouseUp 150290759 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniScopeTestCase>>#testGlobalScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(626@228) mouseUp 150290759 nil]
		aMorph: 	a PluggableListMorph(99352576)
		localEvt: 	[(626@228) mouseUp 150290759 nil]
		index: 	2
		child: 	a TransformMorph(214171648)
		morphs: 	an Array(a TransformMorph(214171648))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(626@228) mouseUp 150290759 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(626@228) mouseUp 150290759 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	150290759
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(626@228)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(626@228) mouseUp 150290759 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(626@228) mouseUp 150290759 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(626@228) mouseUp 150290759 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniScopeTestCase>>#testGlobalScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(626@228) mouseUp 150290759 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniScopeTestCase>>#testGlobalScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(626@228) mouseUp 150290759 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniScopeTestCase>>#testGlobalScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(626@228) mouseUp 150290759 nil]
		focusHolder: 	a PluggableListMorph(99352576)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(626@228.0) corner: (642@244.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(626@228.0) corner: (642@244.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(99352576)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(626@228) mouseOver nil nil]
		targetOffset: 	(242.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 150290759 626 228 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScopeTestCase(TestAsserter)>>assert:
MiniScopeTestCase>>testGlobalScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
9 November 2015 12:05:18.496862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScopeTestCase(TestAsserter)>>assert:
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestAsserter)>>should:raise:
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aBlock: 	[ aScope bind: 'foo' to: 'fubar' ]
		anExceptionalEvent: 	MiniMultipleDeclarationError
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase>>testGlobalScope
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aScope: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testGlobalScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testGlobalScope)
		failedSelected: 	MiniScopeTestCase>>#testGlobalScope
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	nil
		lastUpdate: 	3624541517
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testGlobalScope)
		failedSelected: 	MiniScopeTestCase>>#testGlobalScope
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	nil
		lastUpdate: 	3624541517
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testGlobalScope)
		failedSelected: 	MiniScopeTestCase>>#testGlobalScope
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	nil
		lastUpdate: 	3624541517
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testGlobalScope)
		failedSelected: 	MiniScopeTestCase>>#testGlobalScope
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	nil
		lastUpdate: 	3624541517
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testGlobalScope)
		failedSelected: 	MiniScopeTestCase>>#testGlobalScope
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	nil
		lastUpdate: 	3624541517
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testGlobalScope)
		failedSelected: 	MiniScopeTestCase>>#testGlobalScope
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	nil
		lastUpdate: 	3624541517
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniScopeTestCase>>#testGlobalScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		event: 	[(481@230) mouseUp 150383384 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniScopeTestCase>>#testGlobalScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		evt: 	[(481@230) mouseUp 150383384 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniScopeTestCase>>#testGlobalScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(481@230) mouseUp 150383384 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniScopeTestCase>>#testGlobalScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(481@230) mouseUp 150383384 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		timeStamp: 	150383384
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(481@230)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(481@230) mouseUp 150383384 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniScopeTestCase>>#testGlobalScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(481@230) mouseUp 150383384 nil]
		aMorph: 	a PluggableListMorph(99352576)
		localEvt: 	[(481@230) mouseUp 150383384 nil]
		index: 	2
		child: 	a TransformMorph(214171648)
		morphs: 	an Array(a TransformMorph(214171648))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(481@230) mouseUp 150383384 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(481@230) mouseUp 150383384 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	150383384
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(481@230)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(481@230) mouseUp 150383384 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(481@230) mouseUp 150383384 nil]
		aMorph: 	a PluggableListMorph(99352576)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(481@230) mouseUp 150383384 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniScopeTestCase>>#testGlobalScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(481@230) mouseUp 150383384 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniScopeTestCase>>#testGlobalScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(99352576)
	Arguments and temporary variables: 
		anEvent: 	[(481@230) mouseUp 150383384 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@218.0) corner: (725.0@386.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(214171648))
		fullBounds: 	(384@218) corner: (725@386)
		color: 	Color white
		extension: 	a MorphExtension (364380160) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(131858432)
		scroller: 	a TransformMorph(214171648)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(722468864)
		list: 	#('MiniScopeTestCase>>#testGlobalScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(234094592)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
MiniScopeTestCase(TestAsserter)>>assert:
MiniScopeTestCase(TestAsserter)>>should:raise:
MiniScopeTestCase>>testGlobalScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MiniVoidScopeError: May not bind in the void scope.
9 November 2015 12:06:26.432862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScope>>bind:to:
	Receiver: a MiniVoidScope
	Arguments and temporary variables: 
		aName: 	'foo'
		aValue: 	nil
	Receiver's instance variables: 
		outerScope: 	a MiniScope
		bindings: 	a Dictionary()


MiniScope>>bind:to:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aName: 	'foo'
		aValue: 	nil
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary()


MiniScopeTestCase>>testGlobalScope
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aScope: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testGlobalScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541584
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541584
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541584
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541584
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541584
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541584
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(477@397) mouseUp 150451338 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(477@397) mouseUp 150451338 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(477@397) mouseUp 150451338 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(477@397) mouseUp 150451338 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	150451338
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(477@397)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(477@397) mouseUp 150451338 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@397) mouseUp 150451338 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(477@397) mouseUp 150451338 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@397) mouseUp 150451338 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(477@397) mouseUp 150451338 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	150451338
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(477@397)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@397) mouseUp 150451338 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@397) mouseUp 150451338 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(477@397) mouseUp 150451338 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(477@397) mouseUp 150451338 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(477@397) mouseUp 150451338 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
MiniVoidScope>>bind:to:
MiniScope>>bind:to:
MiniScopeTestCase>>testGlobalScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScope>>MiniMultipleDeclarationError
9 November 2015 12:08:08.952862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScope(Object)>>doesNotUnderstand: #MiniMultipleDeclarationError
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aMessage: 	MiniMultipleDeclarationError
		exception: 	MessageNotUnderstood: MiniScope>>MiniMultipleDeclarationError
		resumeValue: 	nil
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary('foo'->nil )


MiniScope>>bind:to:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aName: 	'foo'
		aValue: 	'fubar'
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary('foo'->nil )


[ aScope bind: 'foo' to: 'fubar' ] in MiniScopeTestCase>>testGlobalScope
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aScope: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ 
aBlock value.
false ] in MiniScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aBlock: 	[ aScope bind: 'foo' to: 'fubar' ]
		anExceptionalEvent: 	MiniMultipleDeclarationError
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


BlockClosure>>on:do:
	Receiver: [ 
aBlock value.
false ]
	Arguments and temporary variables: 
		exception: 	MiniMultipleDeclarationError
		handlerAction: 	[ :ex | ex return: true ]
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
		startpc: 	26
		numArgs: 	0


MiniScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aBlock: 	[ aScope bind: 'foo' to: 'fubar' ]
		anExceptionalEvent: 	MiniMultipleDeclarationError
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestAsserter)>>should:raise:
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aBlock: 	[ aScope bind: 'foo' to: 'fubar' ]
		anExceptionalEvent: 	MiniMultipleDeclarationError
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase>>testGlobalScope
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aScope: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testGlobalScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541686
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541686
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541686
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541686
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541686
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541686
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(511@400) mouseUp 150553853 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(511@400) mouseUp 150553853 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(511@400) mouseUp 150553853 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(511@400) mouseUp 150553853 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	150553853
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(511@400)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(511@400) mouseUp 150553853 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(511@400) mouseUp 150553853 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(511@400) mouseUp 150553853 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(511@400) mouseUp 150553853 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(511@400) mouseUp 150553853 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	150553853
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(511@400)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(511@400) mouseUp 150553853 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil



--- The full stack ---
MiniScope(Object)>>doesNotUnderstand: #MiniMultipleDeclarationError
MiniScope>>bind:to:
[ aScope bind: 'foo' to: 'fubar' ] in MiniScopeTestCase>>testGlobalScope
[ 
aBlock value.
false ] in MiniScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
BlockClosure>>on:do:
MiniScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
MiniScopeTestCase(TestAsserter)>>should:raise:
MiniScopeTestCase>>testGlobalScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScope>>MiniMultipleDeclarationError
9 November 2015 12:08:09.679862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScope(Object)>>doesNotUnderstand: #MiniMultipleDeclarationError
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aMessage: 	MiniMultipleDeclarationError
		exception: 	MessageNotUnderstood: MiniScope>>MiniMultipleDeclarationError
		resumeValue: 	nil
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary('foo'->nil )


MiniScope>>bind:to:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aName: 	'foo'
		aValue: 	'fubar'
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary('foo'->nil )


[ aScope bind: 'foo' to: 'fubar' ] in MiniScopeTestCase>>testGlobalScope
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aScope: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ 
aBlock value.
false ] in MiniScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aBlock: 	[ aScope bind: 'foo' to: 'fubar' ]
		anExceptionalEvent: 	MiniMultipleDeclarationError
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


BlockClosure>>on:do:
	Receiver: [ 
aBlock value.
false ]
	Arguments and temporary variables: 
		exception: 	MiniMultipleDeclarationError
		handlerAction: 	[ :ex | ex return: true ]
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
		startpc: 	26
		numArgs: 	0


MiniScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aBlock: 	[ aScope bind: 'foo' to: 'fubar' ]
		anExceptionalEvent: 	MiniMultipleDeclarationError
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestAsserter)>>should:raise:
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aBlock: 	[ aScope bind: 'foo' to: 'fubar' ]
		anExceptionalEvent: 	MiniMultipleDeclarationError
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase>>testGlobalScope
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aScope: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testGlobalScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541686
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541686
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541686
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541686
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541686
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541686
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(511@400) mouseUp 150554572 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(511@400) mouseUp 150554572 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(511@400) mouseUp 150554572 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(511@400) mouseUp 150554572 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	150554572
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(511@400)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(511@400) mouseUp 150554572 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(511@400) mouseUp 150554572 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(511@400) mouseUp 150554572 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(511@400) mouseUp 150554572 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(511@400) mouseUp 150554572 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	150554572
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(511@400)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(511@400) mouseUp 150554572 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil



--- The full stack ---
MiniScope(Object)>>doesNotUnderstand: #MiniMultipleDeclarationError
MiniScope>>bind:to:
[ aScope bind: 'foo' to: 'fubar' ] in MiniScopeTestCase>>testGlobalScope
[ 
aBlock value.
false ] in MiniScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
BlockClosure>>on:do:
MiniScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
MiniScopeTestCase(TestAsserter)>>should:raise:
MiniScopeTestCase>>testGlobalScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScope>>MiniMultipleDeclarationError
9 November 2015 12:09:12.185862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScope(Object)>>doesNotUnderstand: #MiniMultipleDeclarationError
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aMessage: 	MiniMultipleDeclarationError
		exception: 	MessageNotUnderstood: MiniScope>>MiniMultipleDeclarationError
		resumeValue: 	nil
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary('foo'->nil )


MiniScope>>bind:to:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aName: 	'foo'
		aValue: 	'fubar'
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary('foo'->nil )


[ aScope bind: 'foo' to: 'fubar' ] in MiniScopeTestCase>>testGlobalScope
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aScope: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ 
aBlock value.
false ] in MiniScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aBlock: 	[ aScope bind: 'foo' to: 'fubar' ]
		anExceptionalEvent: 	MiniMultipleDeclarationError
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


BlockClosure>>on:do:
	Receiver: [ 
aBlock value.
false ]
	Arguments and temporary variables: 
		exception: 	MiniMultipleDeclarationError
		handlerAction: 	[ :ex | ex return: true ]
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
		startpc: 	26
		numArgs: 	0


MiniScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aBlock: 	[ aScope bind: 'foo' to: 'fubar' ]
		anExceptionalEvent: 	MiniMultipleDeclarationError
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestAsserter)>>should:raise:
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aBlock: 	[ aScope bind: 'foo' to: 'fubar' ]
		anExceptionalEvent: 	MiniMultipleDeclarationError
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase>>testGlobalScope
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aScope: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testGlobalScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541750
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541750
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541750
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541750
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541750
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541750
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(612@403) mouseUp 150617088 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(612@403) mouseUp 150617088 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(612@403) mouseUp 150617088 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(612@403) mouseUp 150617088 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	150617088
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(612@403)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(612@403) mouseUp 150617088 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(612@403) mouseUp 150617088 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(612@403) mouseUp 150617088 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(612@403) mouseUp 150617088 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(612@403) mouseUp 150617088 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	150617088
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(612@403)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(612@403) mouseUp 150617088 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil



--- The full stack ---
MiniScope(Object)>>doesNotUnderstand: #MiniMultipleDeclarationError
MiniScope>>bind:to:
[ aScope bind: 'foo' to: 'fubar' ] in MiniScopeTestCase>>testGlobalScope
[ 
aBlock value.
false ] in MiniScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
BlockClosure>>on:do:
MiniScopeTestCase(TestAsserter)>>executeShould:inScopeOf:
MiniScopeTestCase(TestAsserter)>>should:raise:
MiniScopeTestCase>>testGlobalScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScope class>>newScopeIn:
9 November 2015 12:09:38.049862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScope class(Object)>>doesNotUnderstand: #newScopeIn:
	Receiver: MiniScope
	Arguments and temporary variables: 
		aMessage: 	newScopeIn: a MiniScope
		exception: 	MessageNotUnderstood: MiniScope class>>newScopeIn:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bind:to:->MiniScope>>#bind:to: #bindingFor:->Mi...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#outerScope #bindings)
		organization: 	a ClassOrganization
		subclasses: 	{MiniVoidScope}
		name: 	#MiniScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	nil
		scopeB: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624541772
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624541772
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624541772
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624541772
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624541772
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624541772
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(571@406) mouseUp 150642947 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(571@406) mouseUp 150642947 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150642947 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(571@406) mouseUp 150642947 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	150642947
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(571@406)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150642947 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150642947 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(571@406) mouseUp 150642947 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150642947 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(571@406) mouseUp 150642947 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	150642947
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(571@406)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150642947 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150642947 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150642947 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150642947 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150642947 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150642947 nil]
		focusHolder: 	a PluggableListMorph(696778752)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(571@406.0) corner: (587@422.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(571@406.0) corner: (587@422.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(696778752)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(571@406) mouseUp 150642947 nil]
		targetOffset: 	(187.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 150642947 571 406 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScope class(Object)>>doesNotUnderstand: #newScopeIn:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScope class>>newScopeIn:
9 November 2015 12:09:39.088862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScope class(Object)>>doesNotUnderstand: #newScopeIn:
	Receiver: MiniScope
	Arguments and temporary variables: 
		aMessage: 	newScopeIn: a MiniScope
		exception: 	MessageNotUnderstood: MiniScope class>>newScopeIn:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bind:to:->MiniScope>>#bind:to: #bindingFor:->Mi...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#outerScope #bindings)
		organization: 	a ClassOrganization
		subclasses: 	{MiniVoidScope}
		name: 	#MiniScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	nil
		scopeB: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624541772
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624541772
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624541772
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624541772
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624541772
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624541772
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(571@406) mouseUp 150643994 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(571@406) mouseUp 150643994 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150643994 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(571@406) mouseUp 150643994 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	150643994
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(571@406)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150643994 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150643994 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(571@406) mouseUp 150643994 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150643994 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(571@406) mouseUp 150643994 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	150643994
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(571@406)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150643994 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150643994 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150643994 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150643994 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150643994 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(571@406) mouseUp 150643994 nil]
		focusHolder: 	a PluggableListMorph(696778752)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(571@406.0) corner: (587@422.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(571@406.0) corner: (587@422.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(696778752)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(571@406) mouseUp 150643994 nil]
		targetOffset: 	(187.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 150643994 571 406 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScope class(Object)>>doesNotUnderstand: #newScopeIn:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "or:" is nil
9 November 2015 12:10:59.112862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #or:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	or: self outerScope
		exception: 	MessageNotUnderstood: receiver of "or:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

MiniScope>>ExecuteUnOptimizedIn:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		t1: 	MiniScope>>bindingFor:
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary('foo'->nil )


UndefinedObject(Object)>>mustBeBooleanInMagic:
	Receiver: nil
	Arguments and temporary variables: 
		context: 	MiniScope>>bindingFor:
		sendNode: 	RBMessageNode((self bindings at: aName) or: [ self outerScope binding...etc...
		methodNode: 	ExecuteUnOptimizedIn: ThisContext
	^ (self bindings at: (ThisContex...etc...
		method: 	MiniScope>>#ExecuteUnOptimizedIn:
	Receiver's instance variables: 
nil

UndefinedObject(Object)>>mustBeBoolean
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

MiniScope>>bindingFor:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aName: 	'foo'
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary('foo'->nil )


MiniScopeTestCase>>testGlobalScope
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 
		aScope: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testGlobalScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGlobalScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testGlobalScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testGlobalScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541857
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541857
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541857
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541857
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testGlobalScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541857
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(970457088) a SearchMorph(627048448...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testGlobalScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testGlobalScope
		lastUpdate: 	3624541857
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		event: 	[(563@400) mouseUp 150724009 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		evt: 	[(563@400) mouseUp 150724009 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(563@400) mouseUp 150724009 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(563@400) mouseUp 150724009 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		timeStamp: 	150724009
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(563@400)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(696778752)
	Arguments and temporary variables: 
		anEvent: 	[(563@400) mouseUp 150724009 nil]
	Receiver's instance variables: 
		bounds: 	(384.0@390.0) corner: (725.0@589.0)
		owner: 	a SystemWindow(970457088)
		submorphs: 	an Array(a TransformMorph(811597824))
		fullBounds: 	(384@390) corner: (725@589)
		color: 	Color white
		extension: 	a MorphExtension (961806336) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(729284608)
		scroller: 	a TransformMorph(811597824)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(246153216)
		list: 	#('MiniScopeTestCase>>#testGlobalScope' 'MiniScopeTestCase>>#testNestedSc...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(831520768)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(563@400) mouseUp 150724009 nil]
		aMorph: 	a PluggableListMorph(696778752)
		localEvt: 	[(563@400) mouseUp 150724009 nil]
		index: 	2
		child: 	a TransformMorph(811597824)
		morphs: 	an Array(a TransformMorph(811597824))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(563@400) mouseUp 150724009 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(563@400) mouseUp 150724009 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	150724009
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(563@400)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(563@400) mouseUp 150724009 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(563@400) mouseUp 150724009 nil]
		aMorph: 	a PluggableListMorph(696778752)
	Receiver's instance variables: 
		morph: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #or:
MiniScope>>ExecuteUnOptimizedIn:
UndefinedObject(Object)>>mustBeBooleanInMagic:
UndefinedObject(Object)>>mustBeBoolean
MiniScope>>bindingFor:
MiniScopeTestCase>>testGlobalScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScope class>>newScopeIn:
9 November 2015 12:11:35.432862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScope class(Object)>>doesNotUnderstand: #newScopeIn:
	Receiver: MiniScope
	Arguments and temporary variables: 
		aMessage: 	newScopeIn: a MiniScope
		exception: 	MessageNotUnderstood: MiniScope class>>newScopeIn:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bind:to:->MiniScope>>#bind:to: #bindingFor:->Mi...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#outerScope #bindings)
		organization: 	a ClassOrganization
		subclasses: 	{MiniVoidScope}
		name: 	#MiniScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	nil
		scopeB: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624541888
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624541888
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624541888
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624541888
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624541888
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624541888
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424.0@416.0) corner: (765.0@615.0)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(606@426) mouseUp 150760322 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424.0@416.0) corner: (765.0@615.0)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(606@426) mouseUp 150760322 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424.0@416.0) corner: (765.0@615.0)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(606@426) mouseUp 150760322 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424.0@416.0) corner: (765.0@615.0)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(606@426) mouseUp 150760322 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	150760322
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(606@426)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(606@426) mouseUp 150760322 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424.0@416.0) corner: (765.0@615.0)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(606@426) mouseUp 150760322 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(606@426) mouseUp 150760322 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(606@426) mouseUp 150760322 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(606@426) mouseUp 150760322 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	150760322
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(606@426)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(606@426) mouseUp 150760322 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(606@426) mouseUp 150760322 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(606@426) mouseUp 150760322 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424.0@416.0) corner: (765.0@615.0)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(606@426) mouseUp 150760322 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424.0@416.0) corner: (765.0@615.0)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(606@426) mouseUp 150760322 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424.0@416.0) corner: (765.0@615.0)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(606@426) mouseUp 150760322 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(606@426.0) corner: (622@442.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(606@426.0) corner: (622@442.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(606@426) mouseOver nil nil]
		targetOffset: 	(182.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 150760322 606 426 0 0 1 1)
		lastKeyScanCode: 	73
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScope class(Object)>>doesNotUnderstand: #newScopeIn:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScope class>>outerScope
9 November 2015 12:17:25.009862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScope class(Object)>>doesNotUnderstand: #outerScope
	Receiver: MiniScope
	Arguments and temporary variables: 
		aMessage: 	outerScope
		exception: 	MessageNotUnderstood: MiniScope class>>outerScope
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bind:to:->MiniScope>>#bind:to: #bindingFor:->Mi...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#outerScope #bindings)
		organization: 	a ClassOrganization
		subclasses: 	{MiniVoidScope}
		name: 	#MiniScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil


MiniScope class>>newScopeIn:
	Receiver: MiniScope
	Arguments and temporary variables: 
		aName: 	a MiniScope
		aMiniScope: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bind:to:->MiniScope>>#bind:to: #bindingFor:->Mi...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#outerScope #bindings)
		organization: 	a ClassOrganization
		subclasses: 	{MiniVoidScope}
		name: 	#MiniScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	nil
		scopeB: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542242
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542242
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542242
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542242
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542242
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542242
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(507@421) mouseUp 151109916 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(507@421) mouseUp 151109916 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(507@421) mouseUp 151109916 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(507@421) mouseUp 151109916 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	151109916
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(507@421)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(507@421) mouseUp 151109916 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(507@421) mouseUp 151109916 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(507@421) mouseUp 151109916 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(507@421) mouseUp 151109916 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(507@421) mouseUp 151109916 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	151109916
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(507@421)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(507@421) mouseUp 151109916 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(507@421) mouseUp 151109916 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(507@421) mouseUp 151109916 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(507@421) mouseUp 151109916 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(507@421) mouseUp 151109916 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
MiniScope class(Object)>>doesNotUnderstand: #outerScope
MiniScope class>>newScopeIn:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScope class>>newScopeIn:
9 November 2015 12:19:11.585862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScope class(Object)>>doesNotUnderstand: #newScopeIn:
	Receiver: MiniScope
	Arguments and temporary variables: 
		aMessage: 	newScopeIn: a MiniScope
		exception: 	MessageNotUnderstood: MiniScope class>>newScopeIn:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bind:to:->MiniScope>>#bind:to: #bindingFor:->Mi...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#outerScope #bindings)
		organization: 	a ClassOrganization
		subclasses: 	{MiniVoidScope}
		name: 	#MiniScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	nil
		scopeB: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542347
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542347
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542347
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542347
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542347
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542347
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(589@430) mouseUp 151216478 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(589@430) mouseUp 151216478 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(589@430) mouseUp 151216478 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(589@430) mouseUp 151216478 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	151216478
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(589@430)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(589@430) mouseUp 151216478 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(589@430) mouseUp 151216478 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(589@430) mouseUp 151216478 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(589@430) mouseUp 151216478 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(589@430) mouseUp 151216478 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	151216478
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(589@430)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(589@430) mouseUp 151216478 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(589@430) mouseUp 151216478 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(589@430) mouseUp 151216478 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(589@430) mouseUp 151216478 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(589@430) mouseUp 151216478 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(589@430) mouseUp 151216478 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(589@430.0) corner: (605@446.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(589@430.0) corner: (605@446.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(589@430) mouseOver nil nil]
		targetOffset: 	(165.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 151216478 589 430 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScope class(Object)>>doesNotUnderstand: #newScopeIn:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
9 November 2015 12:21:36.167862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(SequenceableCollection)>>first
	Receiver: #()
	Arguments and temporary variables: 

	Receiver's instance variables: 
#()

PackageTreeNautilusUI(AbstractTool)>>compileANewMethodInClass:categorized:from:notifyng:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aClass: 	MiniScope
		aCategory: 	#'instance creation'
		aString: 	''
		aController: 	a PluggableTextMorphWithLimits(1035206656)
		selector: 	nil
		existingMethod: 	nil
		targetClass: 	MiniScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'mini'


PackageTreeNautilusUI(NautilusUI)>>compileAMethodFromCategory:withSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aCategory: 	#'instance creation'
		aString: 	''
		aController: 	a PluggableTextMorphWithLimits(1035206656)
		category: 	#'instance creation'
		selector: 	nil
		class: 	MiniScope
		scroll: 	0.0
		method: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'mini'


MethodDefinitionAcceptor>>accept:notifying:
	Receiver: a MethodDefinitionAcceptor
	Arguments and temporary variables: 
		source: 	''
		aController: 	a PluggableTextMorphWithLimits(1035206656)
		protocol: 	#'instance creation'
		method: 	MiniScope>>#newScopeIn:
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for ''
		aController: 	a PluggableTextMorphWithLimits(1035206656)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'mini'


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		acceptedText: 	a Text for ''
	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	64
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		acceptedText: 	a Text for ''
	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(1 to: 0)
		saveScrollerOffset: 	(-3.0@0.0)
	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>promptForCancel
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		choice: 	true
	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>update:
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		aSymbol: 	#wantToChange
	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PackageTreeNautilusUI(AbstractNautilusUI)>>okToChange
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'mini'


CategoryWidget(AbstractCategoryWidget)>>okToChange
	Receiver: a CategoryWidget
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableIconListMorph(245104640))
		model: 	a PackageTreeNautilusUI
		categoriesList: 	a PluggableIconListMorph(245104640)
		categoriesSelection: 	a Dictionary(#'instance creation'->true )
		categories: 	#(#'-- all --' #accessing #binding #'instance creation')


PluggableIconListMorph(PluggableListMorph)>>mouseDownOnMultiple:forRow:
	Receiver: a PluggableIconListMorph(245104640)
	Arguments and temporary variables: 
		event: 	[(978@136) mouseDown red 151358947 nil]
		row: 	4
		anInteger: 	nil
		oldIndex: 	nil
		oldVal: 	nil
		valueKeeper: 	nil
	Receiver's instance variables: 
		bounds: 	(856.0@66.0) corner: (1064.0@311.0)
		owner: 	a NautilusWindow(1043595264)
		submorphs: 	an Array(a TransformMorph(998244352))
		fullBounds: 	(856@66) corner: (1064@311)
		color: 	Color white
		extension: 	a MorphExtension (327942144) [other:  (announcer -> an Announcer) (d...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a CategoryWidget
		scrollBar: 	a ScrollBar(295960576)
		scroller: 	a TransformMorph(998244352)
		getMenuSelector: 	#categoriesMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(680001536)
		list: 	nil
		getListSelector: 	nil
		getListSizeSelector: 	#categoryListSize
		getListElementSelector: 	#getCategoryItem:
		getIndexSelector: 	#selectedCategoryIndex
		setIndexSelector: 	#selectedCategoryIndex:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	3371497
		lastKeystrokes: 	'd'
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	0
		listMorph: 	a LazyMorphListMorph(915668992)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	#dropMethod:inARow:
		wantsDropSelector: 	nil
		wrapSelector: 	#categoryWrapper:
		searchedElement: 	nil
		multipleSelection: 	true
		dragOnOrOff: 	nil
		setSelectionListSelector: 	#categorySelectionAt:put:
		getSelectionListSelector: 	#categorySelectionAt:
		resetListSelector: 	#resetCategorySelection
		keystrokeSelector: 	#keyPressedOnCategory:
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	4
		canMove: 	false
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil
		getIconSelector: 	#categoryIconFor:


PluggableIconListMorph(PluggableListMorph)>>mouseDown:
	Receiver: a PluggableIconListMorph(245104640)
	Arguments and temporary variables: 
		evt: 	[(978@136) mouseDown red 151358947 nil]
		selectors: 	nil
		row: 	4
	Receiver's instance variables: 
		bounds: 	(856.0@66.0) corner: (1064.0@311.0)
		owner: 	a NautilusWindow(1043595264)
		submorphs: 	an Array(a TransformMorph(998244352))
		fullBounds: 	(856@66) corner: (1064@311)
		color: 	Color white
		extension: 	a MorphExtension (327942144) [other:  (announcer -> an Announcer) (d...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a CategoryWidget
		scrollBar: 	a ScrollBar(295960576)
		scroller: 	a TransformMorph(998244352)
		getMenuSelector: 	#categoriesMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(680001536)
		list: 	nil
		getListSelector: 	nil
		getListSizeSelector: 	#categoryListSize
		getListElementSelector: 	#getCategoryItem:
		getIndexSelector: 	#selectedCategoryIndex
		setIndexSelector: 	#selectedCategoryIndex:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	3371497
		lastKeystrokes: 	'd'
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	0
		listMorph: 	a LazyMorphListMorph(915668992)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	#dropMethod:inARow:
		wantsDropSelector: 	nil
		wrapSelector: 	#categoryWrapper:
		searchedElement: 	nil
		multipleSelection: 	true
		dragOnOrOff: 	nil
		setSelectionListSelector: 	#categorySelectionAt:put:
		getSelectionListSelector: 	#categorySelectionAt:
		resetListSelector: 	#resetCategorySelection
		keystrokeSelector: 	#keyPressedOnCategory:
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	4
		canMove: 	false
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil
		getIconSelector: 	#categoryIconFor:


PluggableIconListMorph(Morph)>>handleMouseDown:
	Receiver: a PluggableIconListMorph(245104640)
	Arguments and temporary variables: 
		anEvent: 	[(978@136) mouseDown red 151358947 nil]
	Receiver's instance variables: 
		bounds: 	(856.0@66.0) corner: (1064.0@311.0)
		owner: 	a NautilusWindow(1043595264)
		submorphs: 	an Array(a TransformMorph(998244352))
		fullBounds: 	(856@66) corner: (1064@311)
		color: 	Color white
		extension: 	a MorphExtension (327942144) [other:  (announcer -> an Announcer) (d...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a CategoryWidget
		scrollBar: 	a ScrollBar(295960576)
		scroller: 	a TransformMorph(998244352)
		getMenuSelector: 	#categoriesMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(680001536)
		list: 	nil
		getListSelector: 	nil
		getListSizeSelector: 	#categoryListSize
		getListElementSelector: 	#getCategoryItem:
		getIndexSelector: 	#selectedCategoryIndex
		setIndexSelector: 	#selectedCategoryIndex:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	3371497
		lastKeystrokes: 	'd'
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	0
		listMorph: 	a LazyMorphListMorph(915668992)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	#dropMethod:inARow:
		wantsDropSelector: 	nil
		wrapSelector: 	#categoryWrapper:
		searchedElement: 	nil
		multipleSelection: 	true
		dragOnOrOff: 	nil
		setSelectionListSelector: 	#categorySelectionAt:put:
		getSelectionListSelector: 	#categorySelectionAt:
		resetListSelector: 	#resetCategorySelection
		keystrokeSelector: 	#keyPressedOnCategory:
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	4
		canMove: 	false
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil
		getIconSelector: 	#categoryIconFor:


MouseButtonEvent>>sentTo:
	Receiver: [(978@136) mouseDown red 151358947 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableIconListMorph(245104640)
	Receiver's instance variables: 
		timeStamp: 	151358947
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	4
		position: 	(978@136)
		handler: 	a PluggableIconListMorph(245104640)
		wasHandled: 	true
		whichButton: 	4


PluggableIconListMorph(Morph)>>handleEvent:
	Receiver: a PluggableIconListMorph(245104640)
	Arguments and temporary variables: 
		anEvent: 	[(978@136) mouseDown red 151358947 nil]
	Receiver's instance variables: 
		bounds: 	(856.0@66.0) corner: (1064.0@311.0)
		owner: 	a NautilusWindow(1043595264)
		submorphs: 	an Array(a TransformMorph(998244352))
		fullBounds: 	(856@66) corner: (1064@311)
		color: 	Color white
		extension: 	a MorphExtension (327942144) [other:  (announcer -> an Announcer) (d...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a CategoryWidget
		scrollBar: 	a ScrollBar(295960576)
		scroller: 	a TransformMorph(998244352)
		getMenuSelector: 	#categoriesMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(680001536)
		list: 	nil
		getListSelector: 	nil
		getListSizeSelector: 	#categoryListSize
		getListElementSelector: 	#getCategoryItem:
		getIndexSelector: 	#selectedCategoryIndex
		setIndexSelector: 	#selectedCategoryIndex:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	3371497
		lastKeystrokes: 	'd'
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	0
		listMorph: 	a LazyMorphListMorph(915668992)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	#dropMethod:inARow:
		wantsDropSelector: 	nil
		wrapSelector: 	#categoryWrapper:
		searchedElement: 	nil
		multipleSelection: 	true
		dragOnOrOff: 	nil
		setSelectionListSelector: 	#categorySelectionAt:put:
		getSelectionListSelector: 	#categorySelectionAt:
		resetListSelector: 	#resetCategorySelection
		keystrokeSelector: 	#keyPressedOnCategory:
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	4
		canMove: 	false
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil
		getIconSelector: 	#categoryIconFor:


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(978@136) mouseDown red 151358947 nil]
		aMorph: 	a PluggableIconListMorph(245104640)
		globalPt: 	(978@136)
		localEvt: 	[(978@136) mouseDown red 151358947 nil]
		index: 	2
		child: 	a TransformMorph(998244352)
		morphs: 	an Array(a TransformMorph(998244352))
		handler: 	a PluggableIconListMorph(245104640)
		inside: 	false
		lastHandler: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseDown:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(978@136) mouseDown red 151358947 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(978@136) mouseDown red 151358947 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	151358947
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	4
		position: 	(978@136)
		handler: 	a PluggableIconListMorph(245104640)
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(978@136) mouseDown red 151358947 nil]
		aMorph: 	a PluggableIconListMorph(245104640)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(978@136) mouseDown red 151358947 nil]
		aMorph: 	a PluggableIconListMorph(245104640)
	Receiver's instance variables: 
		morph: 	nil


PluggableIconListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableIconListMorph(245104640)
	Arguments and temporary variables: 
		anEvent: 	[(978@136) mouseDown red 151358947 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(856.0@66.0) corner: (1064.0@311.0)
		owner: 	a NautilusWindow(1043595264)
		submorphs: 	an Array(a TransformMorph(998244352))
		fullBounds: 	(856@66) corner: (1064@311)
		color: 	Color white
		extension: 	a MorphExtension (327942144) [other:  (announcer -> an Announcer) (d...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a CategoryWidget
		scrollBar: 	a ScrollBar(295960576)
		scroller: 	a TransformMorph(998244352)
		getMenuSelector: 	#categoriesMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(680001536)
		list: 	nil
		getListSelector: 	nil
		getListSizeSelector: 	#categoryListSize
		getListElementSelector: 	#getCategoryItem:
		getIndexSelector: 	#selectedCategoryIndex
		setIndexSelector: 	#selectedCategoryIndex:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	3371497
		lastKeystrokes: 	'd'
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	0
		listMorph: 	a LazyMorphListMorph(915668992)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	#dropMethod:inARow:
		wantsDropSelector: 	nil
		wrapSelector: 	#categoryWrapper:
		searchedElement: 	nil
		multipleSelection: 	true
		dragOnOrOff: 	nil
		setSelectionListSelector: 	#categorySelectionAt:put:
		getSelectionListSelector: 	#categorySelectionAt:
		resetListSelector: 	#resetCategorySelection
		keystrokeSelector: 	#keyPressedOnCategory:
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	4
		canMove: 	false
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil
		getIconSelector: 	#categoryIconFor:


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(978@136) mouseDown red 151358947 nil]
		aMorph: 	a NautilusWindow(1043595264)
		globalPt: 	(978@136)
		localEvt: 	[(978@136) mouseDown red 151358947 nil]
		index: 	12
		child: 	a PluggableIconListMorph(245104640)
		morphs: 	an Array(a WindowEdgeGripMorph(251658240) a WindowEdgeGripMorph(9804185...etc...
		handler: 	nil
		inside: 	nil
		lastHandler: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseDown:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(978@136) mouseDown red 151358947 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(978@136) mouseDown red 151358947 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	151358947
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	4
		position: 	(978@136)
		handler: 	a WorldMorph(511705088) [world]
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(978@136) mouseDown red 151358947 nil]
		aMorph: 	a NautilusWindow(1043595264)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(978@136) mouseDown red 151358947 nil]
		aMorph: 	a NautilusWindow(1043595264)
	Receiver's instance variables: 
		morph: 	nil


NautilusWindow(Morph)>>processEvent:using:
	Receiver: a NautilusWindow(1043595264)
	Arguments and temporary variables: 
		anEvent: 	[(978@136) mouseDown red 151358947 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(426.0@38.0) corner: (1277.0@638.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a WindowEdgeGripMorph(251658240) a WindowEdgeGripMorph(9804...etc...
		fullBounds: 	(426@38) corner: (1277@638)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (786432) [other:  (paneColor -> (Color r: 0.8230000...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	a PackageTreeNautilusUI
		labelString: 	'MiniScope>>#newScopeIn:'
		stripes: 	an Array(a Morph(291766272) a Morph(305135616))
		label: 	a LabelMorph(156499968)'MiniScope>>#newScopeIn:'
		closeBox: 	a MultistateButtonMorph(504365056)
		collapseBox: 	a MultistateButtonMorph(936378368)
		activeOnlyOnTop: 	true
		paneMorphs: 	an Array(a PanelMorph(692584448) a DropListMorph(871890944) a Plugg...etc...
		collapsedFrame: 	nil
		fullFrame: 	(426.0@38.0) corner: (1277.0@638.0)
		isCollapsed: 	false
		menuBox: 	a MultistateButtonMorph(655622144)
		mustNotClose: 	false
		labelWidgetAllowance: 	133
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(333709312)
		expandBox: 	a MultistateButtonMorph(131072000)
		embeddable: 	nil
		announcer: 	an Announcer
		menuBuilder: 	nil
		isResizeable: 	true


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(978@136) mouseDown red 151358947 nil]
		aMorph: 	a WorldMorph(511705088) [world]
		globalPt: 	(978@136)
		localEvt: 	[(978@136) mouseDown red 151358947 nil]
		index: 	2
		child: 	a NautilusWindow(1043595264)
		morphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(1043595264) a SpecW...etc...
		handler: 	a WorldMorph(511705088) [world]
		inside: 	nil
		lastHandler: 	nil
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseDown:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(978@136) mouseDown red 151358947 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(978@136) mouseDown red 151358947 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	151358947
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	4
		position: 	(978@136)
		handler: 	a WorldMorph(511705088) [world]
		wasHandled: 	false
		whichButton: 	4



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Array(SequenceableCollection)>>first
PackageTreeNautilusUI(AbstractTool)>>compileANewMethodInClass:categorized:from:notifyng:
PackageTreeNautilusUI(NautilusUI)>>compileAMethodFromCategory:withSource:notifying:
MethodDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
PluggableTextMorphWithLimits(PluggableTextMorph)>>promptForCancel
PluggableTextMorphWithLimits(PluggableTextMorph)>>update:
PackageTreeNautilusUI(AbstractNautilusUI)>>okToChange
CategoryWidget(AbstractCategoryWidget)>>okToChange
PluggableIconListMorph(PluggableListMorph)>>mouseDownOnMultiple:forRow:
PluggableIconListMorph(PluggableListMorph)>>mouseDown:
PluggableIconListMorph(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
PluggableIconListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableIconListMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
NautilusWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
9 November 2015 12:21:45.639862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(SequenceableCollection)>>first
	Receiver: #()
	Arguments and temporary variables: 

	Receiver's instance variables: 
#()

PackageTreeNautilusUI(AbstractTool)>>compileANewMethodInClass:categorized:from:notifyng:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aClass: 	MiniScope
		aCategory: 	#'instance creation'
		aString: 	''
		aController: 	a PluggableTextMorphWithLimits(1035206656)
		selector: 	nil
		existingMethod: 	nil
		targetClass: 	MiniScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'mini'


PackageTreeNautilusUI(NautilusUI)>>compileAMethodFromCategory:withSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aCategory: 	#'instance creation'
		aString: 	''
		aController: 	a PluggableTextMorphWithLimits(1035206656)
		category: 	#'instance creation'
		selector: 	nil
		class: 	MiniScope
		scroll: 	0.0
		method: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'mini'


MethodDefinitionAcceptor>>accept:notifying:
	Receiver: a MethodDefinitionAcceptor
	Arguments and temporary variables: 
		source: 	''
		aController: 	a PluggableTextMorphWithLimits(1035206656)
		protocol: 	#'instance creation'
		method: 	MiniScope>>#newScopeIn:
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for ''
		aController: 	a PluggableTextMorphWithLimits(1035206656)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'mini'


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		acceptedText: 	a Text for ''
	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	64
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		acceptedText: 	a Text for ''
	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(1 to: 0)
		saveScrollerOffset: 	(-3.0@0.0)
	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>promptForCancel
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		choice: 	true
	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>update:
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		aSymbol: 	#wantToChange
	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PackageTreeNautilusUI(AbstractNautilusUI)>>okToChange
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'mini'


PackageTreeNautilusUI(AbstractTool)>>removeCategory:inClass:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aCategory: 	#'instance creation'
		aClass: 	MiniScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'mini'


[ :item | 
| needToUpdate |
needToUpdate := self removeCategory: item inClass: class.
(needToUpdate and: [ removeACategory not ])
	ifTrue: [ removeACategory := true ].
needToUpdate
	ifTrue: [ self updateCategoryAndMethodList ] ] in [ :items | 
| removeACategory scroll |
scroll := categoryWidget vScrollValue.
removeACategory := false.
items
	do: [ :item | 
		| needToUpdate |
		needToUpdate := self removeCategory: item inClass: class.
		(needToUpdate and: [ removeACategory not ])
			ifTrue: [ removeACategory := true ].
		needToUpdate
			ifTrue: [ self updateCategoryAndMethodList ] ].
removeACategory
	ifTrue: [ self selectedCategory: nil ].
self updateCategoryAndMethodList.
categoryWidget vScrollValue: scroll ] in PackageTreeNautilusUI(NautilusUI)>>removeCategories
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		class: 	MiniScope
		items: 	#(#'instance creation')
		scroll: 	0.0
		removeACategory: 	false
		item: 	#'instance creation'
		needToUpdate: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'mini'


Array(SequenceableCollection)>>do:
	Receiver: #(#'instance creation')
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
| needToUpdate |
needToUpdate := self removeCategory: item i...etc...
		index: 	1
	Receiver's instance variables: 
#(#'instance creation')

[ :items | 
| removeACategory scroll |
scroll := categoryWidget vScrollValue.
removeACategory := false.
items
	do: [ :item | 
		| needToUpdate |
		needToUpdate := self removeCategory: item inClass: class.
		(needToUpdate and: [ removeACategory not ])
			ifTrue: [ removeACategory := true ].
		needToUpdate
			ifTrue: [ self updateCategoryAndMethodList ] ].
removeACategory
	ifTrue: [ self selectedCategory: nil ].
self updateCategoryAndMethodList.
categoryWidget vScrollValue: scroll ] in PackageTreeNautilusUI(NautilusUI)>>removeCategories
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		class: 	MiniScope
		removeACategory: 	false
		items: 	#(#'instance creation')
		scroll: 	0.0
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'mini'


BlockClosure>>cull:
	Receiver: [ :items | 
| removeACategory scroll |
scroll := categoryWidget vScrollValue.
removeACateg...etc...
	Arguments and temporary variables: 
		anArg: 	#(#'instance creation')
	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>removeCategories
		startpc: 	76
		numArgs: 	1


Array(Collection)>>ifNotEmpty:
	Receiver: #(#'instance creation')
	Arguments and temporary variables: 
		aBlock: 	[ :items | 
| removeACategory scroll |
scroll := categoryWidget vScroll...etc...
	Receiver's instance variables: 
#(#'instance creation')

PackageTreeNautilusUI(NautilusUI)>>removeCategories
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		class: 	MiniScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'mini'


[ target removeCategories ] in CategoryWidget class>>categoriesMenu:
	Receiver: CategoryWidget
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		superclass: 	AbstractCategoryWidget
		methodDict: 	a MethodDictionary(#buildCategoriesList->CategoryWidget>>#buildCate...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#categoriesList #categoriesSelection #categories)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CategoryWidget
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Nautilus-Widgets'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ target removeCategories ]
	Arguments and temporary variables: 
		anArg: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		outerContext: 	CategoryWidget class>>categoriesMenu:
		startpc: 	470
		numArgs: 	0


[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(468713472)'Remove...'
	Arguments and temporary variables: 
		evt: 	[(1000@259) mouseUp 151369525 nil]
		w: 	a WorldMorph(511705088) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(937.0@247.0) corner: (1154.0@265.0)
		owner: 	a MenuMorph(313262080)
		submorphs: 	#()
		fullBounds: 	(937.0@247.0) corner: (1154.0@265.0)
		color: 	Color black
		extension: 	a MorphExtension (487849984)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'Remove...'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ target removeCategories ]
		selector: 	#cull:
		arguments: 	an Array(a PackageTreeNautilusUI)
		icon: 	ColorForm(14x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'x, t'


BlockClosure>>ensure:
	Receiver: [ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	134
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(s...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(468713472)'Remove...'
	Arguments and temporary variables: 
		evt: 	[(1000@259) mouseUp 151369525 nil]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(937.0@247.0) corner: (1154.0@265.0)
		owner: 	a MenuMorph(313262080)
		submorphs: 	#()
		fullBounds: 	(937.0@247.0) corner: (1154.0@265.0)
		color: 	Color black
		extension: 	a MorphExtension (487849984)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'Remove...'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ target removeCategories ]
		selector: 	#cull:
		arguments: 	an Array(a PackageTreeNautilusUI)
		icon: 	ColorForm(14x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'x, t'


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(468713472)'Remove...'
	Arguments and temporary variables: 
		evt: 	[(1000@259) mouseUp 151369525 nil]
	Receiver's instance variables: 
		bounds: 	(937.0@247.0) corner: (1154.0@265.0)
		owner: 	a MenuMorph(313262080)
		submorphs: 	#()
		fullBounds: 	(937.0@247.0) corner: (1154.0@265.0)
		color: 	Color black
		extension: 	a MorphExtension (487849984)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'Remove...'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ target removeCategories ]
		selector: 	#cull:
		arguments: 	an Array(a PackageTreeNautilusUI)
		icon: 	ColorForm(14x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'x, t'


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(468713472)'Remove...'
	Arguments and temporary variables: 
		anEvent: 	[(1000@259) mouseUp 151369525 nil]
	Receiver's instance variables: 
		bounds: 	(937.0@247.0) corner: (1154.0@265.0)
		owner: 	a MenuMorph(313262080)
		submorphs: 	#()
		fullBounds: 	(937.0@247.0) corner: (1154.0@265.0)
		color: 	Color black
		extension: 	a MorphExtension (487849984)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'Remove...'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ target removeCategories ]
		selector: 	#cull:
		arguments: 	an Array(a PackageTreeNautilusUI)
		icon: 	ColorForm(14x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'x, t'


MouseButtonEvent>>sentTo:
	Receiver: [(1000@259) mouseUp 151369525 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(468713472)'Remove...'
	Receiver's instance variables: 
		timeStamp: 	151369525
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1000@259)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(468713472)'Remove...'
	Arguments and temporary variables: 
		anEvent: 	[(1000@259) mouseUp 151369525 nil]
	Receiver's instance variables: 
		bounds: 	(937.0@247.0) corner: (1154.0@265.0)
		owner: 	a MenuMorph(313262080)
		submorphs: 	#()
		fullBounds: 	(937.0@247.0) corner: (1154.0@265.0)
		color: 	Color black
		extension: 	a MorphExtension (487849984)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'Remove...'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ target removeCategories ]
		selector: 	#cull:
		arguments: 	an Array(a PackageTreeNautilusUI)
		icon: 	ColorForm(14x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'x, t'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1000@259) mouseUp 151369525 nil]
		aMorph: 	a ToggleMenuItemMorph(468713472)'Remove...'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1000@259) mouseUp 151369525 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1000@259) mouseUp 151369525 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	151369525
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1000@259)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1000@259) mouseUp 151369525 nil]
		aMorph: 	a ToggleMenuItemMorph(468713472)'Remove...'
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1000@259) mouseUp 151369525 nil]
		aMorph: 	a ToggleMenuItemMorph(468713472)'Remove...'
	Receiver's instance variables: 
		morph: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Array(SequenceableCollection)>>first
PackageTreeNautilusUI(AbstractTool)>>compileANewMethodInClass:categorized:from:notifyng:
PackageTreeNautilusUI(NautilusUI)>>compileAMethodFromCategory:withSource:notifying:
MethodDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
PluggableTextMorphWithLimits(PluggableTextMorph)>>promptForCancel
PluggableTextMorphWithLimits(PluggableTextMorph)>>update:
PackageTreeNautilusUI(AbstractNautilusUI)>>okToChange
PackageTreeNautilusUI(AbstractTool)>>removeCategory:inClass:
[ :item | 
| needToUpdate |
needToUpdate := self removeCategory: item inClass: class.
(needToUpdate and: [ removeACategory not ])
	ifTrue: [ removeACategory := true ].
needToUpdate
	ifTrue: [ self updateCategoryAndMethodList ] ] in [ :items | 
| removeACategory scroll |
scroll := categoryWidget vScrollValue.
removeACategory := false.
items
	do: [ :item | 
		| needToUpdate |
		needToUpdate := self removeCategory: item inClass: class.
		(needToUpdate and: [ removeACategory not ])
			ifTrue: [ removeACategory := true ].
		needToUpdate
			ifTrue: [ self updateCategoryAndMethodList ] ].
removeACategory
	ifTrue: [ self selectedCategory: nil ].
self updateCategoryAndMethodList.
categoryWidget vScrollValue: scroll ] in PackageTreeNautilusUI(NautilusUI)>>removeCategories
Array(SequenceableCollection)>>do:
[ :items | 
| removeACategory scroll |
scroll := categoryWidget vScrollValue.
removeACategory := false.
items
	do: [ :item | 
		| needToUpdate |
		needToUpdate := self removeCategory: item inClass: class.
		(needToUpdate and: [ removeACategory not ])
			ifTrue: [ removeACategory := true ].
		needToUpdate
			ifTrue: [ self updateCategoryAndMethodList ] ].
removeACategory
	ifTrue: [ self selectedCategory: nil ].
self updateCategoryAndMethodList.
categoryWidget vScrollValue: scroll ] in PackageTreeNautilusUI(NautilusUI)>>removeCategories
BlockClosure>>cull:
Array(Collection)>>ifNotEmpty:
PackageTreeNautilusUI(NautilusUI)>>removeCategories
[ target removeCategories ] in CategoryWidget class>>categoriesMenu:
BlockClosure>>cull:
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScope class>>outerScope
9 November 2015 12:23:56.514862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScope class(Object)>>doesNotUnderstand: #outerScope
	Receiver: MiniScope
	Arguments and temporary variables: 
		aMessage: 	outerScope
		exception: 	MessageNotUnderstood: MiniScope class>>outerScope
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bind:to:->MiniScope>>#bind:to: #bindingFor:->Mi...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#outerScope #bindings)
		organization: 	a ClassOrganization
		subclasses: 	{MiniVoidScope}
		name: 	#MiniScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil


MiniScope class>>newScopeIn:
	Receiver: MiniScope
	Arguments and temporary variables: 
		aName: 	a MiniScope
		aMiniScope: 	a MiniScope
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bind:to:->MiniScope>>#bind:to: #bindingFor:->Mi...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#outerScope #bindings)
		organization: 	a ClassOrganization
		subclasses: 	{MiniVoidScope}
		name: 	#MiniScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	nil
		scopeB: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542633
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542633
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542633
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542633
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542633
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542633
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(626@422) mouseUp 151501306 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(626@422) mouseUp 151501306 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(626@422) mouseUp 151501306 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(626@422) mouseUp 151501306 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	151501306
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(626@422)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(626@422) mouseUp 151501306 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(626@422) mouseUp 151501306 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(626@422) mouseUp 151501306 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(626@422) mouseUp 151501306 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(626@422) mouseUp 151501306 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	151501306
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(626@422)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(626@422) mouseUp 151501306 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(626@422) mouseUp 151501306 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(626@422) mouseUp 151501306 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(626@422) mouseUp 151501306 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(626@422) mouseUp 151501306 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
MiniScope class(Object)>>doesNotUnderstand: #outerScope
MiniScope class>>newScopeIn:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScope class>>outerScope
9 November 2015 12:23:57.515862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScope class(Object)>>doesNotUnderstand: #outerScope
	Receiver: MiniScope
	Arguments and temporary variables: 
		aMessage: 	outerScope
		exception: 	MessageNotUnderstood: MiniScope class>>outerScope
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bind:to:->MiniScope>>#bind:to: #bindingFor:->Mi...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#outerScope #bindings)
		organization: 	a ClassOrganization
		subclasses: 	{MiniVoidScope}
		name: 	#MiniScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil


MiniScope class>>newScopeIn:
	Receiver: MiniScope
	Arguments and temporary variables: 
		aName: 	a MiniScope
		aMiniScope: 	a MiniScope
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bind:to:->MiniScope>>#bind:to: #bindingFor:->Mi...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#outerScope #bindings)
		organization: 	a ClassOrganization
		subclasses: 	{MiniVoidScope}
		name: 	#MiniScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	nil
		scopeB: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542633
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542633
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542633
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542633
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542633
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542633
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(627@426) mouseUp 151502416 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(627@426) mouseUp 151502416 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(627@426) mouseUp 151502416 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(627@426) mouseUp 151502416 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	151502416
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(627@426)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(627@426) mouseUp 151502416 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(627@426) mouseUp 151502416 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(627@426) mouseUp 151502416 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	a WorldMorph(511705088) [world]


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(627@426) mouseUp 151502416 nil]
	Receiver's instance variables: 
		morph: 	a WorldMorph(511705088) [world]


MouseButtonEvent>>sentTo:
	Receiver: [(627@426) mouseUp 151502416 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	151502416
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(627@426)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(627@426) mouseUp 151502416 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	a WorldMorph(511705088) [world]


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(627@426) mouseUp 151502416 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	a WorldMorph(511705088) [world]


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(627@426) mouseUp 151502416 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(627@426) mouseUp 151502416 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(627@426) mouseUp 151502416 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
MiniScope class(Object)>>doesNotUnderstand: #outerScope
MiniScope class>>newScopeIn:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScope class>>outerScope:
9 November 2015 12:24:42.021862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScope class(Object)>>doesNotUnderstand: #outerScope:
	Receiver: MiniScope
	Arguments and temporary variables: 
		aMessage: 	outerScope: a MiniScope
		exception: 	MessageNotUnderstood: MiniScope class>>outerScope:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bind:to:->MiniScope>>#bind:to: #bindingFor:->Mi...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#outerScope #bindings)
		organization: 	a ClassOrganization
		subclasses: 	{MiniVoidScope}
		name: 	#MiniScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil


MiniScope class>>newScopeIn:
	Receiver: MiniScope
	Arguments and temporary variables: 
		aName: 	a MiniScope
		aMiniScope: 	a MiniScope
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bind:to:->MiniScope>>#bind:to: #bindingFor:->Mi...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#outerScope #bindings)
		organization: 	a ClassOrganization
		subclasses: 	{MiniVoidScope}
		name: 	#MiniScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	nil
		scopeB: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542679
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542679
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542679
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542679
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542679
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542679
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(610@432) mouseUp 151546916 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(610@432) mouseUp 151546916 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(610@432) mouseUp 151546916 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(610@432) mouseUp 151546916 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	151546916
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(610@432)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(610@432) mouseUp 151546916 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(610@432) mouseUp 151546916 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(610@432) mouseUp 151546916 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(610@432) mouseUp 151546916 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(610@432) mouseUp 151546916 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	151546916
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(610@432)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(610@432) mouseUp 151546916 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(610@432) mouseUp 151546916 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(610@432) mouseUp 151546916 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(610@432) mouseUp 151546916 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(610@432) mouseUp 151546916 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
MiniScope class(Object)>>doesNotUnderstand: #outerScope:
MiniScope class>>newScopeIn:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScope class>>outerScope:
9 November 2015 12:24:43.791862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScope class(Object)>>doesNotUnderstand: #outerScope:
	Receiver: MiniScope
	Arguments and temporary variables: 
		aMessage: 	outerScope: a MiniScope
		exception: 	MessageNotUnderstood: MiniScope class>>outerScope:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bind:to:->MiniScope>>#bind:to: #bindingFor:->Mi...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#outerScope #bindings)
		organization: 	a ClassOrganization
		subclasses: 	{MiniVoidScope}
		name: 	#MiniScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil


MiniScope class>>newScopeIn:
	Receiver: MiniScope
	Arguments and temporary variables: 
		aName: 	a MiniScope
		aMiniScope: 	a MiniScope
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bind:to:->MiniScope>>#bind:to: #bindingFor:->Mi...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#outerScope #bindings)
		organization: 	a ClassOrganization
		subclasses: 	{MiniVoidScope}
		name: 	#MiniScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	nil
		scopeB: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542679
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542679
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542679
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542679
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542679
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542679
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(607@432) mouseUp 151548697 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(607@432) mouseUp 151548697 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(607@432) mouseUp 151548697 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(607@432) mouseUp 151548697 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	151548697
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(607@432)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(607@432) mouseUp 151548697 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(607@432) mouseUp 151548697 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(607@432) mouseUp 151548697 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(607@432) mouseUp 151548697 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(607@432) mouseUp 151548697 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	151548697
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(607@432)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(607@432) mouseUp 151548697 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(607@432) mouseUp 151548697 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(607@432) mouseUp 151548697 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(607@432) mouseUp 151548697 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(607@432) mouseUp 151548697 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
MiniScope class(Object)>>doesNotUnderstand: #outerScope:
MiniScope class>>newScopeIn:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScope class>>outerScope:
9 November 2015 12:24:44.664862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScope class(Object)>>doesNotUnderstand: #outerScope:
	Receiver: MiniScope
	Arguments and temporary variables: 
		aMessage: 	outerScope: a MiniScope
		exception: 	MessageNotUnderstood: MiniScope class>>outerScope:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bind:to:->MiniScope>>#bind:to: #bindingFor:->Mi...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#outerScope #bindings)
		organization: 	a ClassOrganization
		subclasses: 	{MiniVoidScope}
		name: 	#MiniScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil


MiniScope class>>newScopeIn:
	Receiver: MiniScope
	Arguments and temporary variables: 
		aName: 	a MiniScope
		aMiniScope: 	a MiniScope
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bind:to:->MiniScope>>#bind:to: #bindingFor:->Mi...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#outerScope #bindings)
		organization: 	a ClassOrganization
		subclasses: 	{MiniVoidScope}
		name: 	#MiniScope
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mini-Environment-Impl'
		traitComposition: 	{}
		localSelectors: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	nil
		scopeB: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542679
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542679
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542679
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542679
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542679
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542679
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(607@432) mouseUp 151549556 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(607@432) mouseUp 151549556 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(607@432) mouseUp 151549556 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(607@432) mouseUp 151549556 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	151549556
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(607@432)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(607@432) mouseUp 151549556 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(607@432) mouseUp 151549556 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(607@432) mouseUp 151549556 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(607@432) mouseUp 151549556 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(607@432) mouseUp 151549556 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	151549556
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(607@432)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(607@432) mouseUp 151549556 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(607@432) mouseUp 151549556 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(607@432) mouseUp 151549556 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(607@432) mouseUp 151549556 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(607@432) mouseUp 151549556 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
MiniScope class(Object)>>doesNotUnderstand: #outerScope:
MiniScope class>>newScopeIn:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "includesKey:" is nil
9 November 2015 12:25:34.154862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #includesKey:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	includesKey: 'foo'
		exception: 	MessageNotUnderstood: receiver of "includesKey:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

MiniScope>>bind:to:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aName: 	'foo'
		aValue: 	3
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	a MiniScope
		scopeB: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542732
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542732
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542732
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542732
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542732
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542732
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(583@425) mouseUp 151599041 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(583@425) mouseUp 151599041 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(583@425) mouseUp 151599041 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(583@425) mouseUp 151599041 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	151599041
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(583@425)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(583@425) mouseUp 151599041 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(583@425) mouseUp 151599041 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(583@425) mouseUp 151599041 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(583@425) mouseUp 151599041 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(583@425) mouseUp 151599041 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	151599041
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(583@425)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(583@425) mouseUp 151599041 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(583@425) mouseUp 151599041 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(583@425) mouseUp 151599041 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(583@425) mouseUp 151599041 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(583@425) mouseUp 151599041 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #includesKey:
MiniScope>>bind:to:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "includesKey:" is nil
9 November 2015 12:25:35.520862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #includesKey:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	includesKey: 'foo'
		exception: 	MessageNotUnderstood: receiver of "includesKey:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

MiniScope>>bind:to:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aName: 	'foo'
		aValue: 	3
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	a MiniScope
		scopeB: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542732
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542732
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542732
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542732
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542732
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624542732
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(584@425) mouseUp 151600416 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(584@425) mouseUp 151600416 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(584@425) mouseUp 151600416 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(584@425) mouseUp 151600416 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	151600416
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(584@425)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(584@425) mouseUp 151600416 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(584@425) mouseUp 151600416 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(584@425) mouseUp 151600416 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(584@425) mouseUp 151600416 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(584@425) mouseUp 151600416 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	151600416
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(584@425)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(584@425) mouseUp 151600416 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(584@425) mouseUp 151600416 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(584@425) mouseUp 151600416 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(584@425) mouseUp 151600416 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(584@425) mouseUp 151600416 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@416.0) corner: (765.0@615.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(424@416) corner: (765@615)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #includesKey:
MiniScope>>bind:to:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "includesKey:" is nil
9 November 2015 12:30:12.481862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #includesKey:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	includesKey: 'foo'
		exception: 	MessageNotUnderstood: receiver of "includesKey:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

MiniScope>>DoItIn:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		ThisContext: 	MiniScope>>bind:to:
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'	(self bindings includesKey:aName) '
		itsSelection: 	a Text for '	(self bindings includesKey:aName) '
		itsSelectionString: 	'	(self bindings includesKey:aName) '
	Receiver's instance variables: 
		ast: 	DoItIn: ThisContext
	^ self bindings includesKey: (ThisContext namedTempAt...etc...
		source: 	a ReadStream
		context: 	MiniScope>>bind:to:
		receiver: 	a MiniScope
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	a MiniScope
		ctxt: 	MiniScope>>bind:to:
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>inspectIt
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>inspectIt:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


SmalltalkEditor(TextEditor)>>performCmdActionsWith:shifted:return:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		aBoolean: 	false
		return: 	[ :val | ^ val ]
		asciiValue: 	106
		actions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop: #...etc...
		action: 	#inspectIt:
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


SmalltalkEditor(TextEditor)>>dispatchCommandOn:return:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		return: 	[ :val | ^ val ]
		asciiValue: 	105
		honorCommandKeys: 	true
		char: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


SmalltalkEditor(TextEditor)>>dispatchOn:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		char: 	nil
		return: 	[ :val | ^ val ]
		keyEvents: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


[ self dispatchOn: aKeyboardEvent ] in SmalltalkEditor(TextEditor)>>keystroke:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


SmalltalkEditor(TextEditor)>>handleKeystrokeAction:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ self dispatchOn: aKeyboardEvent ]
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


SmalltalkEditor(TextEditor)>>handleEditionAction:fromKeyboardEvent:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		anAction: 	[ self dispatchOn: aKeyboardEvent ]
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


SmalltalkEditor(TextEditor)>>keystroke:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


[ editor keystroke: evt ] in TextMorphForEditView(TextMorph)>>basicKeyStroke:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
		action: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleInteraction:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		interactionBlock: 	[ editor keystroke: evt ]
		oldEditor: 	a SmalltalkEditor
		oldParagraph: 	a Paragraph
		oldText: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName)...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView>>handleInteraction:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		interActionBlock: 	[ editor keystroke: evt ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>basicKeyStroke:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
		action: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ self basicKeyStroke: evt ] in TextMorphForEditView(TextMorph)>>keyStroke:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


NECController class>>codeCompletionAround:textMorph:keyStroke:
	Receiver: NECController
	Arguments and temporary variables: 
		aBlock: 	[ self basicKeyStroke: evt ]
		aTextMorph: 	a TextMorphForEditView(514588672)
		evt: 	[keystroke '<Cmd-i>']
		editor: 	a SmalltalkEditor
		stringHolder: 	a MorphicTextAdapter
		completionAllowed: 	true
		controller: 	a NECController
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#additionals->NECController>>#additionals #captu...etc...
		format: 	142
		layout: 	a FixedLayout
		instanceVariables: 	#('model' 'menuMorph' 'editor' 'context' 'inverseMapping' 'c...etc...
		organization: 	a ClassOrganization
		subclasses: 	{NECWorkspaceController. NOCController}
		name: 	#NECController
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'NECompletion-View'
		traitComposition: 	{}
		localSelectors: 	nil
		uniqueInstance: 	a NECController


PharoCommonTools(ToolRegistry)>>codeCompletionAround:textMorph:keyStroke:
	Receiver: a PharoCommonTools
	Arguments and temporary variables: 
		aBlock: 	[ self basicKeyStroke: evt ]
		aTextMorph: 	a TextMorphForEditView(514588672)
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		tools: 	an IdentityDictionary(#basicInspector->EyeInspector #browser->PackageTre...etc...
		recentTools: 	a Dictionary(#basicInspector->a Set(EyeInspector) #browser->a Set(...etc...


TextMorphForEditView(TextMorph)>>keyStroke:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView>>keyStroke:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
		view: 	a PluggableTextMorph(633602048)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-i>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(514588672)
	Receiver's instance variables: 
		timeStamp: 	151877306
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(-20@62.0)
		handler: 	nil
		wasHandled: 	false
		keyValue: 	105
		charCode: 	105
		scanCode: 	73


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		focusHolder: 	a TextMorphForEditView(514588672)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(79@363.0) corner: (95@379.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(514588672)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(79@363) mouseOver nil nil]
		targetOffset: 	(291@62)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 151876916 79 363 0 0 0 1)
		lastKeyScanCode: 	73
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(723517440) a Nautilu...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Cmd-i>']
		focusHolder: 	a TextMorphForEditView(514588672)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(79@363.0) corner: (95@379.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(514588672)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(79@363) mouseOver nil nil]
		targetOffset: 	(291@62)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 151876916 79 363 0 0 0 1)
		lastKeyScanCode: 	73
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		focusHolder: 	a TextMorphForEditView(514588672)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(79@363.0) corner: (95@379.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(514588672)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(79@363) mouseOver nil nil]
		targetOffset: 	(291@62)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 151876916 79 363 0 0 0 1)
		lastKeyScanCode: 	73
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


HandMorph>>sendKeyboardEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(79@363.0) corner: (95@379.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(514588672)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(79@363) mouseOver nil nil]
		targetOffset: 	(291@62)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 151876916 79 363 0 0 0 1)
		lastKeyScanCode: 	73
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(79@363.0) corner: (95@379.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(514588672)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(79@363) mouseOver nil nil]
		targetOffset: 	(291@62)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 151876916 79 363 0 0 0 1)
		lastKeyScanCode: 	73
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
		evtBuf: 	#(2 151877306 105 0 8 105 0 1)
		type: 	2
		hadAny: 	true
	Receiver's instance variables: 
		bounds: 	(79@363.0) corner: (95@379.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(514588672)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(79@363) mouseOver nil nil]
		targetOffset: 	(291@62)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 151876916 79 363 0 0 0 1)
		lastKeyScanCode: 	73
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#onBlinkCursor -> a TextMorphForEditView(514588672...etc...
		lastStepTime: 	12188270
		lastStepMessage: 	nil
		lastCycleTime: 	12188268
		alarms: 	a Heap()
		lastAlarmTime: 	12188270
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#onBlinkCursor -> a TextMorphForEditView(514588672...etc...
		lastStepTime: 	12188270
		lastStepMessage: 	nil
		lastCycleTime: 	12188268
		alarms: 	a Heap()
		lastAlarmTime: 	12188270
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#onBlinkCursor -> a TextMorphForEditView(514588672...etc...
		lastStepTime: 	12188270
		lastStepMessage: 	nil
		lastCycleTime: 	12188268
		alarms: 	a Heap()
		lastAlarmTime: 	12188270
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#onBlinkCursor -> a TextMorphForEditView(514588672...etc...
		lastStepTime: 	12188270
		lastStepMessage: 	nil
		lastCycleTime: 	12188268
		alarms: 	a Heap()
		lastAlarmTime: 	12188270
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #includesKey:
MiniScope>>DoItIn:
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>inspectIt
SmalltalkEditor>>inspectIt:
SmalltalkEditor(TextEditor)>>performCmdActionsWith:shifted:return:
SmalltalkEditor(TextEditor)>>dispatchCommandOn:return:
SmalltalkEditor(TextEditor)>>dispatchOn:
[ self dispatchOn: aKeyboardEvent ] in SmalltalkEditor(TextEditor)>>keystroke:
SmalltalkEditor(TextEditor)>>handleKeystrokeAction:
SmalltalkEditor(TextEditor)>>handleEditionAction:fromKeyboardEvent:
SmalltalkEditor(TextEditor)>>keystroke:
[ editor keystroke: evt ] in TextMorphForEditView(TextMorph)>>basicKeyStroke:
TextMorphForEditView(TextMorph)>>handleInteraction:
TextMorphForEditView>>handleInteraction:
TextMorphForEditView(TextMorph)>>basicKeyStroke:
[ self basicKeyStroke: evt ] in TextMorphForEditView(TextMorph)>>keyStroke:
NECController class>>codeCompletionAround:textMorph:keyStroke:
PharoCommonTools(ToolRegistry)>>codeCompletionAround:textMorph:keyStroke:
TextMorphForEditView(TextMorph)>>keyStroke:
TextMorphForEditView>>keyStroke:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "includesKey:" is nil
9 November 2015 12:30:22.543862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #includesKey:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	includesKey: 'foo'
		exception: 	MessageNotUnderstood: receiver of "includesKey:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

MiniScope>>DoItIn:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		ThisContext: 	MiniScope>>bind:to:
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'(self bindings includesKey:aName)'
		itsSelection: 	a Text for '(self bindings includesKey:aName)'
		itsSelectionString: 	'(self bindings includesKey:aName)'
	Receiver's instance variables: 
		ast: 	DoItIn: ThisContext
	^ self bindings includesKey: (ThisContext namedTempAt...etc...
		source: 	a ReadStream
		context: 	MiniScope>>bind:to:
		receiver: 	a MiniScope
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	a MiniScope
		ctxt: 	MiniScope>>bind:to:
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>inspectIt
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>inspectIt:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


SmalltalkEditor(TextEditor)>>performCmdActionsWith:shifted:return:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		aBoolean: 	false
		return: 	[ :val | ^ val ]
		asciiValue: 	106
		actions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop: #...etc...
		action: 	#inspectIt:
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


SmalltalkEditor(TextEditor)>>dispatchCommandOn:return:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		return: 	[ :val | ^ val ]
		asciiValue: 	105
		honorCommandKeys: 	true
		char: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


SmalltalkEditor(TextEditor)>>dispatchOn:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		char: 	nil
		return: 	[ :val | ^ val ]
		keyEvents: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


[ self dispatchOn: aKeyboardEvent ] in SmalltalkEditor(TextEditor)>>keystroke:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


SmalltalkEditor(TextEditor)>>handleKeystrokeAction:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ self dispatchOn: aKeyboardEvent ]
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


SmalltalkEditor(TextEditor)>>handleEditionAction:fromKeyboardEvent:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		anAction: 	[ self dispatchOn: aKeyboardEvent ]
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


SmalltalkEditor(TextEditor)>>keystroke:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(514588672)
		selectionShowing: 	true
		model: 	a MorphicTextAdapter
		editingState: 	a SmalltalkEditingState


[ editor keystroke: evt ] in TextMorphForEditView(TextMorph)>>basicKeyStroke:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
		action: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleInteraction:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		interactionBlock: 	[ editor keystroke: evt ]
		oldEditor: 	a SmalltalkEditor
		oldParagraph: 	a Paragraph
		oldText: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName)...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView>>handleInteraction:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		interActionBlock: 	[ editor keystroke: evt ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>basicKeyStroke:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
		action: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ self basicKeyStroke: evt ] in TextMorphForEditView(TextMorph)>>keyStroke:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


NECController class>>codeCompletionAround:textMorph:keyStroke:
	Receiver: NECController
	Arguments and temporary variables: 
		aBlock: 	[ self basicKeyStroke: evt ]
		aTextMorph: 	a TextMorphForEditView(514588672)
		evt: 	[keystroke '<Cmd-i>']
		editor: 	a SmalltalkEditor
		stringHolder: 	a MorphicTextAdapter
		completionAllowed: 	true
		controller: 	a NECController
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#additionals->NECController>>#additionals #captu...etc...
		format: 	142
		layout: 	a FixedLayout
		instanceVariables: 	#('model' 'menuMorph' 'editor' 'context' 'inverseMapping' 'c...etc...
		organization: 	a ClassOrganization
		subclasses: 	{NECWorkspaceController. NOCController}
		name: 	#NECController
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'NECompletion-View'
		traitComposition: 	{}
		localSelectors: 	nil
		uniqueInstance: 	a NECController


PharoCommonTools(ToolRegistry)>>codeCompletionAround:textMorph:keyStroke:
	Receiver: a PharoCommonTools
	Arguments and temporary variables: 
		aBlock: 	[ self basicKeyStroke: evt ]
		aTextMorph: 	a TextMorphForEditView(514588672)
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		tools: 	an IdentityDictionary(#basicInspector->EyeInspector #browser->PackageTre...etc...
		recentTools: 	a Dictionary(#basicInspector->a Set(EyeInspector) #browser->a Set(...etc...


TextMorphForEditView(TextMorph)>>keyStroke:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView>>keyStroke:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
		view: 	a PluggableTextMorph(633602048)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-i>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(514588672)
	Receiver's instance variables: 
		timeStamp: 	151887369
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(279@58.0)
		handler: 	nil
		wasHandled: 	false
		keyValue: 	105
		charCode: 	105
		scanCode: 	73


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(514588672)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (882@116)
		owner: 	a TransformMorph(51380224)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (882@116)
		color: 	Color black
		extension: 	a MorphExtension (566493184) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'bind: aName
to: aValue

	(self bindings includesKey:aName) 
	...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(633602048)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		focusHolder: 	a TextMorphForEditView(514588672)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(370@350.0) corner: (386@366.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(370@350.0) corner: (386@366.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(514588672)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(378@359) mouseOver nil nil]
		targetOffset: 	(27@72)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 151886884 378 359 0 0 0 1)
		lastKeyScanCode: 	73
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(723517440) a Nautilu...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Cmd-i>']
		focusHolder: 	a TextMorphForEditView(514588672)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(370@350.0) corner: (386@366.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(370@350.0) corner: (386@366.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(514588672)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(378@359) mouseOver nil nil]
		targetOffset: 	(27@72)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 151886884 378 359 0 0 0 1)
		lastKeyScanCode: 	73
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		focusHolder: 	a TextMorphForEditView(514588672)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(370@350.0) corner: (386@366.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(370@350.0) corner: (386@366.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(514588672)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(378@359) mouseOver nil nil]
		targetOffset: 	(27@72)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 151886884 378 359 0 0 0 1)
		lastKeyScanCode: 	73
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


HandMorph>>sendKeyboardEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(370@350.0) corner: (386@366.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(370@350.0) corner: (386@366.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(514588672)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(378@359) mouseOver nil nil]
		targetOffset: 	(27@72)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 151886884 378 359 0 0 0 1)
		lastKeyScanCode: 	73
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(370@350.0) corner: (386@366.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(370@350.0) corner: (386@366.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(514588672)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(378@359) mouseOver nil nil]
		targetOffset: 	(27@72)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 151886884 378 359 0 0 0 1)
		lastKeyScanCode: 	73
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
		evtBuf: 	#(2 151887369 105 0 8 105 0 1)
		type: 	2
		hadAny: 	true
	Receiver's instance variables: 
		bounds: 	(370@350.0) corner: (386@366.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(370@350.0) corner: (386@366.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(514588672)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(378@359) mouseOver nil nil]
		targetOffset: 	(27@72)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 151886884 378 359 0 0 0 1)
		lastKeyScanCode: 	73
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(481820672))(a DropList...etc...
		lastStepTime: 	12198337
		lastStepMessage: 	nil
		lastCycleTime: 	12198337
		alarms: 	a Heap()
		lastAlarmTime: 	12198337
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(481820672))(a DropList...etc...
		lastStepTime: 	12198337
		lastStepMessage: 	nil
		lastCycleTime: 	12198337
		alarms: 	a Heap()
		lastAlarmTime: 	12198337
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(481820672))(a DropList...etc...
		lastStepTime: 	12198337
		lastStepMessage: 	nil
		lastCycleTime: 	12198337
		alarms: 	a Heap()
		lastAlarmTime: 	12198337
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(481820672))(a DropList...etc...
		lastStepTime: 	12198337
		lastStepMessage: 	nil
		lastCycleTime: 	12198337
		alarms: 	a Heap()
		lastAlarmTime: 	12198337
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #includesKey:
MiniScope>>DoItIn:
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>inspectIt
SmalltalkEditor>>inspectIt:
SmalltalkEditor(TextEditor)>>performCmdActionsWith:shifted:return:
SmalltalkEditor(TextEditor)>>dispatchCommandOn:return:
SmalltalkEditor(TextEditor)>>dispatchOn:
[ self dispatchOn: aKeyboardEvent ] in SmalltalkEditor(TextEditor)>>keystroke:
SmalltalkEditor(TextEditor)>>handleKeystrokeAction:
SmalltalkEditor(TextEditor)>>handleEditionAction:fromKeyboardEvent:
SmalltalkEditor(TextEditor)>>keystroke:
[ editor keystroke: evt ] in TextMorphForEditView(TextMorph)>>basicKeyStroke:
TextMorphForEditView(TextMorph)>>handleInteraction:
TextMorphForEditView>>handleInteraction:
TextMorphForEditView(TextMorph)>>basicKeyStroke:
[ self basicKeyStroke: evt ] in TextMorphForEditView(TextMorph)>>keyStroke:
NECController class>>codeCompletionAround:textMorph:keyStroke:
PharoCommonTools(ToolRegistry)>>codeCompletionAround:textMorph:keyStroke:
TextMorphForEditView(TextMorph)>>keyStroke:
TextMorphForEditView>>keyStroke:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
9 November 2015 12:33:39.581862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScopeTestCase(TestAsserter)>>assert:
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	a MiniScope
		scopeB: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		failedSelected: 	MiniScopeTestCase>>#testNestedScope
		errorList: 	an Array(MiniScopeTestCase>>#testRebind)
		errorSelected: 	nil
		lastUpdate: 	3624543217
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 1 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		failedSelected: 	MiniScopeTestCase>>#testNestedScope
		errorList: 	an Array(MiniScopeTestCase>>#testRebind)
		errorSelected: 	nil
		lastUpdate: 	3624543217
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		failedSelected: 	MiniScopeTestCase>>#testNestedScope
		errorList: 	an Array(MiniScopeTestCase>>#testRebind)
		errorSelected: 	nil
		lastUpdate: 	3624543217
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		failedSelected: 	MiniScopeTestCase>>#testNestedScope
		errorList: 	an Array(MiniScopeTestCase>>#testRebind)
		errorSelected: 	nil
		lastUpdate: 	3624543217
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		failedSelected: 	MiniScopeTestCase>>#testNestedScope
		errorList: 	an Array(MiniScopeTestCase>>#testRebind)
		errorSelected: 	nil
		lastUpdate: 	3624543217
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		failedSelected: 	MiniScopeTestCase>>#testNestedScope
		errorList: 	an Array(MiniScopeTestCase>>#testRebind)
		errorSelected: 	nil
		lastUpdate: 	3624543217
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@244.0) corner: (765.0@412.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(424@244) corner: (765@412)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		event: 	[(608@249) mouseUp 152084478 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(424.0@244.0) corner: (765.0@412.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(424@244) corner: (765@412)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		evt: 	[(608@249) mouseUp 152084478 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@244.0) corner: (765.0@412.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(424@244) corner: (765@412)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(608@249) mouseUp 152084478 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(424.0@244.0) corner: (765.0@412.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(424@244) corner: (765@412)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(608@249) mouseUp 152084478 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(223084544)
	Receiver's instance variables: 
		timeStamp: 	152084478
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(608@249)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(608@249) mouseUp 152084478 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@244.0) corner: (765.0@412.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(424@244) corner: (765@412)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(608@249) mouseUp 152084478 nil]
		aMorph: 	a PluggableListMorph(223084544)
		localEvt: 	[(608@249) mouseUp 152084478 nil]
		index: 	2
		child: 	a TransformMorph(144965632)
		morphs: 	an Array(a TransformMorph(144965632))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(608@249) mouseUp 152084478 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(608@249) mouseUp 152084478 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	152084478
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(608@249)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(608@249) mouseUp 152084478 nil]
		aMorph: 	a PluggableListMorph(223084544)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(608@249) mouseUp 152084478 nil]
		aMorph: 	a PluggableListMorph(223084544)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(608@249) mouseUp 152084478 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@244.0) corner: (765.0@412.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(424@244) corner: (765@412)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(608@249) mouseUp 152084478 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@244.0) corner: (765.0@412.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(424@244) corner: (765@412)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(608@249) mouseUp 152084478 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@244.0) corner: (765.0@412.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(424@244) corner: (765@412)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(608@249) mouseUp 152084478 nil]
		focusHolder: 	a PluggableListMorph(223084544)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(608@249.0) corner: (624@265.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(608@249.0) corner: (624@265.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(223084544)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(608@249) mouseOver nil nil]
		targetOffset: 	(184.0@4.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 152084478 608 249 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScopeTestCase(TestAsserter)>>assert:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
9 November 2015 12:33:53.645862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScopeTestCase(TestAsserter)>>assert:
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	a MiniScope
		scopeB: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		failedSelected: 	MiniScopeTestCase>>#testNestedScope
		errorList: 	an Array(MiniScopeTestCase>>#testRebind)
		errorSelected: 	nil
		lastUpdate: 	3624543217
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 1 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		failedSelected: 	MiniScopeTestCase>>#testNestedScope
		errorList: 	an Array(MiniScopeTestCase>>#testRebind)
		errorSelected: 	nil
		lastUpdate: 	3624543217
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		failedSelected: 	MiniScopeTestCase>>#testNestedScope
		errorList: 	an Array(MiniScopeTestCase>>#testRebind)
		errorSelected: 	nil
		lastUpdate: 	3624543217
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		failedSelected: 	MiniScopeTestCase>>#testNestedScope
		errorList: 	an Array(MiniScopeTestCase>>#testRebind)
		errorSelected: 	nil
		lastUpdate: 	3624543217
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		failedSelected: 	MiniScopeTestCase>>#testNestedScope
		errorList: 	an Array(MiniScopeTestCase>>#testRebind)
		errorSelected: 	nil
		lastUpdate: 	3624543217
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		failedSelected: 	MiniScopeTestCase>>#testNestedScope
		errorList: 	an Array(MiniScopeTestCase>>#testRebind)
		errorSelected: 	nil
		lastUpdate: 	3624543217
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(418.0@224.0) corner: (759.0@392.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(418.0@224.0) corner: (759.0@392.0)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		event: 	[(557@235) mouseUp 152098541 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(418.0@224.0) corner: (759.0@392.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(418.0@224.0) corner: (759.0@392.0)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		evt: 	[(557@235) mouseUp 152098541 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@224.0) corner: (759.0@392.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(418.0@224.0) corner: (759.0@392.0)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(557@235) mouseUp 152098541 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(418.0@224.0) corner: (759.0@392.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(418.0@224.0) corner: (759.0@392.0)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(557@235) mouseUp 152098541 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(223084544)
	Receiver's instance variables: 
		timeStamp: 	152098541
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(557@235)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(557@235) mouseUp 152098541 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@224.0) corner: (759.0@392.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(418.0@224.0) corner: (759.0@392.0)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(557@235) mouseUp 152098541 nil]
		aMorph: 	a PluggableListMorph(223084544)
		localEvt: 	[(557@235) mouseUp 152098541 nil]
		index: 	2
		child: 	a TransformMorph(144965632)
		morphs: 	an Array(a TransformMorph(144965632))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(557@235) mouseUp 152098541 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(557@235) mouseUp 152098541 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	152098541
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(557@235)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(557@235) mouseUp 152098541 nil]
		aMorph: 	a PluggableListMorph(223084544)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(557@235) mouseUp 152098541 nil]
		aMorph: 	a PluggableListMorph(223084544)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(557@235) mouseUp 152098541 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(418.0@224.0) corner: (759.0@392.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(418.0@224.0) corner: (759.0@392.0)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(557@235) mouseUp 152098541 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@224.0) corner: (759.0@392.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(418.0@224.0) corner: (759.0@392.0)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(557@235) mouseUp 152098541 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@224.0) corner: (759.0@392.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(418.0@224.0) corner: (759.0@392.0)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(557@235) mouseUp 152098541 nil]
		focusHolder: 	a PluggableListMorph(223084544)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(557@235.0) corner: (573@251.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(557@235.0) corner: (573@251.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(223084544)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(557@235) mouseOver nil nil]
		targetOffset: 	(139.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 152098541 557 235 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScopeTestCase(TestAsserter)>>assert:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MiniUndeclaredError: No bindings in the void scope.
9 November 2015 12:41:12.607862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScope>>bindingFor:
	Receiver: a MiniVoidScope
	Arguments and temporary variables: 
		aName: 	'foo'
	Receiver's instance variables: 
		outerScope: 	a MiniScope
		bindings: 	a Dictionary()


MiniScope>>bindingFor:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aName: 	'foo'
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary('baz'->5 'snark'->'hope' )


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	a MiniScope
		scopeB: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543670
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543670
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543670
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543670
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543670
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543670
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(619@406) mouseUp 152537384 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(619@406) mouseUp 152537384 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(619@406) mouseUp 152537384 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(619@406) mouseUp 152537384 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	152537384
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(619@406)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(619@406) mouseUp 152537384 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(619@406) mouseUp 152537384 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(619@406) mouseUp 152537384 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(619@406) mouseUp 152537384 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(619@406) mouseUp 152537384 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	152537384
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(619@406)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(619@406) mouseUp 152537384 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(619@406) mouseUp 152537384 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(619@406) mouseUp 152537384 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(619@406) mouseUp 152537384 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(619@406) mouseUp 152537384 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
MiniVoidScope>>bindingFor:
MiniScope>>bindingFor:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MiniMultipleDeclarationError: Cannot declare multiple bindings of the same name
9 November 2015 12:42:52.592862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScope>>bind:to:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aName: 	'foo'
		aValue: 	3
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary('foo'->3 'snark'->'boojum' )


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	a MiniScope
		scopeB: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543770
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543770
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543770
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543770
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543770
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543770
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(500@405) mouseUp 152637463 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(500@405) mouseUp 152637463 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(500@405) mouseUp 152637463 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(500@405) mouseUp 152637463 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	152637463
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(500@405)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(500@405) mouseUp 152637463 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(500@405) mouseUp 152637463 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(500@405) mouseUp 152637463 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(500@405) mouseUp 152637463 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(500@405) mouseUp 152637463 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	152637463
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(500@405)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(500@405) mouseUp 152637463 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(500@405) mouseUp 152637463 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(500@405) mouseUp 152637463 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(500@405) mouseUp 152637463 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(500@405) mouseUp 152637463 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(500@405) mouseUp 152637463 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(500@405.0) corner: (516@421.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(500@405.0) corner: (516@421.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(500@405) mouseOver nil nil]
		targetOffset: 	(81.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 152637463 500 405 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScope>>bind:to:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MiniMultipleDeclarationError: Cannot declare multiple bindings of the same name
9 November 2015 12:42:54.321862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScope>>bind:to:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aName: 	'foo'
		aValue: 	3
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary('foo'->3 'snark'->'boojum' )


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	a MiniScope
		scopeB: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543770
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543770
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543770
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543770
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543770
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543770
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(504@401) mouseUp 152639213 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(504@401) mouseUp 152639213 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(504@401) mouseUp 152639213 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(504@401) mouseUp 152639213 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	152639213
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(504@401)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(504@401) mouseUp 152639213 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(504@401) mouseUp 152639213 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(504@401) mouseUp 152639213 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(504@401) mouseUp 152639213 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(504@401) mouseUp 152639213 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	152639213
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(504@401)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(504@401) mouseUp 152639213 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(504@401) mouseUp 152639213 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(504@401) mouseUp 152639213 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(504@401) mouseUp 152639213 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(504@401) mouseUp 152639213 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(504@401) mouseUp 152639213 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(504@401.0) corner: (520@417.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(504@401.0) corner: (520@417.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(504@401) mouseOver nil nil]
		targetOffset: 	(86.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 152639213 504 401 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScope>>bind:to:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScopeTestCase>>accept:
9 November 2015 12:43:19.711862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScopeTestCase(Object)>>doesNotUnderstand: #accept:
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		aMessage: 	accept: true
		exception: 	MessageNotUnderstood: MiniScopeTestCase>>accept:
		resumeValue: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	a MiniScope
		scopeB: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543797
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543797
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543797
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543797
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543797
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543797
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(604@410) mouseUp 152664603 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(604@410) mouseUp 152664603 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(604@410) mouseUp 152664603 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(604@410) mouseUp 152664603 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	152664603
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(604@410)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(604@410) mouseUp 152664603 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(604@410) mouseUp 152664603 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(604@410) mouseUp 152664603 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(604@410) mouseUp 152664603 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(604@410) mouseUp 152664603 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	152664603
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(604@410)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(604@410) mouseUp 152664603 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(604@410) mouseUp 152664603 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(604@410) mouseUp 152664603 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(604@410) mouseUp 152664603 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(604@410) mouseUp 152664603 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(604@410) mouseUp 152664603 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(604@410.0) corner: (620@426.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(604@410.0) corner: (620@426.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	a PluggableListMorph(657719296)
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickDown]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(604@410) mouseOver red nil nil]
		targetOffset: 	(186.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 152664650 604 410 4 0 2 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScopeTestCase(Object)>>doesNotUnderstand: #accept:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScopeTestCase>>accept:
9 November 2015 12:45:16.342862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScopeTestCase(Object)>>doesNotUnderstand: #accept:
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		aMessage: 	accept: true
		exception: 	MessageNotUnderstood: MiniScopeTestCase>>accept:
		resumeValue: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	a MiniScope
		scopeB: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543914
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543914
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543914
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543914
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543914
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543914
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(665@413) mouseUp 152781228 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(665@413) mouseUp 152781228 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(665@413) mouseUp 152781228 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(665@413) mouseUp 152781228 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	152781228
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(665@413)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(665@413) mouseUp 152781228 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(665@413) mouseUp 152781228 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(665@413) mouseUp 152781228 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(665@413) mouseUp 152781228 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(665@413) mouseUp 152781228 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	152781228
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(665@413)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(665@413) mouseUp 152781228 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(665@413) mouseUp 152781228 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(665@413) mouseUp 152781228 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(665@413) mouseUp 152781228 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(665@413) mouseUp 152781228 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(665@413) mouseUp 152781228 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(665@413.0) corner: (681@429.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(665@413.0) corner: (681@429.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(665@413) mouseOver nil nil]
		targetOffset: 	(247.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 152781228 665 413 0 0 1 1)
		lastKeyScanCode: 	88
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScopeTestCase(Object)>>doesNotUnderstand: #accept:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScopeTestCase>>accept:
9 November 2015 12:45:17.462862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScopeTestCase(Object)>>doesNotUnderstand: #accept:
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		aMessage: 	accept: true
		exception: 	MessageNotUnderstood: MiniScopeTestCase>>accept:
		resumeValue: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	a MiniScope
		scopeB: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543914
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543914
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543914
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543914
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543914
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543914
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(663@406) mouseUp 152782353 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(663@406) mouseUp 152782353 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(663@406) mouseUp 152782353 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(663@406) mouseUp 152782353 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	152782353
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(663@406)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(663@406) mouseUp 152782353 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(663@406) mouseUp 152782353 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(663@406) mouseUp 152782353 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(663@406) mouseUp 152782353 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(663@406) mouseUp 152782353 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	152782353
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(663@406)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(663@406) mouseUp 152782353 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(663@406) mouseUp 152782353 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(663@406) mouseUp 152782353 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(663@406) mouseUp 152782353 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(663@406) mouseUp 152782353 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(663@406) mouseUp 152782353 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(663@406.0) corner: (679@422.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(663@406.0) corner: (679@422.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(663@406) mouseOver nil nil]
		targetOffset: 	(245.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 152782353 663 406 0 0 1 1)
		lastKeyScanCode: 	88
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScopeTestCase(Object)>>doesNotUnderstand: #accept:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScopeTestCase>>accept:
9 November 2015 12:45:18.616862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScopeTestCase(Object)>>doesNotUnderstand: #accept:
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		aMessage: 	accept: true
		exception: 	MessageNotUnderstood: MiniScopeTestCase>>accept:
		resumeValue: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	a MiniScope
		scopeB: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543914
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543914
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543914
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543914
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543914
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624543914
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(657@399) mouseUp 152783525 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(657@399) mouseUp 152783525 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(657@399) mouseUp 152783525 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(657@399) mouseUp 152783525 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	152783525
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(657@399)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(657@399) mouseUp 152783525 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(657@399) mouseUp 152783525 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(657@399) mouseUp 152783525 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(657@399) mouseUp 152783525 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(657@399) mouseUp 152783525 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	152783525
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(657@399)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(657@399) mouseUp 152783525 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(657@399) mouseUp 152783525 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(657@399) mouseUp 152783525 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(657@399) mouseUp 152783525 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(657@399) mouseUp 152783525 nil]
	Receiver's instance variables: 
		bounds: 	(418.0@396.0) corner: (759.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(418@396) corner: (759@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(657@399) mouseUp 152783525 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(657@399.0) corner: (673@415.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(657@399.0) corner: (673@415.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(657@399) mouseOver nil nil]
		targetOffset: 	(239.0@3.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 152783525 657 399 0 0 1 1)
		lastKeyScanCode: 	88
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScopeTestCase(Object)>>doesNotUnderstand: #accept:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScopeTestCase>>accept:
9 November 2015 1:56:40.995862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScopeTestCase(Object)>>doesNotUnderstand: #accept:
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		aMessage: 	accept: false
		exception: 	MessageNotUnderstood: MiniScopeTestCase>>accept:
		resumeValue: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	a MiniScope
		scopeB: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624548186
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624548186
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624548186
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624548186
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624548186
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope MiniScopeTestCase>>#tes...etc...
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624548186
		result: 	3 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396.0) corner: (760@595.0)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(564@408) mouseUp 157065728 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396.0) corner: (760@595.0)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(564@408) mouseUp 157065728 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396.0) corner: (760@595.0)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(564@408) mouseUp 157065728 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396.0) corner: (760@595.0)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(564@408) mouseUp 157065728 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	157065728
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(564@408)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(564@408) mouseUp 157065728 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396.0) corner: (760@595.0)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(564@408) mouseUp 157065728 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(564@408) mouseUp 157065728 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(564@408) mouseUp 157065728 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(564@408) mouseUp 157065728 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	157065728
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(564@408)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(564@408) mouseUp 157065728 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(564@408) mouseUp 157065728 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(564@408) mouseUp 157065728 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396.0) corner: (760@595.0)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(564@408) mouseUp 157065728 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396.0) corner: (760@595.0)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(564@408) mouseUp 157065728 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396.0) corner: (760@595.0)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope' 'MiniScopeTestCase>>#testRebind')...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(564@408) mouseUp 157065728 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(565@408.0) corner: (581@424.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(565@408.0) corner: (581@424.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	a PluggableListMorph(657719296)
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickDown]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(565@408) mouseOver red nil nil]
		targetOffset: 	(146.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 157065791 565 408 4 0 2 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScopeTestCase(Object)>>doesNotUnderstand: #accept:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScopeTestCase>>accept:
9 November 2015 1:58:34.385862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScopeTestCase(Object)>>doesNotUnderstand: #accept:
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		aMessage: 	accept: true
		exception: 	MessageNotUnderstood: MiniScopeTestCase>>accept:
		resumeValue: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	a MiniScope
		scopeB: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624548305
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624548305
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624548305
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624548305
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624548305
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624548305
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(539@403) mouseUp 157179181 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(539@403) mouseUp 157179181 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(539@403) mouseUp 157179181 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(539@403) mouseUp 157179181 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	157179181
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(539@403)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(539@403) mouseUp 157179181 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(539@403) mouseUp 157179181 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(539@403) mouseUp 157179181 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(539@403) mouseUp 157179181 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(539@403) mouseUp 157179181 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	157179181
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(539@403)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(539@403) mouseUp 157179181 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(539@403) mouseUp 157179181 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(539@403) mouseUp 157179181 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(539@403) mouseUp 157179181 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(539@403) mouseUp 157179181 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(539@403) mouseUp 157179181 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(539@418.0) corner: (555@434.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(539@418.0) corner: (555@434.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@418) mouseOver nil nil]
		targetOffset: 	(120.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 157179384 539 424 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScopeTestCase(Object)>>doesNotUnderstand: #accept:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScopeTestCase>>accept:
9 November 2015 2:01:27.097862 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScopeTestCase(Object)>>doesNotUnderstand: #accept:
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		aMessage: 	accept: true
		exception: 	MessageNotUnderstood: MiniScopeTestCase>>accept:
		resumeValue: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	a MiniScope
		scopeB: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624548484
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624548484
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624548484
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624548484
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624548484
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	2
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624548484
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(624@408) mouseUp 157351884 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(624@408) mouseUp 157351884 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(624@408) mouseUp 157351884 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(624@408) mouseUp 157351884 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	157351884
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(624@408)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(624@408) mouseUp 157351884 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(624@408) mouseUp 157351884 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(624@408) mouseUp 157351884 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(624@408) mouseUp 157351884 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(624@408) mouseUp 157351884 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	157351884
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(624@408)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(624@408) mouseUp 157351884 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(624@408) mouseUp 157351884 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(624@408) mouseUp 157351884 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(624@408) mouseUp 157351884 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(624@408) mouseUp 157351884 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(624@408) mouseUp 157351884 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(625@408.0) corner: (641@424.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(625@408.0) corner: (641@424.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(625@408) mouseOver nil nil]
		targetOffset: 	(204.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 157352197 625 408 0 0 0 1)
		lastKeyScanCode: 	73
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScopeTestCase(Object)>>doesNotUnderstand: #accept:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScopeTestCase>>accept:
11 November 2015 12:03:05.010928 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScopeTestCase(Object)>>doesNotUnderstand: #accept:
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		aMessage: 	accept: true
		exception: 	MessageNotUnderstood: MiniScopeTestCase>>accept:
		resumeValue: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	a MiniScope
		scopeB: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624714182
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624714182
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624714182
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624714182
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624714182
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624714182
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(564@401) mouseUp 150071687 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(564@401) mouseUp 150071687 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150071687 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(564@401) mouseUp 150071687 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	150071687
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(564@401)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150071687 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150071687 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(564@401) mouseUp 150071687 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150071687 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(564@401) mouseUp 150071687 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	150071687
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(564@401)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150071687 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150071687 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150071687 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150071687 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150071687 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150071687 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(564@401.0) corner: (580@417.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(564@401.0) corner: (580@417.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(564@401) mouseOver nil nil]
		targetOffset: 	(145.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 150071187 564 401 0 0 0 1)
		lastKeyScanCode: 	216
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScopeTestCase(Object)>>doesNotUnderstand: #accept:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniScopeTestCase>>accept:
11 November 2015 12:03:06.223928 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniScopeTestCase(Object)>>doesNotUnderstand: #accept:
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		aMessage: 	accept: true
		exception: 	MessageNotUnderstood: MiniScopeTestCase>>accept:
		resumeValue: 	nil
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase>>testNestedScope
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 
		globalScope: 	a MiniScope
		scopeA: 	a MiniScope
		scopeB: 	a MiniScope
	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


MiniScopeTestCase(TestCase)>>performTest
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniScopeTestCase(TestCase)>>runCase
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniScopeTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniScopeTestCase(TestCase)>>debug
	Receiver: MiniScopeTestCase>>#testNestedScope
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testNestedScope
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniScopeTestCase>>#testNestedScope nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniScopeTestCase>>#testNestedScope)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624714182
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624714182
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624714182
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624714182
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniScopeTestCase>>#testNestedScope
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624714182
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniScopeTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniScopeTestCase>>#testNestedScope)
		errorSelected: 	MiniScopeTestCase>>#testNestedScope
		lastUpdate: 	3624714182
		result: 	3 run, 2 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(564@401) mouseUp 150073015 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(564@401) mouseUp 150073015 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150073015 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(564@401) mouseUp 150073015 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	150073015
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(564@401)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150073015 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150073015 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(564@401) mouseUp 150073015 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150073015 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(564@401) mouseUp 150073015 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	150073015
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(564@401)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150073015 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150073015 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150073015 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150073015 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150073015 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniScopeTestCase>>#testNestedScope')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(564@401) mouseUp 150073015 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(564@401.0) corner: (580@417.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(564@401.0) corner: (580@417.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(564@401) mouseUp 150073015 nil]
		targetOffset: 	(145.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 150073015 564 401 0 0 1 1)
		lastKeyScanCode: 	216
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniScopeTestCase(Object)>>doesNotUnderstand: #accept:
MiniScopeTestCase>>testNestedScope
MiniScopeTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniScopeTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniScopeTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniScopeTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "new" is nil
11 November 2015 12:06:09.571928 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	new
		exception: 	MessageNotUnderstood: receiver of "new" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

MiniEnvironmentTestCase>>setUp
	Receiver: MiniEnvironmentTestCase>>#testDistinctEnvironments
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDistinctEnvironments
		expectedFails: 	nil
		anEnv: 	nil


[ 
self setUp.
self performTest ] in MiniEnvironmentTestCase(TestCase)>>runCase
	Receiver: MiniEnvironmentTestCase>>#testDistinctEnvironments
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDistinctEnvironments
		expectedFails: 	nil
		anEnv: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniEnvironmentTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniEnvironmentTestCase(TestCase)>>runCase
	Receiver: MiniEnvironmentTestCase>>#testDistinctEnvironments
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDistinctEnvironments
		expectedFails: 	nil
		anEnv: 	nil


[ (self class selector: testSelector) runCase ] in MiniEnvironmentTestCase(TestCase)>>debug
	Receiver: MiniEnvironmentTestCase>>#testDistinctEnvironments
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDistinctEnvironments
		expectedFails: 	#()
		anEnv: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniEnvironmentTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniEnvironmentTestCase(TestCase)>>debug
	Receiver: MiniEnvironmentTestCase>>#testDistinctEnvironments
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDistinctEnvironments
		expectedFails: 	#()
		anEnv: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniEnvironmentTestCase>>#testDistinctEnvironments)...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniEnvironmentTestCase>>#testDistinctEnvironments)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments nil nil nil ...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniEnvironmentTestCase>>#testDistinctEnvironments)...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniEnvironmentTestCase>>#testDistinctEnvironments)...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnvi...etc...
		errorSelected: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
		lastUpdate: 	3624714368
		result: 	4 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 4 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	4 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 4 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnvi...etc...
		errorSelected: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
		lastUpdate: 	3624714368
		result: 	4 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 4 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnvi...etc...
		errorSelected: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
		lastUpdate: 	3624714368
		result: 	4 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 4 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnvi...etc...
		errorSelected: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
		lastUpdate: 	3624714368
		result: 	4 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 4 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnvi...etc...
		errorSelected: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
		lastUpdate: 	3624714368
		result: 	4 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 4 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnvi...etc...
		errorSelected: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
		lastUpdate: 	3624714368
		result: 	4 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 4 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(585@412) mouseUp 150256375 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(585@412) mouseUp 150256375 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(585@412) mouseUp 150256375 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(585@412) mouseUp 150256375 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	150256375
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(585@412)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(585@412) mouseUp 150256375 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(585@412) mouseUp 150256375 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(585@412) mouseUp 150256375 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(585@412) mouseUp 150256375 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(585@412) mouseUp 150256375 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	150256375
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(585@412)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(585@412) mouseUp 150256375 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(585@412) mouseUp 150256375 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(585@412) mouseUp 150256375 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(585@412) mouseUp 150256375 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(585@412) mouseUp 150256375 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(585@412) mouseUp 150256375 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(585@412.0) corner: (601@428.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(585@412.0) corner: (601@428.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(585@412) mouseUp 150256375 nil]
		targetOffset: 	(166.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 150256375 585 412 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #new
MiniEnvironmentTestCase>>setUp
[ 
self setUp.
self performTest ] in MiniEnvironmentTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniEnvironmentTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniEnvironmentTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniEnvironmentTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniEnvironment>>addVariable:value:
11 November 2015 12:07:49.051928 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniEnvironment(Object)>>doesNotUnderstand: #addVariable:value:
	Receiver: a MiniEnvironment
	Arguments and temporary variables: 
		aMessage: 	addVariable: 'foo' value: 9
		exception: 	MessageNotUnderstood: MiniEnvironment>>addVariable:value:
		resumeValue: 	nil
	Receiver's instance variables: 
a MiniEnvironment

MiniEnvironmentTestCase>>testDistinctEnvironments
	Receiver: MiniEnvironmentTestCase>>#testDistinctEnvironments
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDistinctEnvironments
		expectedFails: 	nil
		anEnv: 	a MiniEnvironment


MiniEnvironmentTestCase(TestCase)>>performTest
	Receiver: MiniEnvironmentTestCase>>#testDistinctEnvironments
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDistinctEnvironments
		expectedFails: 	nil
		anEnv: 	a MiniEnvironment


[ 
self setUp.
self performTest ] in MiniEnvironmentTestCase(TestCase)>>runCase
	Receiver: MiniEnvironmentTestCase>>#testDistinctEnvironments
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDistinctEnvironments
		expectedFails: 	nil
		anEnv: 	a MiniEnvironment


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniEnvironmentTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniEnvironmentTestCase(TestCase)>>runCase
	Receiver: MiniEnvironmentTestCase>>#testDistinctEnvironments
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDistinctEnvironments
		expectedFails: 	nil
		anEnv: 	a MiniEnvironment


[ (self class selector: testSelector) runCase ] in MiniEnvironmentTestCase(TestCase)>>debug
	Receiver: MiniEnvironmentTestCase>>#testDistinctEnvironments
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDistinctEnvironments
		expectedFails: 	#()
		anEnv: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniEnvironmentTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniEnvironmentTestCase(TestCase)>>debug
	Receiver: MiniEnvironmentTestCase>>#testDistinctEnvironments
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDistinctEnvironments
		expectedFails: 	#()
		anEnv: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniEnvironmentTestCase>>#testDistinctEnvironments)...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniEnvironmentTestCase>>#testDistinctEnvironments)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments nil nil nil ...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniEnvironmentTestCase>>#testDistinctEnvironments)...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniEnvironmentTestCase>>#testDistinctEnvironments)...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnvi...etc...
		errorSelected: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
		lastUpdate: 	3624714467
		result: 	4 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 4 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	4 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 4 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnvi...etc...
		errorSelected: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
		lastUpdate: 	3624714467
		result: 	4 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 4 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnvi...etc...
		errorSelected: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
		lastUpdate: 	3624714467
		result: 	4 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 4 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnvi...etc...
		errorSelected: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
		lastUpdate: 	3624714467
		result: 	4 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 4 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnvi...etc...
		errorSelected: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
		lastUpdate: 	3624714467
		result: 	4 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 4 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnvi...etc...
		errorSelected: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
		lastUpdate: 	3624714467
		result: 	4 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 4 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(537@400) mouseUp 150355859 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(537@400) mouseUp 150355859 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(537@400) mouseUp 150355859 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(537@400) mouseUp 150355859 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	150355859
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(537@400)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(537@400) mouseUp 150355859 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(537@400) mouseUp 150355859 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(537@400) mouseUp 150355859 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(537@400) mouseUp 150355859 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(537@400) mouseUp 150355859 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	150355859
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(537@400)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(537@400) mouseUp 150355859 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(537@400) mouseUp 150355859 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(537@400) mouseUp 150355859 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(537@400) mouseUp 150355859 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(537@400) mouseUp 150355859 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(537@400) mouseUp 150355859 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(537@400.0) corner: (553@416.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(537@400.0) corner: (553@416.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@400) mouseOver nil nil]
		targetOffset: 	(118.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 150355859 537 400 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniEnvironment(Object)>>doesNotUnderstand: #addVariable:value:
MiniEnvironmentTestCase>>testDistinctEnvironments
MiniEnvironmentTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniEnvironmentTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniEnvironmentTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniEnvironmentTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniEnvironmentTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
InvalidGlobalName: NameOfSubclass: NameOfSubclass is not a valid class name
11 November 2015 12:10:47.446928 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

SlotClassBuilder>>validateClassName
	Receiver: a SlotClassBuilder
	Arguments and temporary variables: 

	Receiver's instance variables: 
		installer: 	a PharoClassInstaller
		oldClasses: 	an OrderedCollection()
		newClasses: 	an OrderedCollection()
		classSlots: 	#()
		category: 	nil
		superclass: 	Object
		name: 	#NameOfSubclass
		layoutClass: 	nil
		slots: 	#()
		traitComposition: 	{}
		classTraitComposition: 	{}
		result: 	nil
		sharedPoolsString: 	''
		sharedVariables: 	#()
		comment: 	nil
		commentStamp: 	nil


SlotClassBuilder>>name:
	Receiver: a SlotClassBuilder
	Arguments and temporary variables: 
		aName: 	#NameOfSubclass
	Receiver's instance variables: 
		installer: 	a PharoClassInstaller
		oldClasses: 	an OrderedCollection()
		newClasses: 	an OrderedCollection()
		classSlots: 	#()
		category: 	nil
		superclass: 	Object
		name: 	#NameOfSubclass
		layoutClass: 	nil
		slots: 	#()
		traitComposition: 	{}
		classTraitComposition: 	{}
		result: 	nil
		sharedPoolsString: 	''
		sharedVariables: 	#()
		comment: 	nil
		commentStamp: 	nil


[ :builder | 
builder
	superclass: superClass;
	name: name;
	layoutClass: (self layoutForType: type);
	slots: instanceVariablesString asSlotCollection;
	sharedVariablesFromString: classVariablesString;
	sharedPools: sharedPoolsString;
	category: category;
	environment: environment;
	copyTraitCompositionFromExistingClass;
	copyClassSlotsFromExistingClass ] in OldClassBuilderAdapter>>name:inEnvironment:subclassOf:type:instanceVariableNames:classVariableNames:poolDictionaries:category:
	Receiver: an OldClassBuilderAdapter
	Arguments and temporary variables: 
		name: 	#NameOfSubclass
		environment: 	a SystemDictionary(lots of globals)
		superClass: 	Object
		type: 	#normal
		instanceVariablesString: 	'variableScope procedureScope'
		classVariablesString: 	''
		sharedPoolsString: 	''
		category: 	'Mini-Environment-Impl'
		builder: 	a SlotClassBuilder
	Receiver's instance variables: 
an OldClassBuilderAdapter

PharoClassInstaller class(AbstractClassInstaller class)>>make:
	Receiver: PharoClassInstaller
	Arguments and temporary variables: 
		aBlock: 	[ :builder | 
builder
	superclass: superClass;
	name: name;
	layoutClas...etc...
		builder: 	a SlotClassBuilder
	Receiver's instance variables: 
		superclass: 	AbstractClassInstaller
		methodDict: 	a MethodDictionary(#basicClassDefinitionChangedFrom:to:using:->Phar...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#('environment' 'instanceModification' 'methodUpdateStrategy...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoClassInstaller
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Slot-ClassBuilder'
		traitComposition: 	{}
		localSelectors: 	nil


OldClassBuilderAdapter>>name:inEnvironment:subclassOf:type:instanceVariableNames:classVariableNames:poolDictionaries:category:
	Receiver: an OldClassBuilderAdapter
	Arguments and temporary variables: 
		name: 	#NameOfSubclass
		environment: 	a SystemDictionary(lots of globals)
		superClass: 	Object
		type: 	#normal
		instanceVariablesString: 	'variableScope procedureScope'
		classVariablesString: 	''
		sharedPoolsString: 	''
		category: 	'Mini-Environment-Impl'
	Receiver's instance variables: 
an OldClassBuilderAdapter

OldClassBuilderAdapter>>superclass:subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
	Receiver: an OldClassBuilderAdapter
	Arguments and temporary variables: 
		newSuper: 	Object
		t: 	#NameOfSubclass
		f: 	'variableScope procedureScope'
		d: 	''
		s: 	''
		cat: 	'Mini-Environment-Impl'
	Receiver's instance variables: 
an OldClassBuilderAdapter

Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
	Receiver: Object
	Arguments and temporary variables: 
		t: 	#NameOfSubclass
		f: 	'variableScope procedureScope'
		d: 	''
		s: 	''
		cat: 	'Mini-Environment-Impl'
		class: 	nil
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 382)
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{BalloonState. UndefinedObject. Boolean. FillStyle. ConnectionQueue...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary(a SmaCCD...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'
		traitComposition: 	{}
		localSelectors: 	nil


Object class(Class)>>subclass:instanceVariableNames:classVariableNames:category:
	Receiver: Object
	Arguments and temporary variables: 
		aSubclassSymbol: 	#NameOfSubclass
		instVarNames: 	'variableScope procedureScope'
		classVarNames: 	''
		aCategorySymbol: 	'Mini-Environment-Impl'
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 382)
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{BalloonState. UndefinedObject. Boolean. FillStyle. ConnectionQueue...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary(a SmaCCD...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Object
		subclass: #NameOfSubclass
		instanceVariableNames: 'varia...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'Object subclass: #NameOfSubclass
	instanceVariableNames: ''variableSc...etc...
		aController: 	a PluggableTextMorphWithLimits(1035206656)
		aClass: 	nil
		oldClass: 	nil
		class: 	nil
		newClassName: 	'NameOfSubclass'
		defTokens: 	an OrderedCollection('Object' 'subclass:' '#NameOfSubclass' 'instanc...etc...
		keywdIx: 	2
		envt: 	a SystemDictionary(lots of globals)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'mini'


PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'Object subclass: #NameOfSubclass
	instanceVariableNames: ''variableSc...etc...
		aController: 	a PluggableTextMorphWithLimits(1035206656)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'mini'


ClassDefinitionAcceptor>>accept:notifying:
	Receiver: a ClassDefinitionAcceptor
	Arguments and temporary variables: 
		aText: 	'Object subclass: #NameOfSubclass
	instanceVariableNames: ''variableScop...etc...
		aController: 	a PluggableTextMorphWithLimits(1035206656)
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for 'Object subclass: #NameOfSubclass
	instanceVariableNames: ''v...etc...
		aController: 	a PluggableTextMorphWithLimits(1035206656)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'mini'


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'Object subclass: #NameOfSubclass
	instanceVariableNam...etc...
	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(87 to: 86)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	64
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'Object subclass: #NameOfSubclass
	instanceVariableNam...etc...
	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(87 to: 86)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(87 to: 86)
		saveScrollerOffset: 	(-3@0)
	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(87 to: 86)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(87 to: 86)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(431.0@347.0) corner: (1248.0@633.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(431@347) corner: (1248@633)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(87 to: 86)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView>>acceptContents
	Receiver: a TextMorphForEditView(549715968)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (809@78)
		owner: 	a TransformMorph(700448768)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (809@78)
		color: 	Color black
		extension: 	a MorphExtension (601620480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'Object subclass: #NameOfSubclass
	instanceVariableNames: ''va...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(1035206656)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
	Receiver: TextMorph
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a TextMorphForEditView(549715968)
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(size 206)
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#textStyle #text #wrapFlag #paragraph #editor #container #...etc...
		organization: 	a ClassOrganization
		subclasses: 	{StringMorphEditor. TextMorphForEditView. GrowlMorph}
		name: 	#TextMorph
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-Basic'
		traitComposition: 	TAbleToRotate
		localSelectors: 	a Set(#editorClass #setTextStyle: #setFirstCharacter: #margins:...etc...
		announcer: 	nil


BlockClosure>>cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		anArg: 	a TextMorphForEditView(549715968)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	56
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(549715968)
		secondArg: 	a TextMorphForEditView(549715968)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	56
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(549715968)
		secondArg: 	a TextMorphForEditView(549715968)
		thirdArg: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	56
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		aKeymap: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(549715968)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(549715968)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		l: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#accept on Ctrl + S do [ :morph | morph acceptContents ]
)
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	4
		each: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil nil #accept on Ctrl + S do [ :morph | morph acceptConte...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(549715968)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(549715968)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(549715968)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	3


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(549715968)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a TextMorphForEditView(549715968)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher



--- The full stack ---
SlotClassBuilder>>validateClassName
SlotClassBuilder>>name:
[ :builder | 
builder
	superclass: superClass;
	name: name;
	layoutClass: (self layoutForType: type);
	slots: instanceVariablesString asSlotCollection;
	sharedVariablesFromString: classVariablesString;
	sharedPools: sharedPoolsString;
	category: category;
	environment: environment;
	copyTraitCompositionFromExistingClass;
	copyClassSlotsFromExistingClass ] in OldClassBuilderAdapter>>name:inEnvironment:subclassOf:type:instanceVariableNames:classVariableNames:poolDictionaries:category:
PharoClassInstaller class(AbstractClassInstaller class)>>make:
OldClassBuilderAdapter>>name:inEnvironment:subclassOf:type:instanceVariableNames:classVariableNames:poolDictionaries:category:
OldClassBuilderAdapter>>superclass:subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:category:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
ClassDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
TextMorphForEditView>>acceptContents
[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
11 November 2015 12:18:55.175928 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniEnvironmentTestCase(TestAsserter)>>assert:
	Receiver: MiniEnvironmentTestCase>>#testDistinctEnvironments
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testDistinctEnvironments
		expectedFails: 	nil
		anEnv: 	a MiniEnvironment


MiniEnvironmentTestCase>>testDistinctEnvironments
	Receiver: MiniEnvironmentTestCase>>#testDistinctEnvironments
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDistinctEnvironments
		expectedFails: 	nil
		anEnv: 	a MiniEnvironment


MiniEnvironmentTestCase(TestCase)>>performTest
	Receiver: MiniEnvironmentTestCase>>#testDistinctEnvironments
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDistinctEnvironments
		expectedFails: 	nil
		anEnv: 	a MiniEnvironment


[ 
self setUp.
self performTest ] in MiniEnvironmentTestCase(TestCase)>>runCase
	Receiver: MiniEnvironmentTestCase>>#testDistinctEnvironments
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDistinctEnvironments
		expectedFails: 	nil
		anEnv: 	a MiniEnvironment


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniEnvironmentTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniEnvironmentTestCase(TestCase)>>runCase
	Receiver: MiniEnvironmentTestCase>>#testDistinctEnvironments
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDistinctEnvironments
		expectedFails: 	nil
		anEnv: 	a MiniEnvironment


[ (self class selector: testSelector) runCase ] in MiniEnvironmentTestCase(TestCase)>>debug
	Receiver: MiniEnvironmentTestCase>>#testDistinctEnvironments
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDistinctEnvironments
		expectedFails: 	#()
		anEnv: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniEnvironmentTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniEnvironmentTestCase(TestCase)>>debug
	Receiver: MiniEnvironmentTestCase>>#testDistinctEnvironments
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDistinctEnvironments
		expectedFails: 	#()
		anEnv: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniEnvironmentTestCase>>#testDistinctEnvironments)...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniEnvironmentTestCase>>#testDistinctEnvironments)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments nil nil nil ...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniEnvironmentTestCase>>#testDistinctEnvironments)...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniEnvironmentTestCase>>#testDistinctEnvironments)...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnv...etc...
		failedSelected: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
		errorList: 	an Array(MiniEnvironmentTestCase>>#testScopeActivation)
		errorSelected: 	nil
		lastUpdate: 	3624715130
		result: 	4 run, 0 passes, 0 skipped, 0 expected failures, 3 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	4 run, 0 passes, 0 skipped, 0 expected failures, 3 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnv...etc...
		failedSelected: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
		errorList: 	an Array(MiniEnvironmentTestCase>>#testScopeActivation)
		errorSelected: 	nil
		lastUpdate: 	3624715130
		result: 	4 run, 0 passes, 0 skipped, 0 expected failures, 3 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnv...etc...
		failedSelected: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
		errorList: 	an Array(MiniEnvironmentTestCase>>#testScopeActivation)
		errorSelected: 	nil
		lastUpdate: 	3624715130
		result: 	4 run, 0 passes, 0 skipped, 0 expected failures, 3 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnv...etc...
		failedSelected: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
		errorList: 	an Array(MiniEnvironmentTestCase>>#testScopeActivation)
		errorSelected: 	nil
		lastUpdate: 	3624715130
		result: 	4 run, 0 passes, 0 skipped, 0 expected failures, 3 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnv...etc...
		failedSelected: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
		errorList: 	an Array(MiniEnvironmentTestCase>>#testScopeActivation)
		errorSelected: 	nil
		lastUpdate: 	3624715130
		result: 	4 run, 0 passes, 0 skipped, 0 expected failures, 3 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	an Array(MiniEnvironmentTestCase>>#testDistinctEnvironments MiniEnv...etc...
		failedSelected: 	MiniEnvironmentTestCase>>#testDistinctEnvironments
		errorList: 	an Array(MiniEnvironmentTestCase>>#testScopeActivation)
		errorSelected: 	nil
		lastUpdate: 	3624715130
		result: 	4 run, 0 passes, 0 skipped, 0 expected failures, 3 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@224.0) corner: (760.0@392.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(419@224) corner: (760@392)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		event: 	[(623@234) mouseUp 151021968 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@224.0) corner: (760.0@392.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(419@224) corner: (760@392)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		evt: 	[(623@234) mouseUp 151021968 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@224.0) corner: (760.0@392.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(419@224) corner: (760@392)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(623@234) mouseUp 151021968 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(419.0@224.0) corner: (760.0@392.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(419@224) corner: (760@392)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(623@234) mouseUp 151021968 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(223084544)
	Receiver's instance variables: 
		timeStamp: 	151021968
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(623@234)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(623@234) mouseUp 151021968 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@224.0) corner: (760.0@392.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(419@224) corner: (760@392)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(623@234) mouseUp 151021968 nil]
		aMorph: 	a PluggableListMorph(223084544)
		localEvt: 	[(623@234) mouseUp 151021968 nil]
		index: 	2
		child: 	a TransformMorph(144965632)
		morphs: 	an Array(a TransformMorph(144965632))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(623@234) mouseUp 151021968 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(623@234) mouseUp 151021968 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	151021968
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(623@234)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(623@234) mouseUp 151021968 nil]
		aMorph: 	a PluggableListMorph(223084544)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(623@234) mouseUp 151021968 nil]
		aMorph: 	a PluggableListMorph(223084544)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(623@234) mouseUp 151021968 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(419.0@224.0) corner: (760.0@392.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(419@224) corner: (760@392)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(623@234) mouseUp 151021968 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@224.0) corner: (760.0@392.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(419@224) corner: (760@392)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(623@234) mouseUp 151021968 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@224.0) corner: (760.0@392.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(419@224) corner: (760@392)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniEnvironmentTestCase>>#testDistinctEnvironments' 'MiniEnvironmentTe...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(623@234) mouseUp 151021968 nil]
		focusHolder: 	a PluggableListMorph(223084544)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(623@234.0) corner: (639@250.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(623@234.0) corner: (639@250.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(223084544)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(623@234) mouseOver nil nil]
		targetOffset: 	(203.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 151021968 623 234 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniEnvironmentTestCase(TestAsserter)>>assert:
MiniEnvironmentTestCase>>testDistinctEnvironments
MiniEnvironmentTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniEnvironmentTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniEnvironmentTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniEnvironmentTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniEnvironmentTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniEnvironment>>activateScope
11 November 2015 12:19:38.290928 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniEnvironment(Object)>>doesNotUnderstand: #activateScope
	Receiver: a MiniEnvironment
	Arguments and temporary variables: 
		aMessage: 	activateScope
		exception: 	MessageNotUnderstood: MiniEnvironment>>activateScope
		resumeValue: 	nil
	Receiver's instance variables: 
		variableScope: 	a MiniScope
		procedureScope: 	a MiniScope


MiniEnvironmentTestCase>>testScopeActivation
	Receiver: MiniEnvironmentTestCase>>#testScopeActivation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testScopeActivation
		expectedFails: 	nil
		anEnv: 	a MiniEnvironment


MiniEnvironmentTestCase(TestCase)>>performTest
	Receiver: MiniEnvironmentTestCase>>#testScopeActivation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testScopeActivation
		expectedFails: 	nil
		anEnv: 	a MiniEnvironment


[ 
self setUp.
self performTest ] in MiniEnvironmentTestCase(TestCase)>>runCase
	Receiver: MiniEnvironmentTestCase>>#testScopeActivation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testScopeActivation
		expectedFails: 	nil
		anEnv: 	a MiniEnvironment


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniEnvironmentTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniEnvironmentTestCase(TestCase)>>runCase
	Receiver: MiniEnvironmentTestCase>>#testScopeActivation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testScopeActivation
		expectedFails: 	nil
		anEnv: 	a MiniEnvironment


[ (self class selector: testSelector) runCase ] in MiniEnvironmentTestCase(TestCase)>>debug
	Receiver: MiniEnvironmentTestCase>>#testScopeActivation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testScopeActivation
		expectedFails: 	#()
		anEnv: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniEnvironmentTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniEnvironmentTestCase(TestCase)>>debug
	Receiver: MiniEnvironmentTestCase>>#testScopeActivation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testScopeActivation
		expectedFails: 	#()
		anEnv: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniEnvironmentTestCase>>#testScopeActivation
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniEnvironmentTestCase>>#testScopeActivation)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniEnvironmentTestCase>>#testScopeActivation)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniEnvironmentTestCase>>#testScopeActivation nil nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniEnvironmentTestCase>>#testScopeActivation)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniEnvironmentTestCase>>#testScopeActivation)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testScopeActivation)
		errorSelected: 	MiniEnvironmentTestCase>>#testScopeActivation
		lastUpdate: 	3624715174
		result: 	4 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	4 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testScopeActivation)
		errorSelected: 	MiniEnvironmentTestCase>>#testScopeActivation
		lastUpdate: 	3624715174
		result: 	4 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testScopeActivation)
		errorSelected: 	MiniEnvironmentTestCase>>#testScopeActivation
		lastUpdate: 	3624715174
		result: 	4 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testScopeActivation)
		errorSelected: 	MiniEnvironmentTestCase>>#testScopeActivation
		lastUpdate: 	3624715174
		result: 	4 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniEnvironmentTestCase>>#testScopeActivation
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testScopeActivation)
		errorSelected: 	MiniEnvironmentTestCase>>#testScopeActivation
		lastUpdate: 	3624715174
		result: 	4 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter')
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Environment-Tests')
		classes: 	{MiniEnvironmentTestCase. MiniScopeTestCase. MiniVoidScopeTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniEnvironmentTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniEnvironmentTestCase>>#testScopeActivation)
		errorSelected: 	MiniEnvironmentTestCase>>#testScopeActivation
		lastUpdate: 	3624715174
		result: 	4 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testScopeActivation')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(650@408) mouseUp 151065078 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testScopeActivation')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(650@408) mouseUp 151065078 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testScopeActivation')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(650@408) mouseUp 151065078 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testScopeActivation')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(650@408) mouseUp 151065078 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	151065078
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(650@408)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(650@408) mouseUp 151065078 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testScopeActivation')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(650@408) mouseUp 151065078 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(650@408) mouseUp 151065078 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(650@408) mouseUp 151065078 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(650@408) mouseUp 151065078 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	151065078
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(650@408)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(650@408) mouseUp 151065078 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(650@408) mouseUp 151065078 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(650@408) mouseUp 151065078 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testScopeActivation')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(650@408) mouseUp 151065078 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testScopeActivation')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(650@408) mouseUp 151065078 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniEnvironmentTestCase>>#testScopeActivation')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(650@408) mouseUp 151065078 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(650@408.0) corner: (666@424.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(650@408.0) corner: (666@424.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(650@408) mouseUp 151065078 nil]
		targetOffset: 	(231.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 151065078 650 408 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniEnvironment(Object)>>doesNotUnderstand: #activateScope
MiniEnvironmentTestCase>>testScopeActivation
MiniEnvironmentTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniEnvironmentTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniEnvironmentTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniEnvironmentTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniEnvironmentTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "generateWithSource" is nil
11 November 2015 12:24:44.573928 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	generateWithSource
		exception: 	MessageNotUnderstood: receiver of "generateWithSource" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'activateScope

	variableScope: (newScopeIn: variableScope).'
		aController: 	a PluggableTextMorphWithLimits(1035206656)
		aClass: 	MiniEnvironment
		oldClass: 	Object
		class: 	nil
		newClassName: 	'activateScope'
		defTokens: 	an OrderedCollection('activateScope' 'variableScope:' '(newScopeIn:'...etc...
		keywdIx: 	0
		envt: 	a SystemDictionary(lots of globals)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'mini'


PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'activateScope

	variableScope: (newScopeIn: variableScope).'
		aController: 	a PluggableTextMorphWithLimits(1035206656)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'mini'


ClassOrMethodDefinitionAcceptor>>acceptInstanceSide:notifying:
	Receiver: a ClassOrMethodDefinitionAcceptor
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


ClassOrMethodDefinitionAcceptor>>accept:notifying:
	Receiver: a ClassOrMethodDefinitionAcceptor
	Arguments and temporary variables: 
		source: 	'activateScope

	variableScope: (newScopeIn: variableScope).'
		aController: 	a PluggableTextMorphWithLimits(1035206656)
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for 'activateScope

	variableScope: (newScopeIn: variableScope).'...etc...
		aController: 	a PluggableTextMorphWithLimits(1035206656)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(1043595264)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(1035206656)
		sourceCodePanel: 	a PanelMorph(919601152)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(692584448)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1035206656...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(406061056)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(543162368)
		packagePatternString: 	'mini'


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'activateScope

	variableScope: (newScopeIn: variableS...etc...
	Receiver's instance variables: 
		bounds: 	(425.0@338.0) corner: (1242.0@624.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(425@338) corner: (1242@624)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	64
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'activateScope

	variableScope: (newScopeIn: variableS...etc...
	Receiver's instance variables: 
		bounds: 	(425.0@338.0) corner: (1242.0@624.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(425@338) corner: (1242@624)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(60 to: 59)
		saveScrollerOffset: 	(-3.0@0.0)
	Receiver's instance variables: 
		bounds: 	(425.0@338.0) corner: (1242.0@624.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(425@338) corner: (1242@624)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(425.0@338.0) corner: (1242.0@624.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(425@338) corner: (1242@624)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(1035206656)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(425.0@338.0) corner: (1242.0@624.0)
		owner: 	a MultipleMethodsEditor(406061056)
		submorphs: 	an Array(an AlphaImageMorph(743440384) a TransformMorph(700448768))
		fullBounds: 	(425@338) corner: (1242@624)
		color: 	Color white
		extension: 	a MorphExtension (30146560) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(4194304)
		scroller: 	a TransformMorph(700448768)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(382205952)
		textMorph: 	a TextMorphForEditView(549715968)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(743440384)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView>>acceptContents
	Receiver: a TextMorphForEditView(549715968)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (809@59)
		owner: 	a TransformMorph(700448768)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (809@59)
		color: 	Color black
		extension: 	a MorphExtension (601620480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'activateScope

	variableScope: ( Variable or expression expec...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(1035206656)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
	Receiver: TextMorph
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a TextMorphForEditView(549715968)
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(size 206)
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#textStyle #text #wrapFlag #paragraph #editor #container #...etc...
		organization: 	a ClassOrganization
		subclasses: 	{StringMorphEditor. TextMorphForEditView. GrowlMorph}
		name: 	#TextMorph
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-Basic'
		traitComposition: 	TAbleToRotate
		localSelectors: 	a Set(#editorClass #setTextStyle: #setFirstCharacter: #margins:...etc...
		announcer: 	nil


BlockClosure>>cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		anArg: 	a TextMorphForEditView(549715968)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	56
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(549715968)
		secondArg: 	a TextMorphForEditView(549715968)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	56
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(549715968)
		secondArg: 	a TextMorphForEditView(549715968)
		thirdArg: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	56
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		aKeymap: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(549715968)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(549715968)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		l: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#accept on Ctrl + S do [ :morph | morph acceptContents ]
)
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	4
		each: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil nil #accept on Ctrl + S do [ :morph | morph acceptConte...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(549715968)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(549715968)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(549715968)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	3


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(549715968)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a TextMorphForEditView(549715968)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-s>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(549715968)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(549715968)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (809@59)
		owner: 	a TransformMorph(700448768)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (809@59)
		color: 	Color black
		extension: 	a MorphExtension (601620480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'activateScope

	variableScope: ( Variable or expression expec...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(1035206656)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(549715968)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (809@59)
		owner: 	a TransformMorph(700448768)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (809@59)
		color: 	Color black
		extension: 	a MorphExtension (601620480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'activateScope

	variableScope: ( Variable or expression expec...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(1035206656)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-s>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(549715968)
	Receiver's instance variables: 
		timeStamp: 	151371171
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(341.0@ -55.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	19
		charCode: 	19
		scanCode: 	83


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(549715968)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (809@59)
		owner: 	a TransformMorph(700448768)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (809@59)
		color: 	Color black
		extension: 	a MorphExtension (601620480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'activateScope

	variableScope: ( Variable or expression expec...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(1035206656)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
OpalCompiler>>evaluate
PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
ClassOrMethodDefinitionAcceptor>>acceptInstanceSide:notifying:
ClassOrMethodDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
TextMorphForEditView>>acceptContents
[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniPrettyPrinter>>visitMiniProcedureNode:
13 November 2015 11:25:44.162875 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniPrettyPrinter(Object)>>doesNotUnderstand: #visitMiniProcedureNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aMessage: 	visitMiniProcedureNode: a MiniProcedureNode
		exception: 	MessageNotUnderstood: MiniPrettyPrinter>>visitMiniProcedureNode:
		resumeValue: 	nil
	Receiver's instance variables: 
		stream: 	a WriteStream


MiniProcedureNode>>accept:
	Receiver: a MiniProcedureNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		heading: 	a MiniProcedureHeadingNode
		statements: 	an OrderedCollection(a MiniAssignmentNode)


[ :each | 
each accept: self.
self stream cr ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
		each: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream


OrderedCollection>>do:
	Receiver: an OrderedCollection(a MiniProcedureNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each accept: self.
self stream cr ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a MiniProcedureNode)
		firstIndex: 	1
		lastIndex: 	1


MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
	Receiver's instance variables: 
		stream: 	a WriteStream


MiniProcedureSectionNode>>accept:
	Receiver: a MiniProcedureSectionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		procedures: 	an OrderedCollection(a MiniProcedureNode)


MiniPrettyPrinter>>visitMiniProgramNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'self accept:MiniPrettyPrinter new.'
		itsSelection: 	a Text for 'self accept:MiniPrettyPrinter new.'
		itsSelectionString: 	'self accept:MiniPrettyPrinter new.'
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniPrettyPrinter new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(607911936)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(607911936)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(644087808)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(607911936)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (967@50)
		owner: 	a TransformWithLayoutMorph(771751936)
		submorphs: 	an Array(a RubPrimarySelectionMorph(362020864) a RubCursor(25690112)...etc...
		fullBounds: 	(0@0) corner: (967@50)
		color: 	Color transparent
		extension: 	a MorphExtension (21233664) [other:  (announcer -> an Announcer) (km...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(733478912)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(25690112)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(827850752))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(644087808)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(562561024))(a SearchMorp...etc...
		lastStepTime: 	1241737
		lastStepMessage: 	nil
		lastCycleTime: 	1241737
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	1241737
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1005060096) a S...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(562561024))(a SearchMorp...etc...
		lastStepTime: 	1241737
		lastStepMessage: 	nil
		lastCycleTime: 	1241737
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	1241737
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(562561024))(a SearchMorp...etc...
		lastStepTime: 	1241737
		lastStepMessage: 	nil
		lastCycleTime: 	1241737
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	1241737
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1005060096) a S...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniPrettyPrinter(Object)>>doesNotUnderstand: #visitMiniProcedureNode:
MiniProcedureNode>>accept:
[ :each | 
each accept: self.
self stream cr ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
OrderedCollection>>do:
MiniPrettyPrinter>>visitMiniProcedureSectionNode:
MiniProcedureSectionNode>>accept:
MiniPrettyPrinter>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
13 November 2015 11:29:46.776875 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniPrettyPrinter>>visitMiniProcedureNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcedureNode: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream


MiniProcedureNode>>accept:
	Receiver: a MiniProcedureNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		heading: 	a MiniProcedureHeadingNode
		statements: 	an OrderedCollection(a MiniAssignmentNode)


[ :each | 
each accept: self.
self stream cr ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
		each: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream


OrderedCollection>>do:
	Receiver: an OrderedCollection(a MiniProcedureNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each accept: self.
self stream cr ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a MiniProcedureNode)
		firstIndex: 	1
		lastIndex: 	1


MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
	Receiver's instance variables: 
		stream: 	a WriteStream


MiniProcedureSectionNode>>accept:
	Receiver: a MiniProcedureSectionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		procedures: 	an OrderedCollection(a MiniProcedureNode)


MiniPrettyPrinter>>visitMiniProgramNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'self accept:MiniPrettyPrinter new.'
		itsSelection: 	a Text for 'self accept:MiniPrettyPrinter new.'
		itsSelectionString: 	'self accept:MiniPrettyPrinter new.'
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniPrettyPrinter new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(607911936)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(607911936)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(644087808)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(607911936)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (967@50)
		owner: 	a TransformWithLayoutMorph(771751936)
		submorphs: 	an Array(a RubPrimarySelectionMorph(362020864) a RubCursor(25690112)...etc...
		fullBounds: 	(0@0) corner: (967@50)
		color: 	Color transparent
		extension: 	a MorphExtension (21233664) [other:  (announcer -> an Announcer) (km...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(733478912)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(25690112)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(652738560))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(644087808)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(481820672))(a DropList...etc...
		lastStepTime: 	1484288
		lastStepMessage: 	nil
		lastCycleTime: 	1484285
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	1484288
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1005060096) a N...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(481820672))(a DropList...etc...
		lastStepTime: 	1484288
		lastStepMessage: 	nil
		lastCycleTime: 	1484285
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	1484288
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(481820672))(a DropList...etc...
		lastStepTime: 	1484288
		lastStepMessage: 	nil
		lastCycleTime: 	1484285
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	1484288
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1005060096) a N...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniPrettyPrinter>>visitMiniProcedureNode:
MiniProcedureNode>>accept:
[ :each | 
each accept: self.
self stream cr ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
OrderedCollection>>do:
MiniPrettyPrinter>>visitMiniProcedureSectionNode:
MiniProcedureSectionNode>>accept:
MiniPrettyPrinter>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
13 November 2015 11:37:33.205875 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniPrettyPrinter>>visitMiniProcedureNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcedureNode: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProcedureNode>>accept:
	Receiver: a MiniProcedureNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		heading: 	a MiniProcedureHeadingNode
		statements: 	an OrderedCollection(a MiniAssignmentNode)


[ :each | 
each accept: self.
self stream cr ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
		each: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


OrderedCollection>>do:
	Receiver: an OrderedCollection(a MiniProcedureNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each accept: self.
self stream cr ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a MiniProcedureNode)
		firstIndex: 	1
		lastIndex: 	1


MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProcedureSectionNode>>accept:
	Receiver: a MiniProcedureSectionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		procedures: 	an OrderedCollection(a MiniProcedureNode)


MiniPrettyPrinter>>visitMiniProgramNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'self accept:MiniPrettyPrinter new.'
		itsSelection: 	a Text for 'self accept:MiniPrettyPrinter new.'
		itsSelectionString: 	'self accept:MiniPrettyPrinter new.'
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniPrettyPrinter new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(607911936)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(607911936)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(644087808)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(607911936)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (967@50)
		owner: 	a TransformWithLayoutMorph(771751936)
		submorphs: 	an Array(a RubPrimarySelectionMorph(362020864) a RubCursor(25690112)...etc...
		fullBounds: 	(0@0) corner: (967@50)
		color: 	Color transparent
		extension: 	a MorphExtension (21233664) [other:  (announcer -> an Announcer) (km...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(733478912)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(25690112)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(168296448))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(644087808)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	1950747
		lastStepMessage: 	nil
		lastCycleTime: 	1950747
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	1950747
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1005060096) a N...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	1950747
		lastStepMessage: 	nil
		lastCycleTime: 	1950747
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	1950747
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	1950747
		lastStepMessage: 	nil
		lastCycleTime: 	1950747
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	1950747
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1005060096) a N...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniPrettyPrinter>>visitMiniProcedureNode:
MiniProcedureNode>>accept:
[ :each | 
each accept: self.
self stream cr ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
OrderedCollection>>do:
MiniPrettyPrinter>>visitMiniProcedureSectionNode:
MiniProcedureSectionNode>>accept:
MiniPrettyPrinter>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniPrettyPrinter>>skip:
13 November 2015 11:40:05.215875 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniPrettyPrinter(Object)>>doesNotUnderstand: #skip:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aMessage: 	skip: -1
		exception: 	MessageNotUnderstood: MiniPrettyPrinter>>skip:
		resumeValue: 	nil
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniPrettyPrinter>>visitMiniVariableSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aVarSectionNode: 	a MiniVariableSectionNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniVariableSectionNode>>accept:
	Receiver: a MiniVariableSectionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		variables: 	an OrderedCollection(a MiniVariableDeclarationNode)


MiniPrettyPrinter>>visitMiniProgramNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniPrettyPrinter new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(607911936)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(607911936)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(644087808)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(607911936)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (967@50)
		owner: 	a TransformWithLayoutMorph(771751936)
		submorphs: 	an Array(a RubPrimarySelectionMorph(362020864) a RubCursor(25690112)...etc...
		fullBounds: 	(0@0) corner: (967@50)
		color: 	Color transparent
		extension: 	a MorphExtension (21233664) [other:  (announcer -> an Announcer) (km...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(733478912)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(25690112)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(179044352))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(644087808)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(543162368))(a SearchMorp...etc...
		lastStepTime: 	2102847
		lastStepMessage: 	nil
		lastCycleTime: 	2102843
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	2102847
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1005060096) a S...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(543162368))(a SearchMorp...etc...
		lastStepTime: 	2102847
		lastStepMessage: 	nil
		lastCycleTime: 	2102843
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	2102847
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(543162368))(a SearchMorp...etc...
		lastStepTime: 	2102847
		lastStepMessage: 	nil
		lastCycleTime: 	2102843
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	2102847
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1005060096) a S...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniPrettyPrinter(Object)>>doesNotUnderstand: #skip:
MiniPrettyPrinter>>visitMiniVariableSectionNode:
MiniVariableSectionNode>>accept:
MiniPrettyPrinter>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniPrettyPrinter>>skip:
13 November 2015 11:40:07.117875 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniPrettyPrinter(Object)>>doesNotUnderstand: #skip:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aMessage: 	skip: -1
		exception: 	MessageNotUnderstood: MiniPrettyPrinter>>skip:
		resumeValue: 	nil
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


Message>>sentTo:
	Receiver: skip: -1
	Arguments and temporary variables: 
		receiver: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		selector: 	#skip:
		args: 	#(-1)
		lookupClass: 	MiniPrettyPrinter


MiniPrettyPrinter(Object)>>doesNotUnderstand: #skip:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aMessage: 	skip: -1
		exception: 	MessageNotUnderstood: MiniPrettyPrinter>>skip:
		resumeValue: 	MessageNotUnderstood: MiniPrettyPrinter>>skip:
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniPrettyPrinter>>visitMiniVariableSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aVarSectionNode: 	a MiniVariableSectionNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniVariableSectionNode>>accept:
	Receiver: a MiniVariableSectionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		variables: 	an OrderedCollection(a MiniVariableDeclarationNode)


MiniPrettyPrinter>>visitMiniProgramNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniPrettyPrinter new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(607911936)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(607911936)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(644087808)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(607911936)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (967@50)
		owner: 	a TransformWithLayoutMorph(771751936)
		submorphs: 	an Array(a RubPrimarySelectionMorph(362020864) a RubCursor(25690112)...etc...
		fullBounds: 	(0@0) corner: (967@50)
		color: 	Color transparent
		extension: 	a MorphExtension (21233664) [other:  (announcer -> an Announcer) (km...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(733478912)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(25690112)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(179044352))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(644087808)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(543162368))(a SearchMorp...etc...
		lastStepTime: 	2104587
		lastStepMessage: 	nil
		lastCycleTime: 	2104608
		alarms: 	a Heap()
		lastAlarmTime: 	2104587
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(657981440) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(543162368))(a SearchMorp...etc...
		lastStepTime: 	2104587
		lastStepMessage: 	nil
		lastCycleTime: 	2104608
		alarms: 	a Heap()
		lastAlarmTime: 	2104587
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(543162368))(a SearchMorp...etc...
		lastStepTime: 	2104587
		lastStepMessage: 	nil
		lastCycleTime: 	2104608
		alarms: 	a Heap()
		lastAlarmTime: 	2104587
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(657981440) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniPrettyPrinter(Object)>>doesNotUnderstand: #skip:
Message>>sentTo:
MiniPrettyPrinter(Object)>>doesNotUnderstand: #skip:
MiniPrettyPrinter>>visitMiniVariableSectionNode:
MiniVariableSectionNode>>accept:
MiniPrettyPrinter>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
13 November 2015 11:41:23.139875 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniPrettyPrinter>>visitMiniProcedureNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcedureNode: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProcedureNode>>accept:
	Receiver: a MiniProcedureNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		heading: 	a MiniProcedureHeadingNode
		statements: 	an OrderedCollection(a MiniAssignmentNode)


[ :each | 
each accept: self.
self stream cr ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
		each: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


OrderedCollection>>do:
	Receiver: an OrderedCollection(a MiniProcedureNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each accept: self.
self stream cr ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a MiniProcedureNode)
		firstIndex: 	1
		lastIndex: 	1


MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProcedureSectionNode>>accept:
	Receiver: a MiniProcedureSectionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		procedures: 	an OrderedCollection(a MiniProcedureNode)


MiniPrettyPrinter>>visitMiniProgramNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniPrettyPrinter new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(607911936)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(607911936)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(644087808)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(607911936)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (967@50)
		owner: 	a TransformWithLayoutMorph(771751936)
		submorphs: 	an Array(a RubPrimarySelectionMorph(362020864) a RubCursor(25690112)...etc...
		fullBounds: 	(0@0) corner: (967@50)
		color: 	Color transparent
		extension: 	a MorphExtension (21233664) [other:  (announcer -> an Announcer) (km...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(733478912)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(25690112)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(580648960))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(644087808)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	2180655
		lastStepMessage: 	nil
		lastCycleTime: 	2180652
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	2180655
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1005060096) a N...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	2180655
		lastStepMessage: 	nil
		lastCycleTime: 	2180652
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	2180655
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	2180655
		lastStepMessage: 	nil
		lastCycleTime: 	2180652
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	2180655
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1005060096) a N...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniPrettyPrinter>>visitMiniProcedureNode:
MiniProcedureNode>>accept:
[ :each | 
each accept: self.
self stream cr ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
OrderedCollection>>do:
MiniPrettyPrinter>>visitMiniProcedureSectionNode:
MiniProcedureSectionNode>>accept:
MiniPrettyPrinter>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
13 November 2015 11:43:21.900875 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniPrettyPrinter>>visitMiniProcedureNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcedureNode: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProcedureNode>>accept:
	Receiver: a MiniProcedureNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		heading: 	a MiniProcedureHeadingNode
		statements: 	an OrderedCollection(a MiniAssignmentNode)


[ :each | 
each accept: self.
self stream cr ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
		each: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


OrderedCollection>>do:
	Receiver: an OrderedCollection(a MiniProcedureNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each accept: self.
self stream cr ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a MiniProcedureNode)
		firstIndex: 	1
		lastIndex: 	1


MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProcedureSectionNode>>accept:
	Receiver: a MiniProcedureSectionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		procedures: 	an OrderedCollection(a MiniProcedureNode)


MiniPrettyPrinter>>visitMiniProgramNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniPrettyPrinter new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(607911936)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(607911936)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(644087808)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(607911936)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (967@50)
		owner: 	a TransformWithLayoutMorph(771751936)
		submorphs: 	an Array(a RubPrimarySelectionMorph(362020864) a RubCursor(25690112)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (21233664) [other:  (announcer -> an Announcer) (km...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(733478912)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(25690112)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(871628800))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(644087808)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(807403520))(a SearchMorp...etc...
		lastStepTime: 	2299197
		lastStepMessage: 	nil
		lastCycleTime: 	2299218
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	2299197
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1005060096) a N...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(807403520))(a SearchMorp...etc...
		lastStepTime: 	2299197
		lastStepMessage: 	nil
		lastCycleTime: 	2299218
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	2299197
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(807403520))(a SearchMorp...etc...
		lastStepTime: 	2299197
		lastStepMessage: 	nil
		lastCycleTime: 	2299218
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	2299197
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1005060096) a N...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniPrettyPrinter>>visitMiniProcedureNode:
MiniProcedureNode>>accept:
[ :each | 
each accept: self.
self stream cr ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
OrderedCollection>>do:
MiniPrettyPrinter>>visitMiniProcedureSectionNode:
MiniProcedureSectionNode>>accept:
MiniPrettyPrinter>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniPrettyPrinter>>visitMiniProcedureHeadingNode:
13 November 2015 11:46:30.659875 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniPrettyPrinter(Object)>>doesNotUnderstand: #visitMiniProcedureHeadingNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aMessage: 	visitMiniProcedureHeadingNode: a MiniProcedureHeadingNode
		exception: 	MessageNotUnderstood: MiniPrettyPrinter>>visitMiniProcedureHeadingNo...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProcedureHeadingNode>>accept:
	Receiver: a MiniProcedureHeadingNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<doit>
		params: 	nil


MiniPrettyPrinter>>visitMiniProcedureNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcedureNode: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProcedureNode>>accept:
	Receiver: a MiniProcedureNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		heading: 	a MiniProcedureHeadingNode
		statements: 	an OrderedCollection(a MiniAssignmentNode)


[ :each | 
each accept: self.
self stream cr ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
		each: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


OrderedCollection>>do:
	Receiver: an OrderedCollection(a MiniProcedureNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each accept: self.
self stream cr ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a MiniProcedureNode)
		firstIndex: 	1
		lastIndex: 	1


MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProcedureSectionNode>>accept:
	Receiver: a MiniProcedureSectionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		procedures: 	an OrderedCollection(a MiniProcedureNode)


MiniPrettyPrinter>>visitMiniProgramNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniPrettyPrinter new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(607911936)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(607911936)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(644087808)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(607911936)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (967@50)
		owner: 	a TransformWithLayoutMorph(771751936)
		submorphs: 	an Array(a RubPrimarySelectionMorph(362020864) a RubCursor(25690112)...etc...
		fullBounds: 	(0@0) corner: (967@50)
		color: 	Color transparent
		extension: 	a MorphExtension (21233664) [other:  (announcer -> an Announcer) (km...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(733478912)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(25690112)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(805568512))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(644087808)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	2488296
		lastStepMessage: 	nil
		lastCycleTime: 	2488290
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	2488296
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1005060096) a N...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	2488296
		lastStepMessage: 	nil
		lastCycleTime: 	2488290
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	2488296
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	2488296
		lastStepMessage: 	nil
		lastCycleTime: 	2488290
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25690112)))
		lastAlarmTime: 	2488296
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1005060096) a N...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniPrettyPrinter(Object)>>doesNotUnderstand: #visitMiniProcedureHeadingNode:
MiniProcedureHeadingNode>>accept:
MiniPrettyPrinter>>visitMiniProcedureNode:
MiniProcedureNode>>accept:
[ :each | 
each accept: self.
self stream cr ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
OrderedCollection>>do:
MiniPrettyPrinter>>visitMiniProcedureSectionNode:
MiniProcedureSectionNode>>accept:
MiniPrettyPrinter>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
16 November 2015 11:32:55.47226 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniPrettyPrinter>>visitMiniProcedureHeadingNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcedureHeadingNode: 	a MiniProcedureHeadingNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProcedureHeadingNode>>accept:
	Receiver: a MiniProcedureHeadingNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<doit>
		params: 	#()


MiniPrettyPrinter>>visitMiniProcedureNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcedureNode: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProcedureNode>>accept:
	Receiver: a MiniProcedureNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		heading: 	a MiniProcedureHeadingNode
		statements: 	an OrderedCollection(a MiniAssignmentNode)


[ :each | 
each accept: self.
self stream cr ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
		each: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


OrderedCollection>>do:
	Receiver: an OrderedCollection(a MiniProcedureNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each accept: self.
self stream cr ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a MiniProcedureNode)
		firstIndex: 	1
		lastIndex: 	1


MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProcedureSectionNode>>accept:
	Receiver: a MiniProcedureSectionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		procedures: 	an OrderedCollection(a MiniProcedureNode)


MiniPrettyPrinter>>visitMiniProgramNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniPrettyPrinter new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(670040064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(670040064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(676069376)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(670040064)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (474@50)
		owner: 	a TransformWithLayoutMorph(803733504)
		submorphs: 	an Array(a RubPrimarySelectionMorph(538443776) a RubCursor(105617817...etc...
		fullBounds: 	(0@0) corner: (474@50)
		color: 	Color transparent
		extension: 	a MorphExtension (26214400) [other:  (announcer -> an Announcer) (km...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(765460480)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1056178176)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(1022099456))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(676069376)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(807403520))(a SearchMorp...etc...
		lastStepTime: 	2244917
		lastStepMessage: 	nil
		lastCycleTime: 	2244917
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1056178176)))
		lastAlarmTime: 	2244917
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(490471424) a St...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(807403520))(a SearchMorp...etc...
		lastStepTime: 	2244917
		lastStepMessage: 	nil
		lastCycleTime: 	2244917
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1056178176)))
		lastAlarmTime: 	2244917
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(807403520))(a SearchMorp...etc...
		lastStepTime: 	2244917
		lastStepMessage: 	nil
		lastCycleTime: 	2244917
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1056178176)))
		lastAlarmTime: 	2244917
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(490471424) a St...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniPrettyPrinter>>visitMiniProcedureHeadingNode:
MiniProcedureHeadingNode>>accept:
MiniPrettyPrinter>>visitMiniProcedureNode:
MiniProcedureNode>>accept:
[ :each | 
each accept: self.
self stream cr ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
OrderedCollection>>do:
MiniPrettyPrinter>>visitMiniProcedureSectionNode:
MiniProcedureSectionNode>>accept:
MiniPrettyPrinter>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
16 November 2015 11:37:27.19326 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniPrettyPrinter>>visitMiniProcedureHeadingNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcedureHeadingNode: 	a MiniProcedureHeadingNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProcedureHeadingNode>>accept:
	Receiver: a MiniProcedureHeadingNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<doit>
		params: 	#()


MiniPrettyPrinter>>visitMiniProcedureNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcedureNode: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProcedureNode>>accept:
	Receiver: a MiniProcedureNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		heading: 	a MiniProcedureHeadingNode
		statements: 	an OrderedCollection(a MiniAssignmentNode)


[ :each | 
each accept: self.
self stream cr ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
		each: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a MiniProcedureNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each accept: self.
self stream cr ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a MiniProcedureNode)
		firstIndex: 	1
		lastIndex: 	1


MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProcedureSectionNode>>accept:
	Receiver: a MiniProcedureSectionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		procedures: 	an OrderedCollection(a MiniProcedureNode)


MiniPrettyPrinter>>visitMiniProgramNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniPrettyPrinter new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(1035993088)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(1035993088)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(327155712)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(1035993088)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (967@50)
		owner: 	a TransformWithLayoutMorph(448790528)
		submorphs: 	an Array(a RubPrimarySelectionMorph(315883520) a RubCursor(378535936...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (392167424) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(410517504)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(378535936)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(76808192))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(327155712)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(807403520))(a SearchMorp...etc...
		lastStepTime: 	2516367
		lastStepMessage: 	nil
		lastCycleTime: 	2516389
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(378535936)))
		lastAlarmTime: 	2516367
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(451149824) a St...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(807403520))(a SearchMorp...etc...
		lastStepTime: 	2516367
		lastStepMessage: 	nil
		lastCycleTime: 	2516389
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(378535936)))
		lastAlarmTime: 	2516367
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(807403520))(a SearchMorp...etc...
		lastStepTime: 	2516367
		lastStepMessage: 	nil
		lastCycleTime: 	2516389
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(378535936)))
		lastAlarmTime: 	2516367
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(451149824) a St...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniPrettyPrinter>>visitMiniProcedureHeadingNode:
MiniProcedureHeadingNode>>accept:
MiniPrettyPrinter>>visitMiniProcedureNode:
MiniProcedureNode>>accept:
[ :each | 
each accept: self.
self stream cr ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
OrderedCollection>>do:
MiniPrettyPrinter>>visitMiniProcedureSectionNode:
MiniProcedureSectionNode>>accept:
MiniPrettyPrinter>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
16 November 2015 11:40:10.32226 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniPrettyPrinter>>visitMiniProcedureHeadingNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcedureHeadingNode: 	a MiniProcedureHeadingNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProcedureHeadingNode>>accept:
	Receiver: a MiniProcedureHeadingNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<doit>
		params: 	#()


MiniPrettyPrinter>>visitMiniProcedureNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcedureNode: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProcedureNode>>accept:
	Receiver: a MiniProcedureNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		heading: 	a MiniProcedureHeadingNode
		statements: 	an OrderedCollection(a MiniAssignmentNode)


[ :each | 
each accept: self.
self stream cr ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
		each: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a MiniProcedureNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each accept: self.
self stream cr ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a MiniProcedureNode)
		firstIndex: 	1
		lastIndex: 	1


MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProcedureSectionNode>>accept:
	Receiver: a MiniProcedureSectionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		procedures: 	an OrderedCollection(a MiniProcedureNode)


MiniPrettyPrinter>>visitMiniProgramNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniPrettyPrinter new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(292290560)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(292290560)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(316407808)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(292290560)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (967@50)
		owner: 	a TransformWithLayoutMorph(438042624)
		submorphs: 	an Array(a RubPrimarySelectionMorph(238026752) a RubCursor(750780416...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (830734336) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(411828224)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(750780416)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(96206848))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(316407808)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(807403520))(a SearchMorp...etc...
		lastStepTime: 	2679501
		lastStepMessage: 	nil
		lastCycleTime: 	2679522
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(750780416)))
		lastAlarmTime: 	2679501
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(645660672) a St...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(807403520))(a SearchMorp...etc...
		lastStepTime: 	2679501
		lastStepMessage: 	nil
		lastCycleTime: 	2679522
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(750780416)))
		lastAlarmTime: 	2679501
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(807403520))(a SearchMorp...etc...
		lastStepTime: 	2679501
		lastStepMessage: 	nil
		lastCycleTime: 	2679522
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(750780416)))
		lastAlarmTime: 	2679501
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(645660672) a St...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniPrettyPrinter>>visitMiniProcedureHeadingNode:
MiniProcedureHeadingNode>>accept:
MiniPrettyPrinter>>visitMiniProcedureNode:
MiniProcedureNode>>accept:
[ :each | 
each accept: self.
self stream cr ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
OrderedCollection>>do:
MiniPrettyPrinter>>visitMiniProcedureSectionNode:
MiniProcedureSectionNode>>accept:
MiniPrettyPrinter>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
16 November 2015 11:40:55.10326 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniPrettyPrinter>>visitMiniProcedureHeadingNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcedureHeadingNode: 	a MiniProcedureHeadingNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProcedureHeadingNode>>accept:
	Receiver: a MiniProcedureHeadingNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<doit>
		params: 	#()


MiniPrettyPrinter>>visitMiniProcedureNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcedureNode: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProcedureNode>>accept:
	Receiver: a MiniProcedureNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		heading: 	a MiniProcedureHeadingNode
		statements: 	an OrderedCollection(a MiniAssignmentNode)


[ :each | 
each accept: self.
self stream crtab: self indentLevel ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
		each: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a MiniProcedureNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each accept: self.
self stream crtab: self indentLevel ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a MiniProcedureNode)
		firstIndex: 	1
		lastIndex: 	1


MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProcedureSectionNode>>accept:
	Receiver: a MiniProcedureSectionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		procedures: 	an OrderedCollection(a MiniProcedureNode)


MiniPrettyPrinter>>visitMiniProgramNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniPrettyPrinter new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(1035993088)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(1035993088)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(327155712)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(1035993088)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (967@50)
		owner: 	a TransformWithLayoutMorph(448790528)
		submorphs: 	an Array(a RubPrimarySelectionMorph(315883520) a RubCursor(378535936...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (392167424) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(410517504)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(378535936)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(221511680))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(327155712)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	2724431
		lastStepMessage: 	nil
		lastCycleTime: 	2724453
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(378535936)))
		lastAlarmTime: 	2724431
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(451149824) a Na...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	2724431
		lastStepMessage: 	nil
		lastCycleTime: 	2724453
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(378535936)))
		lastAlarmTime: 	2724431
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	2724431
		lastStepMessage: 	nil
		lastCycleTime: 	2724453
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(378535936)))
		lastAlarmTime: 	2724431
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(451149824) a Na...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniPrettyPrinter>>visitMiniProcedureHeadingNode:
MiniProcedureHeadingNode>>accept:
MiniPrettyPrinter>>visitMiniProcedureNode:
MiniProcedureNode>>accept:
[ :each | 
each accept: self.
self stream crtab: self indentLevel ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
OrderedCollection>>do:
MiniPrettyPrinter>>visitMiniProcedureSectionNode:
MiniProcedureSectionNode>>accept:
MiniPrettyPrinter>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
16 November 2015 11:41:12.56326 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniPrettyPrinter>>visitMiniProcedureHeadingNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcedureHeadingNode: 	a MiniProcedureHeadingNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProcedureHeadingNode>>accept:
	Receiver: a MiniProcedureHeadingNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<doit>
		params: 	#()


MiniPrettyPrinter>>visitMiniProcedureNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcedureNode: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProcedureNode>>accept:
	Receiver: a MiniProcedureNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		heading: 	a MiniProcedureHeadingNode
		statements: 	an OrderedCollection(a MiniAssignmentNode)


[ :each | 
each accept: self.
self stream crtab: self indentLevel ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
		each: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a MiniProcedureNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each accept: self.
self stream crtab: self indentLevel ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a MiniProcedureNode)
		firstIndex: 	1
		lastIndex: 	1


MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProcedureSectionNode>>accept:
	Receiver: a MiniProcedureSectionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		procedures: 	an OrderedCollection(a MiniProcedureNode)


MiniPrettyPrinter>>visitMiniProgramNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniPrettyPrinter new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(738197504)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(738197504)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(769916928)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(738197504)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (474@50)
		owner: 	a TransformWithLayoutMorph(891551744)
		submorphs: 	an Array(a RubPrimarySelectionMorph(420741120) a RubCursor(86769664)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (106430464) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(853278720)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(86769664)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(231735296))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(769916928)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	2741889
		lastStepMessage: 	nil
		lastCycleTime: 	2741910
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(86769664)))
		lastAlarmTime: 	2741889
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(169345024) a St...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	2741889
		lastStepMessage: 	nil
		lastCycleTime: 	2741910
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(86769664)))
		lastAlarmTime: 	2741889
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	2741889
		lastStepMessage: 	nil
		lastCycleTime: 	2741910
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(86769664)))
		lastAlarmTime: 	2741889
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(169345024) a St...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniPrettyPrinter>>visitMiniProcedureHeadingNode:
MiniProcedureHeadingNode>>accept:
MiniPrettyPrinter>>visitMiniProcedureNode:
MiniProcedureNode>>accept:
[ :each | 
each accept: self.
self stream crtab: self indentLevel ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
OrderedCollection>>do:
MiniPrettyPrinter>>visitMiniProcedureSectionNode:
MiniProcedureSectionNode>>accept:
MiniPrettyPrinter>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
16 November 2015 11:42:15.51926 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniPrettyPrinter>>visitMiniProcedureHeadingNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcedureHeadingNode: 	a MiniProcedureHeadingNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProcedureHeadingNode>>accept:
	Receiver: a MiniProcedureHeadingNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<doit>
		params: 	#()


MiniPrettyPrinter>>visitMiniProcedureNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcedureNode: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProcedureNode>>accept:
	Receiver: a MiniProcedureNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		heading: 	a MiniProcedureHeadingNode
		statements: 	an OrderedCollection(a MiniAssignmentNode)


[ :each | 
each accept: self.
self stream crtab: self indentLevel ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
		each: 	a MiniProcedureNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a MiniProcedureNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each accept: self.
self stream crtab: self indentLevel ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a MiniProcedureNode)
		firstIndex: 	1
		lastIndex: 	1


MiniPrettyPrinter>>visitMiniProcedureSectionNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProcedureSectionNode>>accept:
	Receiver: a MiniProcedureSectionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		procedures: 	an OrderedCollection(a MiniProcedureNode)


MiniPrettyPrinter>>visitMiniProgramNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	1


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Jessica>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	an OrderedCollection(a MiniAssignmentNode)


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniPrettyPrinter new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(228589568)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(228589568)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(246677504)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(228589568)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (967@50)
		owner: 	a TransformWithLayoutMorph(374341632)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1059848192) a RubCursor(60266905...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (664535040) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(336068608)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(602669056)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(867172352))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(246677504)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(807403520))(a SearchMorp...etc...
		lastStepTime: 	2804856
		lastStepMessage: 	nil
		lastCycleTime: 	2804877
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(602669056)))
		lastAlarmTime: 	2804856
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(96206848) a Sta...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(807403520))(a SearchMorp...etc...
		lastStepTime: 	2804856
		lastStepMessage: 	nil
		lastCycleTime: 	2804877
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(602669056)))
		lastAlarmTime: 	2804856
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(807403520))(a SearchMorp...etc...
		lastStepTime: 	2804856
		lastStepMessage: 	nil
		lastCycleTime: 	2804877
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(602669056)))
		lastAlarmTime: 	2804856
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(96206848) a Sta...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniPrettyPrinter>>visitMiniProcedureHeadingNode:
MiniProcedureHeadingNode>>accept:
MiniPrettyPrinter>>visitMiniProcedureNode:
MiniProcedureNode>>accept:
[ :each | 
each accept: self.
self stream crtab: self indentLevel ] in MiniPrettyPrinter>>visitMiniProcedureSectionNode:
OrderedCollection>>do:
MiniPrettyPrinter>>visitMiniProcedureSectionNode:
MiniProcedureSectionNode>>accept:
MiniPrettyPrinter>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MenuMorph>>labels:lines:selections:
19 November 2015 11:05:44.069281 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MenuMorph(Object)>>doesNotUnderstand: #labels:lines:selections:
	Receiver: a MenuMorph(759169024)
	Arguments and temporary variables: 
		aMessage: 	labels: 'find...(f)
find again (g)
set search string (h)
do again (j)...etc...
		exception: 	MessageNotUnderstood: MenuMorph>>labels:lines:selections:
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (40@10)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (784072704) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a SmaCCCodeHolder
		selectedItem: 	nil
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		embeddable: 	nil
		menuItems: 	nil
		basicColor: 	nil


SmaCCCodeHolder>>contentsMenu:shifted:
	Receiver: a SmaCCCodeHolder
	Arguments and temporary variables: 
		aMenu: 	a MenuMorph(759169024)
		shifted: 	false
		selections: 	#(#find #findAgain #setSearchString #again #undo #copySelection #cu...etc...
		labelsString: 	'find...(f)
find again (g)
set search string (h)
do again (j)
und...etc...
		linesArray: 	#(3 5 9 11 14)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableTextMorph(35389440))
		contents: 	''
		contentsMorph: 	a PluggableTextMorph(35389440)
		owner: 	a SmaCCDevelopmentUI
		ownerAcceptSelector: 	#acceptTestCode:notifying:


PluggableTextMorph(ScrollPane)>>getMenu:
	Receiver: a PluggableTextMorph(35389440)
	Arguments and temporary variables: 
		shiftKeyState: 	false
		menu: 	a MenuMorph(759169024)
		aMenu: 	nil
		aTitle: 	nil
	Receiver's instance variables: 
		bounds: 	(300.0@383.0) corner: (1020.0@626.0)
		owner: 	an AlignmentMorph(729022464)
		submorphs: 	an Array(a TransformMorph(247463936))
		fullBounds: 	(300@383) corner: (1020@626)
		color: 	Color transparent
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer) (k...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a SmaCCCodeHolder
		scrollBar: 	a ScrollBar(76283904)
		scroller: 	a TransformMorph(247463936)
		getMenuSelector: 	#contentsMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(719585280)
		textMorph: 	a TextMorphForEditView(1026031616)
		getTextSelector: 	#contents
		setTextSelector: 	#contents:notifying:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(14 to: 13)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	nil
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>yellowButtonActivity:
	Receiver: a PluggableTextMorph(35389440)
	Arguments and temporary variables: 
		shiftKeyState: 	false
	Receiver's instance variables: 
		bounds: 	(300.0@383.0) corner: (1020.0@626.0)
		owner: 	an AlignmentMorph(729022464)
		submorphs: 	an Array(a TransformMorph(247463936))
		fullBounds: 	(300@383) corner: (1020@626)
		color: 	Color transparent
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer) (k...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a SmaCCCodeHolder
		scrollBar: 	a ScrollBar(76283904)
		scroller: 	a TransformMorph(247463936)
		getMenuSelector: 	#contentsMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(719585280)
		textMorph: 	a TextMorphForEditView(1026031616)
		getTextSelector: 	#contents
		setTextSelector: 	#contents:notifying:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(14 to: 13)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	nil
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


SmalltalkEditor(TextEditor)>>mouseUp:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		evt: 	[(185@21.0) mouseUp 264439031 nil]
		mouseDownInterval: 	(14 to: 13)
		clickPoint: 	nil
		b: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(1026031616)
		selectionShowing: 	true
		model: 	a SmaCCCodeHolder
		editingState: 	a SmalltalkEditingState


[ editor mouseUp: evt ] in TextMorphForEditView(TextMorph)>>mouseUp:
	Receiver: a TextMorphForEditView(1026031616)
	Arguments and temporary variables: 
		evt: 	[(185@21.0) mouseUp 264439031 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (712@40)
		owner: 	a TransformMorph(247463936)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (712@40)
		color: 	Color black
		extension: 	a MorphExtension (1065877504) [other:  (kmDispatcher -> a KMDispatch...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Sans Pro
		text: 	a Text for 'program foo 
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	nil
		editView: 	a PluggableTextMorph(35389440)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleInteraction:
	Receiver: a TextMorphForEditView(1026031616)
	Arguments and temporary variables: 
		interactionBlock: 	[ editor mouseUp: evt ]
		oldEditor: 	a SmalltalkEditor
		oldParagraph: 	a Paragraph
		oldText: 	a Text for 'program foo 
'
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (712@40)
		owner: 	a TransformMorph(247463936)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (712@40)
		color: 	Color black
		extension: 	a MorphExtension (1065877504) [other:  (kmDispatcher -> a KMDispatch...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Sans Pro
		text: 	a Text for 'program foo 
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	nil
		editView: 	a PluggableTextMorph(35389440)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView>>handleInteraction:
	Receiver: a TextMorphForEditView(1026031616)
	Arguments and temporary variables: 
		interActionBlock: 	[ editor mouseUp: evt ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (712@40)
		owner: 	a TransformMorph(247463936)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (712@40)
		color: 	Color black
		extension: 	a MorphExtension (1065877504) [other:  (kmDispatcher -> a KMDispatch...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Sans Pro
		text: 	a Text for 'program foo 
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	nil
		editView: 	a PluggableTextMorph(35389440)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>mouseUp:
	Receiver: a TextMorphForEditView(1026031616)
	Arguments and temporary variables: 
		evt: 	[(185@21.0) mouseUp 264439031 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (712@40)
		owner: 	a TransformMorph(247463936)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (712@40)
		color: 	Color black
		extension: 	a MorphExtension (1065877504) [other:  (kmDispatcher -> a KMDispatch...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Sans Pro
		text: 	a Text for 'program foo 
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	nil
		editView: 	a PluggableTextMorph(35389440)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView>>mouseUp:
	Receiver: a TextMorphForEditView(1026031616)
	Arguments and temporary variables: 
		event: 	[(185@21.0) mouseUp 264439031 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (712@40)
		owner: 	a TransformMorph(247463936)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (712@40)
		color: 	Color black
		extension: 	a MorphExtension (1065877504) [other:  (kmDispatcher -> a KMDispatch...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Sans Pro
		text: 	a Text for 'program foo 
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	nil
		editView: 	a PluggableTextMorph(35389440)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleMouseUp:
	Receiver: a TextMorphForEditView(1026031616)
	Arguments and temporary variables: 
		anEvent: 	[(185@21.0) mouseUp 264439031 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (712@40)
		owner: 	a TransformMorph(247463936)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (712@40)
		color: 	Color black
		extension: 	a MorphExtension (1065877504) [other:  (kmDispatcher -> a KMDispatch...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Sans Pro
		text: 	a Text for 'program foo 
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	nil
		editView: 	a PluggableTextMorph(35389440)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(185@21.0) mouseUp 264439031 nil]
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(1026031616)
	Receiver's instance variables: 
		timeStamp: 	264439031
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(185@21.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(1026031616)
	Arguments and temporary variables: 
		anEvent: 	[(185@21.0) mouseUp 264439031 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (712@40)
		owner: 	a TransformMorph(247463936)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (712@40)
		color: 	Color black
		extension: 	a MorphExtension (1065877504) [other:  (kmDispatcher -> a KMDispatch...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Sans Pro
		text: 	a Text for 'program foo 
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	nil
		editView: 	a PluggableTextMorph(35389440)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(1026031616)
	Arguments and temporary variables: 
		anEvent: 	[(185@21.0) mouseUp 264439031 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (712@40)
		owner: 	a TransformMorph(247463936)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (712@40)
		color: 	Color black
		extension: 	a MorphExtension (1065877504) [other:  (kmDispatcher -> a KMDispatch...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Sans Pro
		text: 	a Text for 'program foo 
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	nil
		editView: 	a PluggableTextMorph(35389440)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(489@405) mouseUp 264439031 nil]
		focusHolder: 	a TextMorphForEditView(1026031616)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(481@396.0) corner: (497@412.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(481@396.0) corner: (497@412.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(1026031616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(489@405) mouseOver nil nil]
		targetOffset: 	(185@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 264439031 489 405 0 0 1 1)
		lastKeyScanCode: 	13
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(489@405) mouseOver nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a StandardWindow(730595328) a Nau...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(489@405) mouseUp 264439031 nil]
		focusHolder: 	a TextMorphForEditView(1026031616)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(481@396.0) corner: (497@412.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(481@396.0) corner: (497@412.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(1026031616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(489@405) mouseOver nil nil]
		targetOffset: 	(185@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 264439031 489 405 0 0 1 1)
		lastKeyScanCode: 	13
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(489@405) mouseUp 264439031 nil]
		focusHolder: 	a TextMorphForEditView(1026031616)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(481@396.0) corner: (497@412.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(481@396.0) corner: (497@412.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(1026031616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(489@405) mouseOver nil nil]
		targetOffset: 	(185@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 264439031 489 405 0 0 1 1)
		lastKeyScanCode: 	13
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(489@405) mouseUp 264439031 nil]
	Receiver's instance variables: 
		bounds: 	(481@396.0) corner: (497@412.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(481@396.0) corner: (497@412.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(1026031616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(489@405) mouseOver nil nil]
		targetOffset: 	(185@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 264439031 489 405 0 0 1 1)
		lastKeyScanCode: 	13
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(489@405) mouseUp 264439031 nil]
		evt: 	[(489@405) mouseUp 264439031 nil]
	Receiver's instance variables: 
		bounds: 	(481@396.0) corner: (497@412.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(481@396.0) corner: (497@412.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(1026031616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(489@405) mouseOver nil nil]
		targetOffset: 	(185@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 264439031 489 405 0 0 1 1)
		lastKeyScanCode: 	13
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


MouseClickState>>handleEvent:from:
	Receiver: a MouseClickState[#firstClickUp]
	Arguments and temporary variables: 
		evt: 	[(489@405) mouseUp 264439031 nil]
		aHand: 	a HandMorph(760479744)
		localEvt: 	[(489@405) mouseUp 264439031 nil]
		timedOut: 	false
		isDrag: 	false
	Receiver's instance variables: 
		clickClient: 	a StandardWindow(730595328)
		clickState: 	#firstClickUp
		firstClickDown: 	[(489@405) mouseDown yellow 264438953 nil]
		firstClickUp: 	[(489@405) mouseUp 264439031 nil]
		firstClickTime: 	264438953
		clickSelector: 	#click:
		dblClickSelector: 	#doubleClick:
		dblClickTime: 	350
		dblClickTimeoutSelector: 	#doubleClickTimeout:
		dragSelector: 	#startDrag:
		dragThreshold: 	10


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(489@405) mouseUp 264439031 nil]
		evt: 	[(489@405) mouseUp 264439031 nil]
	Receiver's instance variables: 
		bounds: 	(481@396.0) corner: (497@412.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(481@396.0) corner: (497@412.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(1026031616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(489@405) mouseOver nil nil]
		targetOffset: 	(185@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 264439031 489 405 0 0 1 1)
		lastKeyScanCode: 	13
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(489@405) mouseUp 264439031 nil]
		evtBuf: 	#(1 264439031 489 405 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(481@396.0) corner: (497@412.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(481@396.0) corner: (497@412.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(1026031616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(489@405) mouseOver nil nil]
		targetOffset: 	(185@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 264439031 489 405 0 0 1 1)
		lastKeyScanCode: 	13
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#toggleSelected 367525888))(3...etc...
		lastStepTime: 	513226
		lastStepMessage: 	nil
		lastCycleTime: 	513302
		alarms: 	a Heap()
		lastAlarmTime: 	513226
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#toggleSelected 367525888))(3...etc...
		lastStepTime: 	513226
		lastStepMessage: 	nil
		lastCycleTime: 	513302
		alarms: 	a Heap()
		lastAlarmTime: 	513226
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#toggleSelected 367525888))(3...etc...
		lastStepTime: 	513226
		lastStepMessage: 	nil
		lastCycleTime: 	513302
		alarms: 	a Heap()
		lastAlarmTime: 	513226
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#toggleSelected 367525888))(3...etc...
		lastStepTime: 	513226
		lastStepMessage: 	nil
		lastCycleTime: 	513302
		alarms: 	a Heap()
		lastAlarmTime: 	513226
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a StandardWindow(730595328) a Nau...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MenuMorph(Object)>>doesNotUnderstand: #labels:lines:selections:
SmaCCCodeHolder>>contentsMenu:shifted:
PluggableTextMorph(ScrollPane)>>getMenu:
PluggableTextMorph>>yellowButtonActivity:
SmalltalkEditor(TextEditor)>>mouseUp:
[ editor mouseUp: evt ] in TextMorphForEditView(TextMorph)>>mouseUp:
TextMorphForEditView(TextMorph)>>handleInteraction:
TextMorphForEditView>>handleInteraction:
TextMorphForEditView(TextMorph)>>mouseUp:
TextMorphForEditView>>mouseUp:
TextMorphForEditView(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
19 November 2015 11:19:32.704281 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniPrettyPrinter>>visitMiniCompoundStatementNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aCompoundStatement: 	a MiniCompoundStatementNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniCompoundStatementNode>>accept:
	Receiver: a MiniCompoundStatementNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		statements: 	an OrderedCollection(a MiniAssignmentNode a MiniAssignmentNode)


MiniPrettyPrinter>>visitMiniProgramNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<Factorials>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	a MiniCompoundStatementNode


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Factorials>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	a MiniCompoundStatementNode


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniPrettyPrinter new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(853016576)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(853016576)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(878706688)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(853016576)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (967@50)
		owner: 	a TransformWithLayoutMorph(1006370816)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1066926080) a RubCursor(27682406...etc...
		fullBounds: 	(0@0) corner: (967@50)
		color: 	Color transparent
		extension: 	a MorphExtension (254279680) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(968097792)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(276824064)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(946864128))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(878706688)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(807403520))(a SearchMorp...etc...
		lastStepTime: 	1342033
		lastStepMessage: 	nil
		lastCycleTime: 	1342033
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(276824064)))
		lastAlarmTime: 	1342033
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(544735232) a St...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(807403520))(a SearchMorp...etc...
		lastStepTime: 	1342033
		lastStepMessage: 	nil
		lastCycleTime: 	1342033
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(276824064)))
		lastAlarmTime: 	1342033
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(807403520))(a SearchMorp...etc...
		lastStepTime: 	1342033
		lastStepMessage: 	nil
		lastCycleTime: 	1342033
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(276824064)))
		lastAlarmTime: 	1342033
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(544735232) a St...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniPrettyPrinter>>visitMiniCompoundStatementNode:
MiniCompoundStatementNode>>accept:
MiniPrettyPrinter>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
19 November 2015 11:19:48.676281 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniPrettyPrinter>>visitMiniCompoundStatementNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aCompoundStatement: 	a MiniCompoundStatementNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniCompoundStatementNode>>accept:
	Receiver: a MiniCompoundStatementNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		statements: 	an OrderedCollection(a MiniAssignmentNode a MiniAssignmentNode)


MiniPrettyPrinter>>visitMiniProgramNode:
	Receiver: a MiniPrettyPrinter
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniPrettyPrinter
	Receiver's instance variables: 
		name: 	<Factorials>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	a MiniCompoundStatementNode


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Factorials>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	a MiniCompoundStatementNode


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniPrettyPrinter new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(853016576)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(853016576)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(878706688)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(853016576)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (967@50)
		owner: 	a TransformWithLayoutMorph(1006370816)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1066926080) a RubCursor(27682406...etc...
		fullBounds: 	(0@0) corner: (967@50)
		color: 	Color transparent
		extension: 	a MorphExtension (254279680) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(968097792)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(276824064)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(964689920))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(878706688)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	1357890
		lastStepMessage: 	nil
		lastCycleTime: 	1357886
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(276824064)))
		lastAlarmTime: 	1357890
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(544735232) a St...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	1357967
		lastStepMessage: 	nil
		lastCycleTime: 	1357966
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(276824064)))
		lastAlarmTime: 	1357967
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1350@689)
		canvas: 	a FormCanvas on: DisplayScreen(1350x689x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(871890944))(a DropList...etc...
		lastStepTime: 	1357967
		lastStepMessage: 	nil
		lastCycleTime: 	1357966
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(276824064)))
		lastAlarmTime: 	1357967
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(544735232) a St...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniPrettyPrinter>>visitMiniCompoundStatementNode:
MiniCompoundStatementNode>>accept:
MiniPrettyPrinter>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: SmaCCToken>>asNumber
19 November 2015 11:43:12.271281 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

SmaCCToken(Object)>>doesNotUnderstand: #asNumber
	Receiver: {42(0,1,#())}
	Arguments and temporary variables: 
		aMessage: 	asNumber
		exception: 	MessageNotUnderstood: SmaCCToken>>asNumber
		resumeValue: 	nil
	Receiver's instance variables: 
		start: 	0
		ids: 	#()
		value: 	'42'


MiniInterpreter>>visitMiniIntegerNode:
	Receiver: a MiniInterpreter
	Arguments and temporary variables: 
		anIntegerNode: 	<42>
	Receiver's instance variables: 
		environment: 	a MiniEnvironment


MiniIntegerNode>>accept:
	Receiver: <42>
	Arguments and temporary variables: 
		aVisitor: 	a MiniInterpreter
	Receiver's instance variables: 
		token: 	{42(0,1,#())}


MiniInterpreterTestCase>>testVisitIntegerNode
	Receiver: MiniInterpreterTestCase>>#testVisitIntegerNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVisitIntegerNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase(TestCase)>>performTest
	Receiver: MiniInterpreterTestCase>>#testVisitIntegerNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVisitIntegerNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVisitIntegerNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVisitIntegerNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVisitIntegerNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVisitIntegerNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVisitIntegerNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVisitIntegerNode
		expectedFails: 	#()
		visitor: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVisitIntegerNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVisitIntegerNode
		expectedFails: 	#()
		visitor: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniInterpreterTestCase>>#testVisitIntegerNode
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVisitIntegerNode)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniInterpreterTestCase>>#testVisitIntegerNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniInterpreterTestCase>>#testVisitIntegerNode nil nil nil nil ...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVisitIntegerNode)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVisitIntegerNode)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVisitIntegerNode)
		errorSelected: 	MiniInterpreterTestCase>>#testVisitIntegerNode
		lastUpdate: 	3625404190
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVisitIntegerNode)
		errorSelected: 	MiniInterpreterTestCase>>#testVisitIntegerNode
		lastUpdate: 	3625404190
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVisitIntegerNode)
		errorSelected: 	MiniInterpreterTestCase>>#testVisitIntegerNode
		lastUpdate: 	3625404190
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVisitIntegerNode)
		errorSelected: 	MiniInterpreterTestCase>>#testVisitIntegerNode
		lastUpdate: 	3625404190
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniInterpreterTestCase>>#testVisitIntegerNode
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVisitIntegerNode)
		errorSelected: 	MiniInterpreterTestCase>>#testVisitIntegerNode
		lastUpdate: 	3625404190
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVisitIntegerNode)
		errorSelected: 	MiniInterpreterTestCase>>#testVisitIntegerNode
		lastUpdate: 	3625404190
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVisitIntegerNode')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(582@414) mouseUp 266687234 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVisitIntegerNode')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(582@414) mouseUp 266687234 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVisitIntegerNode')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(582@414) mouseUp 266687234 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVisitIntegerNode')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(582@414) mouseUp 266687234 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	266687234
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(582@414)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(582@414) mouseUp 266687234 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVisitIntegerNode')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(582@414) mouseUp 266687234 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(582@414) mouseUp 266687234 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(582@414) mouseUp 266687234 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(582@414) mouseUp 266687234 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	266687234
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(582@414)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(582@414) mouseUp 266687234 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(582@414) mouseUp 266687234 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(582@414) mouseUp 266687234 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVisitIntegerNode')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(582@414) mouseUp 266687234 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVisitIntegerNode')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
SmaCCToken(Object)>>doesNotUnderstand: #asNumber
MiniInterpreter>>visitMiniIntegerNode:
MiniIntegerNode>>accept:
MiniInterpreterTestCase>>testVisitIntegerNode
MiniInterpreterTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniInterpreterTestCase>>visitMiniVariableDeclarationNode:
19 November 2015 11:46:12.888281 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniInterpreterTestCase(Object)>>doesNotUnderstand: #visitMiniVariableDeclarationNode:
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 
		aMessage: 	visitMiniVariableDeclarationNode: a MiniVariableDeclarationNode
		exception: 	MessageNotUnderstood: MiniInterpreterTestCase>>visitMiniVariableDecl...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniVariableDeclarationNode>>accept:
	Receiver: a MiniVariableDeclarationNode
	Arguments and temporary variables: 
		aVisitor: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		name: 	<earl>
		type: 	<integer>


MiniInterpreterTestCase>>testVariableDeclaration
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase(TestCase)>>performTest
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	#()
		visitor: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	#()
		visitor: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625404371
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625404371
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625404371
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625404371
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625404371
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625404371
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(673@410) mouseUp 266867937 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(673@410) mouseUp 266867937 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(673@410) mouseUp 266867937 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(673@410) mouseUp 266867937 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	266867937
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(673@410)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(673@410) mouseUp 266867937 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(673@410) mouseUp 266867937 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(673@410) mouseUp 266867937 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(673@410) mouseUp 266867937 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(673@410) mouseUp 266867937 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	266867937
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(673@410)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(673@410) mouseUp 266867937 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(673@410) mouseUp 266867937 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(673@410) mouseUp 266867937 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(673@410) mouseUp 266867937 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(673@410) mouseUp 266867937 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
MiniInterpreterTestCase(Object)>>doesNotUnderstand: #visitMiniVariableDeclarationNode:
MiniVariableDeclarationNode>>accept:
MiniInterpreterTestCase>>testVariableDeclaration
MiniInterpreterTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniEnvironment>>hasVariableNamed:
20 November 2015 11:28:25.265865 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniEnvironment(Object)>>doesNotUnderstand: #hasVariableNamed:
	Receiver: a MiniEnvironment
	Arguments and temporary variables: 
		aMessage: 	hasVariableNamed: 'earl'
		exception: 	MessageNotUnderstood: MiniEnvironment>>hasVariableNamed:
		resumeValue: 	nil
	Receiver's instance variables: 
		procedures: 	a MiniScope
		variables: 	a MiniScope


MiniInterpreterTestCase>>testVariableDeclaration
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase(TestCase)>>performTest
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	#()
		visitor: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	#()
		visitor: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625489703
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625489703
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625489703
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625489703
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625489703
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625489703
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(615@405) mouseUp 352200218 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(615@405) mouseUp 352200218 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352200218 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(615@405) mouseUp 352200218 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	352200218
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(615@405)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352200218 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352200218 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(615@405) mouseUp 352200218 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352200218 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(615@405) mouseUp 352200218 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	352200218
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(615@405)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352200218 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352200218 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352200218 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352200218 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352200218 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352200218 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(615@405.0) corner: (631@421.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(615@405.0) corner: (631@421.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(615@405) mouseOver nil nil]
		targetOffset: 	(196.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 352200218 615 405 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniEnvironment(Object)>>doesNotUnderstand: #hasVariableNamed:
MiniInterpreterTestCase>>testVariableDeclaration
MiniInterpreterTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniEnvironment>>hasVariableNamed:
20 November 2015 11:28:26.694865 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniEnvironment(Object)>>doesNotUnderstand: #hasVariableNamed:
	Receiver: a MiniEnvironment
	Arguments and temporary variables: 
		aMessage: 	hasVariableNamed: 'earl'
		exception: 	MessageNotUnderstood: MiniEnvironment>>hasVariableNamed:
		resumeValue: 	nil
	Receiver's instance variables: 
		procedures: 	a MiniScope
		variables: 	a MiniScope


MiniInterpreterTestCase>>testVariableDeclaration
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase(TestCase)>>performTest
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	#()
		visitor: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	#()
		visitor: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625489703
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625489703
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625489703
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625489703
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625489703
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625489703
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(615@405) mouseUp 352201734 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(615@405) mouseUp 352201734 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352201734 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(615@405) mouseUp 352201734 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	352201734
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(615@405)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352201734 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352201734 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(615@405) mouseUp 352201734 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352201734 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(615@405) mouseUp 352201734 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	352201734
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(615@405)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352201734 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352201734 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352201734 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352201734 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352201734 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(615@405) mouseUp 352201734 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(615@405.0) corner: (631@421.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(615@405.0) corner: (631@421.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(615@405) mouseUp 352201734 nil]
		targetOffset: 	(196.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 352201734 615 405 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniEnvironment(Object)>>doesNotUnderstand: #hasVariableNamed:
MiniInterpreterTestCase>>testVariableDeclaration
MiniInterpreterTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniEnvironment>>hasVariableNamed:
20 November 2015 11:28:32.129865 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniEnvironment(Object)>>doesNotUnderstand: #hasVariableNamed:
	Receiver: a MiniEnvironment
	Arguments and temporary variables: 
		aMessage: 	hasVariableNamed: 'earl'
		exception: 	MessageNotUnderstood: MiniEnvironment>>hasVariableNamed:
		resumeValue: 	nil
	Receiver's instance variables: 
		procedures: 	a MiniScope
		variables: 	a MiniScope


MiniInterpreterTestCase>>testVariableDeclaration
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase(TestCase)>>performTest
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	#()
		visitor: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	#()
		visitor: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625489711
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625489711
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625489711
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625489711
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625489711
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	1
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3625489711
		result: 	2 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(583@410) mouseUp 352207187 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(583@410) mouseUp 352207187 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(583@410) mouseUp 352207187 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(583@410) mouseUp 352207187 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	352207187
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(583@410)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(583@410) mouseUp 352207187 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(583@410) mouseUp 352207187 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(583@410) mouseUp 352207187 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(583@410) mouseUp 352207187 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(583@410) mouseUp 352207187 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	352207187
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(583@410)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(583@410) mouseUp 352207187 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(583@410) mouseUp 352207187 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(583@410) mouseUp 352207187 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(583@410) mouseUp 352207187 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(583@410) mouseUp 352207187 nil]
	Receiver's instance variables: 
		bounds: 	(419.0@396.0) corner: (760.0@595.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(419@396) corner: (760@595)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(583@410) mouseUp 352207187 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(583@410.0) corner: (599@426.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(583@410.0) corner: (599@426.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(583@410) mouseUp 352207187 nil]
		targetOffset: 	(164.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 352207187 583 410 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniEnvironment(Object)>>doesNotUnderstand: #hasVariableNamed:
MiniInterpreterTestCase>>testVariableDeclaration
MiniInterpreterTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniEnvironment>>hasVariableNamed:
30 November 2015 10:57:20.67382 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniEnvironment(Object)>>doesNotUnderstand: #hasVariableNamed:
	Receiver: a MiniEnvironment
	Arguments and temporary variables: 
		aMessage: 	hasVariableNamed: 'earl'
		exception: 	MessageNotUnderstood: MiniEnvironment>>hasVariableNamed:
		resumeValue: 	nil
	Receiver's instance variables: 
		procedures: 	a MiniScope
		variables: 	a MiniScope


MiniInterpreterTestCase>>testVariableDeclaration
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase(TestCase)>>performTest
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	#()
		visitor: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	#()
		visitor: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	3
		categoriesSelected: 	a Set(#'Mini-PrettyPrinter' #'Mini-Interpreter')
		classes: 	{MiniVisitorTestCase. MiniInterpreterTestCase. MiniPrettyPrinterTestCa...etc...
		classIndex: 	2
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626351838
		result: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	3
		categoriesSelected: 	a Set(#'Mini-PrettyPrinter' #'Mini-Interpreter')
		classes: 	{MiniVisitorTestCase. MiniInterpreterTestCase. MiniPrettyPrinterTestCa...etc...
		classIndex: 	2
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626351838
		result: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	3
		categoriesSelected: 	a Set(#'Mini-PrettyPrinter' #'Mini-Interpreter')
		classes: 	{MiniVisitorTestCase. MiniInterpreterTestCase. MiniPrettyPrinterTestCa...etc...
		classIndex: 	2
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626351838
		result: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	3
		categoriesSelected: 	a Set(#'Mini-PrettyPrinter' #'Mini-Interpreter')
		classes: 	{MiniVisitorTestCase. MiniInterpreterTestCase. MiniPrettyPrinterTestCa...etc...
		classIndex: 	2
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626351838
		result: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	3
		categoriesSelected: 	a Set(#'Mini-PrettyPrinter' #'Mini-Interpreter')
		classes: 	{MiniVisitorTestCase. MiniInterpreterTestCase. MiniPrettyPrinterTestCa...etc...
		classIndex: 	2
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626351838
		result: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	3
		categoriesSelected: 	a Set(#'Mini-PrettyPrinter' #'Mini-Interpreter')
		classes: 	{MiniVisitorTestCase. MiniInterpreterTestCase. MiniPrettyPrinterTestCa...etc...
		classIndex: 	2
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626351838
		result: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(402.0@408.0) corner: (743.0@607.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(402@408) corner: (743@607)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(645@417) mouseUp 140593551 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(402.0@408.0) corner: (743.0@607.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(402@408) corner: (743@607)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(645@417) mouseUp 140593551 nil]
	Receiver's instance variables: 
		bounds: 	(402.0@408.0) corner: (743.0@607.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(402@408) corner: (743@607)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(645@417) mouseUp 140593551 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(402.0@408.0) corner: (743.0@607.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(402@408) corner: (743@607)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(645@417) mouseUp 140593551 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	140593551
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(645@417)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(645@417) mouseUp 140593551 nil]
	Receiver's instance variables: 
		bounds: 	(402.0@408.0) corner: (743.0@607.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(402@408) corner: (743@607)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(645@417) mouseUp 140593551 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(645@417) mouseUp 140593551 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(645@417) mouseUp 140593551 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(645@417) mouseUp 140593551 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	140593551
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(645@417)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(645@417) mouseUp 140593551 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(645@417) mouseUp 140593551 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(645@417) mouseUp 140593551 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(402.0@408.0) corner: (743.0@607.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(402@408) corner: (743@607)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(645@417) mouseUp 140593551 nil]
	Receiver's instance variables: 
		bounds: 	(402.0@408.0) corner: (743.0@607.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(402@408) corner: (743@607)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(645@417) mouseUp 140593551 nil]
	Receiver's instance variables: 
		bounds: 	(402.0@408.0) corner: (743.0@607.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(402@408) corner: (743@607)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(645@417) mouseUp 140593551 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(770@187.0) corner: (786@203.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(770@187.0) corner: (786@203.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(770@187) mouseOver nil nil]
		targetOffset: 	(243.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 140594082 770 187 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniEnvironment(Object)>>doesNotUnderstand: #hasVariableNamed:
MiniInterpreterTestCase>>testVariableDeclaration
MiniInterpreterTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
30 November 2015 10:58:05.61682 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniInterpreterTestCase(TestAsserter)>>assert:
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase>>testAssignmentNode
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase(TestCase)>>performTest
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	#()
		visitor: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	#()
		visitor: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniInterpreterTestCase>>#testAssignmentNode
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	nil
		lastUpdate: 	3626351883
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	nil
		lastUpdate: 	3626351883
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	nil
		lastUpdate: 	3626351883
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	nil
		lastUpdate: 	3626351883
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniInterpreterTestCase>>#testAssignmentNode
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	nil
		lastUpdate: 	3626351883
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	nil
		lastUpdate: 	3626351883
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(402.0@236.0) corner: (743.0@404.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(402@236) corner: (743@404)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		event: 	[(666@239) mouseUp 140638847 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(402.0@236.0) corner: (743.0@404.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(402@236) corner: (743@404)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		evt: 	[(666@239) mouseUp 140638847 nil]
	Receiver's instance variables: 
		bounds: 	(402.0@236.0) corner: (743.0@404.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(402@236) corner: (743@404)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(666@239) mouseUp 140638847 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(402.0@236.0) corner: (743.0@404.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(402@236) corner: (743@404)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(666@239) mouseUp 140638847 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(223084544)
	Receiver's instance variables: 
		timeStamp: 	140638847
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(666@239)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(666@239) mouseUp 140638847 nil]
	Receiver's instance variables: 
		bounds: 	(402.0@236.0) corner: (743.0@404.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(402@236) corner: (743@404)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(666@239) mouseUp 140638847 nil]
		aMorph: 	a PluggableListMorph(223084544)
		localEvt: 	[(666@239) mouseUp 140638847 nil]
		index: 	2
		child: 	a TransformMorph(144965632)
		morphs: 	an Array(a TransformMorph(144965632))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(666@239) mouseUp 140638847 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(666@239) mouseUp 140638847 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	140638847
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(666@239)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(666@239) mouseUp 140638847 nil]
		aMorph: 	a PluggableListMorph(223084544)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(666@239) mouseUp 140638847 nil]
		aMorph: 	a PluggableListMorph(223084544)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(666@239) mouseUp 140638847 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(402.0@236.0) corner: (743.0@404.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(402@236) corner: (743@404)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(666@239) mouseUp 140638847 nil]
	Receiver's instance variables: 
		bounds: 	(402.0@236.0) corner: (743.0@404.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(402@236) corner: (743@404)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(666@239) mouseUp 140638847 nil]
	Receiver's instance variables: 
		bounds: 	(402.0@236.0) corner: (743.0@404.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(402@236) corner: (743@404)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(666@239) mouseUp 140638847 nil]
		focusHolder: 	a PluggableListMorph(223084544)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(666@239.0) corner: (682@255.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(666@239.0) corner: (682@255.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(223084544)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(666@239) mouseUp 140638847 nil]
		targetOffset: 	(264.0@3.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 140638847 666 239 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniInterpreterTestCase(TestAsserter)>>assert:
MiniInterpreterTestCase>>testAssignmentNode
MiniInterpreterTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
30 November 2015 10:59:25.90282 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniInterpreterTestCase(TestAsserter)>>assert:
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase>>testAssignmentNode
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase(TestCase)>>performTest
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	#()
		visitor: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	#()
		visitor: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniInterpreterTestCase>>#testAssignmentNode
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	nil
		lastUpdate: 	3626351883
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	nil
		lastUpdate: 	3626351883
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	nil
		lastUpdate: 	3626351883
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	nil
		lastUpdate: 	3626351883
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniInterpreterTestCase>>#testAssignmentNode
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	nil
		lastUpdate: 	3626351883
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	nil
		lastUpdate: 	3626351883
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(388.0@180.0) corner: (729.0@348.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(388.0@180.0) corner: (729.0@348.0)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		event: 	[(574@188) mouseUp 140719113 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(388.0@180.0) corner: (729.0@348.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(388.0@180.0) corner: (729.0@348.0)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		evt: 	[(574@188) mouseUp 140719113 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@180.0) corner: (729.0@348.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(388.0@180.0) corner: (729.0@348.0)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(574@188) mouseUp 140719113 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(388.0@180.0) corner: (729.0@348.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(388.0@180.0) corner: (729.0@348.0)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(574@188) mouseUp 140719113 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(223084544)
	Receiver's instance variables: 
		timeStamp: 	140719113
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(574@188)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(574@188) mouseUp 140719113 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@180.0) corner: (729.0@348.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(388.0@180.0) corner: (729.0@348.0)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(574@188) mouseUp 140719113 nil]
		aMorph: 	a PluggableListMorph(223084544)
		localEvt: 	[(574@188) mouseUp 140719113 nil]
		index: 	2
		child: 	a TransformMorph(144965632)
		morphs: 	an Array(a TransformMorph(144965632))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(574@188) mouseUp 140719113 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(574@188) mouseUp 140719113 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	140719113
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(574@188)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(574@188) mouseUp 140719113 nil]
		aMorph: 	a PluggableListMorph(223084544)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(574@188) mouseUp 140719113 nil]
		aMorph: 	a PluggableListMorph(223084544)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(574@188) mouseUp 140719113 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(388.0@180.0) corner: (729.0@348.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(388.0@180.0) corner: (729.0@348.0)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(574@188) mouseUp 140719113 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@180.0) corner: (729.0@348.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(388.0@180.0) corner: (729.0@348.0)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(574@188) mouseUp 140719113 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@180.0) corner: (729.0@348.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(388.0@180.0) corner: (729.0@348.0)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(574@188) mouseUp 140719113 nil]
		focusHolder: 	a PluggableListMorph(223084544)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(574@188.0) corner: (590@204.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(574@188.0) corner: (590@204.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(223084544)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(574@188) mouseUp 140719113 nil]
		targetOffset: 	(186.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 140719113 574 188 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniInterpreterTestCase(TestAsserter)>>assert:
MiniInterpreterTestCase>>testAssignmentNode
MiniInterpreterTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
30 November 2015 11:18:35.31782 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniInterpreterTestCase(TestAsserter)>>assert:
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase>>testAssignmentNode
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase(TestCase)>>performTest
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	#()
		visitor: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	#()
		visitor: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniInterpreterTestCase>>#testAssignmentNode
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	nil
		lastUpdate: 	3626353097
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	nil
		lastUpdate: 	3626353097
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	nil
		lastUpdate: 	3626353097
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	nil
		lastUpdate: 	3626353097
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniInterpreterTestCase>>#testAssignmentNode
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	nil
		lastUpdate: 	3626353097
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	nil
		lastUpdate: 	3626353097
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(388.0@180.0) corner: (729.0@348.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(388@180) corner: (729@348)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		event: 	[(466@196) mouseUp 141867379 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(388.0@180.0) corner: (729.0@348.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(388@180) corner: (729@348)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		evt: 	[(466@196) mouseUp 141867379 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@180.0) corner: (729.0@348.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(388@180) corner: (729@348)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(466@196) mouseUp 141867379 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(388.0@180.0) corner: (729.0@348.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(388@180) corner: (729@348)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(466@196) mouseUp 141867379 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(223084544)
	Receiver's instance variables: 
		timeStamp: 	141867379
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(466@196)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(466@196) mouseUp 141867379 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@180.0) corner: (729.0@348.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(388@180) corner: (729@348)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(466@196) mouseUp 141867379 nil]
		aMorph: 	a PluggableListMorph(223084544)
		localEvt: 	[(466@196) mouseUp 141867379 nil]
		index: 	2
		child: 	a TransformMorph(144965632)
		morphs: 	an Array(a TransformMorph(144965632))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(466@196) mouseUp 141867379 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(466@196) mouseUp 141867379 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	141867379
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(466@196)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(466@196) mouseUp 141867379 nil]
		aMorph: 	a PluggableListMorph(223084544)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(466@196) mouseUp 141867379 nil]
		aMorph: 	a PluggableListMorph(223084544)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(466@196) mouseUp 141867379 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(388.0@180.0) corner: (729.0@348.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(388@180) corner: (729@348)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(466@196) mouseUp 141867379 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@180.0) corner: (729.0@348.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(388@180) corner: (729@348)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(223084544)
	Arguments and temporary variables: 
		anEvent: 	[(466@196) mouseUp 141867379 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@180.0) corner: (729.0@348.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(144965632))
		fullBounds: 	(388@180) corner: (729@348)
		color: 	Color white
		extension: 	a MorphExtension (391643136) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(255590400)
		scroller: 	a TransformMorph(144965632)
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(749731840)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(170917888)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(466@196) mouseUp 141867379 nil]
		focusHolder: 	a PluggableListMorph(223084544)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(901@106.0) corner: (917@122.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(901@106.0) corner: (917@122.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(223084544)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(901@106) mouseOver nil nil]
		targetOffset: 	(78.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 141868519 901 107 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniInterpreterTestCase(TestAsserter)>>assert:
MiniInterpreterTestCase>>testAssignmentNode
MiniInterpreterTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniEnvironment>>hasVariableNamed:
30 November 2015 11:19:53.88282 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniEnvironment(Object)>>doesNotUnderstand: #hasVariableNamed:
	Receiver: a MiniEnvironment
	Arguments and temporary variables: 
		aMessage: 	hasVariableNamed: 'earl'
		exception: 	MessageNotUnderstood: MiniEnvironment>>hasVariableNamed:
		resumeValue: 	nil
	Receiver's instance variables: 
		procedures: 	a MiniScope
		variables: 	a MiniScope


MiniInterpreterTestCase>>testVariableDeclaration
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase(TestCase)>>performTest
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	#()
		visitor: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	#()
		visitor: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626353097
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626353097
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626353097
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626353097
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626353097
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode)
		failedSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626353097
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(563@354) mouseUp 141947113 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(563@354) mouseUp 141947113 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(563@354) mouseUp 141947113 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(563@354) mouseUp 141947113 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	141947113
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(563@354)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(563@354) mouseUp 141947113 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(563@354) mouseUp 141947113 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(563@354) mouseUp 141947113 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(563@354) mouseUp 141947113 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(563@354) mouseUp 141947113 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	141947113
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(563@354)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(563@354) mouseUp 141947113 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(563@354) mouseUp 141947113 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(563@354) mouseUp 141947113 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(563@354) mouseUp 141947113 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(563@354) mouseUp 141947113 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(563@354) mouseUp 141947113 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(563@354.0) corner: (579@370.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(563@354.0) corner: (579@370.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(563@354) mouseUp 141947113 nil]
		targetOffset: 	(175.0@2.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 141947113 563 354 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniEnvironment(Object)>>doesNotUnderstand: #hasVariableNamed:
MiniInterpreterTestCase>>testVariableDeclaration
MiniInterpreterTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniInterpreter>>visitMiniAssignmentNode:
30 November 2015 11:23:45.50082 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniInterpreter(Object)>>doesNotUnderstand: #visitMiniAssignmentNode:
	Receiver: a MiniInterpreter
	Arguments and temporary variables: 
		aMessage: 	visitMiniAssignmentNode: a MiniAssignmentNode
		exception: 	MessageNotUnderstood: MiniInterpreter>>visitMiniAssignmentNode:
		resumeValue: 	nil
	Receiver's instance variables: 
		environment: 	a MiniEnvironment


MiniAssignmentNode>>accept:
	Receiver: a MiniAssignmentNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniInterpreter
	Receiver's instance variables: 
		lhs: 	<colton>
		rhs: 	<9>


MiniInterpreterTestCase>>testAssignmentNode
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase(TestCase)>>performTest
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	#()
		visitor: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	#()
		visitor: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniInterpreterTestCase>>#testAssignmentNode
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode MiniInterprete...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		lastUpdate: 	3626353422
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode MiniInterprete...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		lastUpdate: 	3626353422
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode MiniInterprete...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		lastUpdate: 	3626353422
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode MiniInterprete...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		lastUpdate: 	3626353422
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniInterpreterTestCase>>#testAssignmentNode
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode MiniInterprete...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		lastUpdate: 	3626353422
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode MiniInterprete...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		lastUpdate: 	3626353422
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(605@359) mouseUp 142178707 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(605@359) mouseUp 142178707 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(605@359) mouseUp 142178707 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(605@359) mouseUp 142178707 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	142178707
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(605@359)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(605@359) mouseUp 142178707 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(605@359) mouseUp 142178707 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(605@359) mouseUp 142178707 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(605@359) mouseUp 142178707 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(605@359) mouseUp 142178707 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	142178707
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(605@359)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(605@359) mouseUp 142178707 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(605@359) mouseUp 142178707 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(605@359) mouseUp 142178707 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(605@359) mouseUp 142178707 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(605@359) mouseUp 142178707 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
MiniInterpreter(Object)>>doesNotUnderstand: #visitMiniAssignmentNode:
MiniAssignmentNode>>accept:
MiniInterpreterTestCase>>testAssignmentNode
MiniInterpreterTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniEnvironment>>hasVariableNamed:
30 November 2015 11:24:10.00582 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniEnvironment(Object)>>doesNotUnderstand: #hasVariableNamed:
	Receiver: a MiniEnvironment
	Arguments and temporary variables: 
		aMessage: 	hasVariableNamed: 'earl'
		exception: 	MessageNotUnderstood: MiniEnvironment>>hasVariableNamed:
		resumeValue: 	nil
	Receiver's instance variables: 
		variableScope: 	a MiniScope
		procedureScope: 	a MiniScope


MiniInterpreterTestCase>>testVariableDeclaration
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase(TestCase)>>performTest
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	#()
		visitor: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	#()
		visitor: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode MiniInterprete...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626353422
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode MiniInterprete...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626353422
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode MiniInterprete...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626353422
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode MiniInterprete...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626353422
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode MiniInterprete...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626353422
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	2
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode MiniInterprete...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626353422
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	2
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(499@379) mouseUp 142203222 nil]
		row: 	2
		mdr: 	2
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(499@379) mouseUp 142203222 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(499@379) mouseUp 142203222 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(499@379) mouseUp 142203222 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	142203222
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(499@379)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(499@379) mouseUp 142203222 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@379) mouseUp 142203222 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(499@379) mouseUp 142203222 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@379) mouseUp 142203222 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(499@379) mouseUp 142203222 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	142203222
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(499@379)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@379) mouseUp 142203222 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@379) mouseUp 142203222 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(499@379) mouseUp 142203222 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(499@379) mouseUp 142203222 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(499@379) mouseUp 142203222 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(499@379) mouseUp 142203222 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(499@379.0) corner: (515@395.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(499@379.0) corner: (515@395.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(499@379) mouseUp 142203222 nil]
		targetOffset: 	(111.0@27.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 142203222 499 379 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniEnvironment(Object)>>doesNotUnderstand: #hasVariableNamed:
MiniInterpreterTestCase>>testVariableDeclaration
MiniInterpreterTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniInterpreter>>visitMiniAssignmentNode:
30 November 2015 11:30:13.16582 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniInterpreter(Object)>>doesNotUnderstand: #visitMiniAssignmentNode:
	Receiver: a MiniInterpreter
	Arguments and temporary variables: 
		aMessage: 	visitMiniAssignmentNode: a MiniAssignmentNode
		exception: 	MessageNotUnderstood: MiniInterpreter>>visitMiniAssignmentNode:
		resumeValue: 	nil
	Receiver's instance variables: 
		environment: 	a MiniEnvironment


MiniAssignmentNode>>accept:
	Receiver: a MiniAssignmentNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniInterpreter
	Receiver's instance variables: 
		lhs: 	<colton>
		rhs: 	<9>


MiniInterpreterTestCase>>testAssignmentNode
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase(TestCase)>>performTest
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	#()
		visitor: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testAssignmentNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAssignmentNode
		expectedFails: 	#()
		visitor: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniInterpreterTestCase>>#testAssignmentNode
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testAssignmentNode)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode MiniInterprete...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		lastUpdate: 	3626353811
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode MiniInterprete...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		lastUpdate: 	3626353811
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode MiniInterprete...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		lastUpdate: 	3626353811
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode MiniInterprete...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		lastUpdate: 	3626353811
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniInterpreterTestCase>>#testAssignmentNode
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode MiniInterprete...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		lastUpdate: 	3626353811
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testAssignmentNode MiniInterprete...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testAssignmentNode
		lastUpdate: 	3626353811
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(644@358) mouseUp 142566379 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(644@358) mouseUp 142566379 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(644@358) mouseUp 142566379 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(644@358) mouseUp 142566379 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	142566379
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(644@358)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(644@358) mouseUp 142566379 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(644@358) mouseUp 142566379 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(644@358) mouseUp 142566379 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(644@358) mouseUp 142566379 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(644@358) mouseUp 142566379 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	142566379
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(644@358)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(644@358) mouseUp 142566379 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(644@358) mouseUp 142566379 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(644@358) mouseUp 142566379 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(644@358) mouseUp 142566379 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(644@358) mouseUp 142566379 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testAssignmentNode' 'MiniInterpreterTestCase...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
MiniInterpreter(Object)>>doesNotUnderstand: #visitMiniAssignmentNode:
MiniAssignmentNode>>accept:
MiniInterpreterTestCase>>testAssignmentNode
MiniInterpreterTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniEnvironment>>hasVariableNamed:
30 November 2015 11:30:32.43082 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniEnvironment(Object)>>doesNotUnderstand: #hasVariableNamed:
	Receiver: a MiniEnvironment
	Arguments and temporary variables: 
		aMessage: 	hasVariableNamed: 'earl'
		exception: 	MessageNotUnderstood: MiniEnvironment>>hasVariableNamed:
		resumeValue: 	nil
	Receiver's instance variables: 
		variableScope: 	a MiniScope
		procedureScope: 	a MiniScope


MiniInterpreterTestCase>>testVariableDeclaration
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase(TestCase)>>performTest
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	#()
		visitor: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	#()
		visitor: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626353830
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626353830
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626353830
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626353830
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626353830
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626353830
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(521@359) mouseUp 142585644 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(521@359) mouseUp 142585644 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(521@359) mouseUp 142585644 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(521@359) mouseUp 142585644 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	142585644
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(521@359)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(521@359) mouseUp 142585644 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(521@359) mouseUp 142585644 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(521@359) mouseUp 142585644 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(521@359) mouseUp 142585644 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(521@359) mouseUp 142585644 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	142585644
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(521@359)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(521@359) mouseUp 142585644 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(521@359) mouseUp 142585644 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(521@359) mouseUp 142585644 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(521@359) mouseUp 142585644 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(521@359) mouseUp 142585644 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(521@359) mouseUp 142585644 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(521@359.0) corner: (537@375.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(521@359.0) corner: (537@375.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(521@359) mouseUp 142585644 nil]
		targetOffset: 	(133.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 142585644 521 359 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniEnvironment(Object)>>doesNotUnderstand: #hasVariableNamed:
MiniInterpreterTestCase>>testVariableDeclaration
MiniInterpreterTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: CompiledMethod>>theNonMetaClass
30 November 2015 11:35:30.327106 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

CompiledMethod(Object)>>doesNotUnderstand: #theNonMetaClass
	Receiver: MiniInterpreterTestCase>>#functionNode
	Arguments and temporary variables: 
		aMessage: 	theNonMetaClass
		exception: 	MessageNotUnderstood: CompiledMethod>>theNonMetaClass
		resumeValue: 	nil
	Receiver's instance variables: 
MiniInterpreterTestCase>>#functionNode

[ :aClass | 
self showGroups
	ifTrue: [ 
		receiver addClasses: {aClass}.
		ActiveHand shiftPressed
			ifFalse: [ 
				self selectedGroup removeClass: aClass.
				self updateClassView ] ]
	ifFalse: [ 
		receiver addClass: aClass theNonMetaClass.
		ActiveHand shiftPressed
			ifTrue: [ 
				self selectedClass: nil.
				self updateClassView ]
			ifFalse: [ 
				self selectedPackage: receiver.
				self selectedClass: aClass.
				self updatePackageGroupAndClassList ] ] ] in PackageTreeNautilusUI(AbstractNautilusUI)>>dropInAPackage:into:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aCollection: 	{MiniInterpreterTestCase>>#functionNode}
		receiver: 	a RPackage(Mini-PrettyPrinter)
		aClass: 	MiniInterpreterTestCase>>#functionNode
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(456916992)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(708050944)
		sourceCodePanel: 	a PanelMorph(592445440)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(311427072)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(708050944)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(24903680)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(329777152)
		packagePatternString: 	'mini'


Array(SequenceableCollection)>>do:
	Receiver: {MiniInterpreterTestCase>>#functionNode}
	Arguments and temporary variables: 
		aBlock: 	[ :aClass | 
self showGroups
	ifTrue: [ 
		receiver addClasses: {aClass...etc...
		index: 	1
	Receiver's instance variables: 
{MiniInterpreterTestCase>>#functionNode}

PackageTreeNautilusUI(AbstractNautilusUI)>>dropInAPackage:into:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aCollection: 	{MiniInterpreterTestCase>>#functionNode}
		receiver: 	a RPackage(Mini-PrettyPrinter)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(456916992)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(708050944)
		sourceCodePanel: 	a PanelMorph(592445440)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(311427072)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(708050944)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(24903680)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(329777152)
		packagePatternString: 	'mini'


PackageTreeModel>>acceptDroppingMorph:event:inMorph:
	Receiver: a PackageTreeModel
	Arguments and temporary variables: 
		aMorph: 	a TransferMorph(867434496)
		evt: 	[(477@230.0) dropEvent nil]
		aTreeMorph: 	a MorphTreeMorph(660602880)
		target: 	a RPackage(Mini-PrettyPrinter)
		items: 	{MiniInterpreterTestCase>>#functionNode}
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphTreeMorph(660602880))
		selection: 	a MorphTreeMorphMultipleSelection
		announcer: 	an Announcer
		rootItems: 	nil
		autoMultiSelection: 	nil
		headerLabel: 	nil
		multiSelection: 	nil
		wrapBlockOrSelector: 	nil
		isCheckList: 	nil
		enabled: 	true
		model: 	a PackageTreeNautilusUI


MorphTreeMorph>>acceptDroppingMorph:event:
	Receiver: a MorphTreeMorph(660602880)
	Arguments and temporary variables: 
		aMorph: 	a TransferMorph(867434496)
		evt: 	[(477@230.0) dropEvent nil]
	Receiver's instance variables: 
		bounds: 	(429.0@77.0) corner: (637.0@303.0)
		owner: 	a PanelMorph(573308928)
		submorphs: 	an Array(a Morph(200540160) a MorphTreeTransformMorph(930086912))
		fullBounds: 	(429.0@77.0) corner: (638.0@303.0)
		color: 	Color white
		extension: 	a MorphExtension (524288) [other:  (announcer -> an Announcer) (drop...etc...
		borderWidth: 	0
		borderColor: 	Color gray
		model: 	a PackageTreeModel
		scrollBar: 	a ScrollBar(715128832)
		scroller: 	a MorphTreeTransformMorph(930086912)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(328466432)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	NodeMorph(Node(a RPackage(Mini-PrettyPrinter)))
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(769392640)
		notExpandedToggleImage: 	an ImageMorph(952369152)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(200540160)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color white. Color white}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	153.0
		enabled: 	true


MorphTreeMorph(Morph)>>handleDropMorph:
	Receiver: a MorphTreeMorph(660602880)
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
		aMorph: 	a TransferMorph(867434496)
		localPt: 	(591.0@221.5)
	Receiver's instance variables: 
		bounds: 	(429.0@77.0) corner: (637.0@303.0)
		owner: 	a PanelMorph(573308928)
		submorphs: 	an Array(a Morph(200540160) a MorphTreeTransformMorph(930086912))
		fullBounds: 	(429.0@77.0) corner: (638.0@303.0)
		color: 	Color white
		extension: 	a MorphExtension (524288) [other:  (announcer -> an Announcer) (drop...etc...
		borderWidth: 	0
		borderColor: 	Color gray
		model: 	a PackageTreeModel
		scrollBar: 	a ScrollBar(715128832)
		scroller: 	a MorphTreeTransformMorph(930086912)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(328466432)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	NodeMorph(Node(a RPackage(Mini-PrettyPrinter)))
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(769392640)
		notExpandedToggleImage: 	an ImageMorph(952369152)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(200540160)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color white. Color white}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	153.0
		enabled: 	true


DropEvent>>sentTo:
	Receiver: [(477@230.0) dropEvent nil]
	Arguments and temporary variables: 
		anObject: 	a MorphTreeMorph(660602880)
	Receiver's instance variables: 
		timeStamp: 	nil
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		position: 	(477@230.0)
		contents: 	a TransferMorph(867434496)
		wasHandled: 	true


MorphTreeMorph(Morph)>>handleEvent:
	Receiver: a MorphTreeMorph(660602880)
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
	Receiver's instance variables: 
		bounds: 	(429.0@77.0) corner: (637.0@303.0)
		owner: 	a PanelMorph(573308928)
		submorphs: 	an Array(a Morph(200540160) a MorphTreeTransformMorph(930086912))
		fullBounds: 	(429.0@77.0) corner: (638.0@303.0)
		color: 	Color white
		extension: 	a MorphExtension (524288) [other:  (announcer -> an Announcer) (drop...etc...
		borderWidth: 	0
		borderColor: 	Color gray
		model: 	a PackageTreeModel
		scrollBar: 	a ScrollBar(715128832)
		scroller: 	a MorphTreeTransformMorph(930086912)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(328466432)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	NodeMorph(Node(a RPackage(Mini-PrettyPrinter)))
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(769392640)
		notExpandedToggleImage: 	an ImageMorph(952369152)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(200540160)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color white. Color white}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	153.0
		enabled: 	true


MorphicEventDispatcher>>dispatchDropEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
		aMorph: 	a MorphTreeMorph(660602880)
		inside: 	true
		index: 	3
		morphs: 	an Array(a Morph(200540160) a MorphTreeTransformMorph(930086912))
		child: 	a MorphTreeTransformMorph(930086912)
		localEvt: 	[(477@230.0) dropEvent nil]
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleDropMorph:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
	Receiver's instance variables: 
		morph: 	nil


DropEvent>>sentTo:
	Receiver: [(477@230.0) dropEvent nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	nil
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		position: 	(477@230.0)
		contents: 	a TransferMorph(867434496)
		wasHandled: 	true


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
		aMorph: 	a MorphTreeMorph(660602880)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
		aMorph: 	a MorphTreeMorph(660602880)
	Receiver's instance variables: 
		morph: 	nil


MorphTreeMorph(Morph)>>processEvent:using:
	Receiver: a MorphTreeMorph(660602880)
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(429.0@77.0) corner: (637.0@303.0)
		owner: 	a PanelMorph(573308928)
		submorphs: 	an Array(a Morph(200540160) a MorphTreeTransformMorph(930086912))
		fullBounds: 	(429.0@77.0) corner: (638.0@303.0)
		color: 	Color white
		extension: 	a MorphExtension (524288) [other:  (announcer -> an Announcer) (drop...etc...
		borderWidth: 	0
		borderColor: 	Color gray
		model: 	a PackageTreeModel
		scrollBar: 	a ScrollBar(715128832)
		scroller: 	a MorphTreeTransformMorph(930086912)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(328466432)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	NodeMorph(Node(a RPackage(Mini-PrettyPrinter)))
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(769392640)
		notExpandedToggleImage: 	an ImageMorph(952369152)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(200540160)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color white. Color white}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	153.0
		enabled: 	true


MorphicEventDispatcher>>dispatchDropEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
		aMorph: 	a PanelMorph(573308928)
		inside: 	false
		index: 	3
		morphs: 	an Array(a PanelMorph(63963136) a SearchMorph(329777152) a MorphTreeMor...etc...
		child: 	a MorphTreeMorph(660602880)
		localEvt: 	[(477@230.0) dropEvent nil]
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleDropMorph:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
	Receiver's instance variables: 
		morph: 	nil


DropEvent>>sentTo:
	Receiver: [(477@230.0) dropEvent nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	nil
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		position: 	(477@230.0)
		contents: 	a TransferMorph(867434496)
		wasHandled: 	false


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
		aMorph: 	a PanelMorph(573308928)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
		aMorph: 	a PanelMorph(573308928)
	Receiver's instance variables: 
		morph: 	nil


PanelMorph(Morph)>>processEvent:using:
	Receiver: a PanelMorph(573308928)
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(429.0@47.0) corner: (637.0@333.0)
		owner: 	a NautilusWindow(456916992)
		submorphs: 	an Array(a PanelMorph(63963136) a SearchMorph(329777152) a MorphTree...etc...
		fullBounds: 	(429@47) corner: (637@333)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (652214272) [sticky]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...


MorphicEventDispatcher>>dispatchDropEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
		aMorph: 	a NautilusWindow(456916992)
		inside: 	false
		index: 	10
		morphs: 	an Array(a WindowEdgeGripMorph(431226880) a WindowEdgeGripMorph(2715811...etc...
		child: 	a PanelMorph(573308928)
		localEvt: 	[(477@230.0) dropEvent nil]
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleDropMorph:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
	Receiver's instance variables: 
		morph: 	nil


DropEvent>>sentTo:
	Receiver: [(477@230.0) dropEvent nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	nil
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		position: 	(477@230.0)
		contents: 	a TransferMorph(867434496)
		wasHandled: 	false


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
		aMorph: 	a NautilusWindow(456916992)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
		aMorph: 	a NautilusWindow(456916992)
	Receiver's instance variables: 
		morph: 	nil


NautilusWindow(Morph)>>processEvent:using:
	Receiver: a NautilusWindow(456916992)
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@19.0) corner: (1274.0@619.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a WindowEdgeGripMorph(431226880) a WindowEdgeGripMorph(2715...etc...
		fullBounds: 	(424@19) corner: (1274@619)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (481820672) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	a PackageTreeNautilusUI
		labelString: 	'MiniInterpreterTestCase>>#functionNode'
		stripes: 	an Array(a Morph(664272896) a Morph(677642240))
		label: 	a LabelMorph(643563520)'MiniInterpreterTestCase>>#functionNode'
		closeBox: 	a MultistateButtonMorph(894959616)
		collapseBox: 	a MultistateButtonMorph(168820736)
		activeOnlyOnTop: 	true
		paneMorphs: 	an Array(a PanelMorph(311427072) a DropListMorph(485752832) a Plugg...etc...
		collapsedFrame: 	nil
		fullFrame: 	(424.0@19.0) corner: (1274.0@619.0)
		isCollapsed: 	false
		menuBox: 	a MultistateButtonMorph(841220096)
		mustNotClose: 	false
		labelWidgetAllowance: 	133
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(706215936)
		expandBox: 	a MultistateButtonMorph(358875136)
		embeddable: 	nil
		announcer: 	an Announcer
		menuBuilder: 	nil
		isResizeable: 	true


MorphicEventDispatcher>>dispatchDropEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
		aMorph: 	a WorldMorph(511705088) [world]
		inside: 	false
		index: 	2
		morphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(456916992) a System...etc...
		child: 	a NautilusWindow(456916992)
		localEvt: 	[(477@230.0) dropEvent nil]
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleDropMorph:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
	Receiver's instance variables: 
		morph: 	nil


DropEvent>>sentTo:
	Receiver: [(477@230.0) dropEvent nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	nil
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		position: 	(477@230.0)
		contents: 	a TransferMorph(867434496)
		wasHandled: 	false


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
		aMorph: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
		aMorph: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		morph: 	nil


WorldMorph(Morph)>>processEvent:using:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(456916992) a Sys...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(Morph)>>processEvent:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1350@689)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(456916992) a Sys...etc...
		fullBounds: 	(0@0) corner: (1350@689)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(477@230.0) dropEvent nil]
		focusHolder: 	nil
		aBlock: 	[ nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(479@228.0) corner: (495@244.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(479@228.0) corner: (495@244.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	a MorphTreeMorph(660602880)
		keyboardFocus: 	a TransferMorph(867434496)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(479@228) mouseOver nil nil]
		targetOffset: 	(-4.0@ -21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	false
		savedPatch: 	nil
		lastEventBuffer: 	#(1 142883676 478 229 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
CompiledMethod(Object)>>doesNotUnderstand: #theNonMetaClass
[ :aClass | 
self showGroups
	ifTrue: [ 
		receiver addClasses: {aClass}.
		ActiveHand shiftPressed
			ifFalse: [ 
				self selectedGroup removeClass: aClass.
				self updateClassView ] ]
	ifFalse: [ 
		receiver addClass: aClass theNonMetaClass.
		ActiveHand shiftPressed
			ifTrue: [ 
				self selectedClass: nil.
				self updateClassView ]
			ifFalse: [ 
				self selectedPackage: receiver.
				self selectedClass: aClass.
				self updatePackageGroupAndClassList ] ] ] in PackageTreeNautilusUI(AbstractNautilusUI)>>dropInAPackage:into:
Array(SequenceableCollection)>>do:
PackageTreeNautilusUI(AbstractNautilusUI)>>dropInAPackage:into:
PackageTreeModel>>acceptDroppingMorph:event:inMorph:
MorphTreeMorph>>acceptDroppingMorph:event:
MorphTreeMorph(Morph)>>handleDropMorph:
DropEvent>>sentTo:
MorphTreeMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDropEvent:with:
MorphicEventDispatcher>>handleDropMorph:
DropEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MorphTreeMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDropEvent:with:
MorphicEventDispatcher>>handleDropMorph:
DropEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDropEvent:with:
MorphicEventDispatcher>>handleDropMorph:
DropEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
NautilusWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDropEvent:with:
MorphicEventDispatcher>>handleDropMorph:
DropEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendEvent:focus:
HandMorph>>dropMorph:event:
[ :m | 
"Drop back to front to maintain z-order"
self dropMorph: m event: anEvent ] in HandMorph>>dropMorphs:
Array(SequenceableCollection)>>reverseDo:
HandMorph(Morph)>>submorphsReverseDo:
HandMorph>>dropMorphs:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniInterpreter>>visitMiniFunctionNode:
30 November 2015 11:42:45.554106 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniInterpreter(Object)>>doesNotUnderstand: #visitMiniFunctionNode:
	Receiver: a MiniInterpreter
	Arguments and temporary variables: 
		aMessage: 	visitMiniFunctionNode: a MiniFunctionNode
		exception: 	MessageNotUnderstood: MiniInterpreter>>visitMiniFunctionNode:
		resumeValue: 	nil
	Receiver's instance variables: 
		environment: 	a MiniEnvironment


MiniFunctionNode>>accept:
	Receiver: a MiniFunctionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniInterpreter
	Receiver's instance variables: 
		heading: 	a MiniFunctionHeadingNode
		statements: 	a MiniAssignmentNode


MiniInterpreterTestCase>>testFunctionDeclaration
	Receiver: MiniInterpreterTestCase>>#testFunctionDeclaration
	Arguments and temporary variables: 
		daFunk: 	a MiniFunctionNode
	Receiver's instance variables: 
		testSelector: 	#testFunctionDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase(TestCase)>>performTest
	Receiver: MiniInterpreterTestCase>>#testFunctionDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testFunctionDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testFunctionDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testFunctionDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testFunctionDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testFunctionDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testFunctionDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testFunctionDeclaration
		expectedFails: 	#()
		visitor: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testFunctionDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testFunctionDeclaration
		expectedFails: 	#()
		visitor: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniInterpreterTestCase>>#testFunctionDeclaration
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testFunctionDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniInterpreterTestCase>>#testFunctionDeclaration)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniInterpreterTestCase>>#testFunctionDeclaration nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testFunctionDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testFunctionDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testFunctionDeclaration MiniInter...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testFunctionDeclaration
		lastUpdate: 	3626354559
		result: 	9 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	9 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testFunctionDeclaration MiniInter...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testFunctionDeclaration
		lastUpdate: 	3626354559
		result: 	9 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testFunctionDeclaration MiniInter...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testFunctionDeclaration
		lastUpdate: 	3626354559
		result: 	9 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testFunctionDeclaration MiniInter...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testFunctionDeclaration
		lastUpdate: 	3626354559
		result: 	9 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniInterpreterTestCase>>#testFunctionDeclaration
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testFunctionDeclaration MiniInter...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testFunctionDeclaration
		lastUpdate: 	3626354559
		result: 	9 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testFunctionDeclaration MiniInter...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testFunctionDeclaration
		lastUpdate: 	3626354559
		result: 	9 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testFunctionDeclaration' 'MiniInterpreterTes...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(420@361) mouseUp 143318660 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testFunctionDeclaration' 'MiniInterpreterTes...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(420@361) mouseUp 143318660 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testFunctionDeclaration' 'MiniInterpreterTes...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(420@361) mouseUp 143318660 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testFunctionDeclaration' 'MiniInterpreterTes...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(420@361) mouseUp 143318660 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	143318660
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(420@361)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(420@361) mouseUp 143318660 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testFunctionDeclaration' 'MiniInterpreterTes...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(420@361) mouseUp 143318660 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(420@361) mouseUp 143318660 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(420@361) mouseUp 143318660 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(420@361) mouseUp 143318660 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	143318660
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(420@361)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(420@361) mouseUp 143318660 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(420@361) mouseUp 143318660 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(420@361) mouseUp 143318660 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testFunctionDeclaration' 'MiniInterpreterTes...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(420@361) mouseUp 143318660 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testFunctionDeclaration' 'MiniInterpreterTes...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(420@361) mouseUp 143318660 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testFunctionDeclaration' 'MiniInterpreterTes...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil



--- The full stack ---
MiniInterpreter(Object)>>doesNotUnderstand: #visitMiniFunctionNode:
MiniFunctionNode>>accept:
MiniInterpreterTestCase>>testFunctionDeclaration
MiniInterpreterTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MiniUndeclaredError: No bindings in the void scope.
30 November 2015 11:45:50.924106 am

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniVoidScope>>bindingFor:
	Receiver: a MiniVoidScope
	Arguments and temporary variables: 
		aName: 	'colton'
	Receiver's instance variables: 
		outerScope: 	a MiniScope
		bindings: 	a Dictionary()


[ self outerScope bindingFor: aName ] in MiniScope>>bindingFor:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aName: 	'colton'
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary()


Dictionary>>at:ifAbsent:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		key: 	'colton'
		aBlock: 	[ self outerScope bindingFor: aName ]
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


MiniScope>>bindingFor:
	Receiver: a MiniScope
	Arguments and temporary variables: 
		aName: 	'colton'
	Receiver's instance variables: 
		outerScope: 	a MiniVoidScope
		bindings: 	a Dictionary()


MiniEnvironment>>procedureNamed:
	Receiver: a MiniEnvironment
	Arguments and temporary variables: 
		aName: 	'colton'
	Receiver's instance variables: 
		variableScope: 	a MiniScope
		procedureScope: 	a MiniScope


MiniInterpreterTestCase>>testFunctionDeclaration
	Receiver: MiniInterpreterTestCase>>#testFunctionDeclaration
	Arguments and temporary variables: 
		daFunk: 	a MiniFunctionNode
	Receiver's instance variables: 
		testSelector: 	#testFunctionDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase(TestCase)>>performTest
	Receiver: MiniInterpreterTestCase>>#testFunctionDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testFunctionDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testFunctionDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testFunctionDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testFunctionDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testFunctionDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testFunctionDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testFunctionDeclaration
		expectedFails: 	#()
		visitor: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testFunctionDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testFunctionDeclaration
		expectedFails: 	#()
		visitor: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniInterpreterTestCase>>#testFunctionDeclaration
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testFunctionDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniInterpreterTestCase>>#testFunctionDeclaration)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniInterpreterTestCase>>#testFunctionDeclaration nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testFunctionDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testFunctionDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testFunctionDeclaration MiniInter...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testFunctionDeclaration
		lastUpdate: 	3626354749
		result: 	9 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	9 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 2 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testFunctionDeclaration MiniInter...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testFunctionDeclaration
		lastUpdate: 	3626354749
		result: 	9 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testFunctionDeclaration MiniInter...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testFunctionDeclaration
		lastUpdate: 	3626354749
		result: 	9 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testFunctionDeclaration MiniInter...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testFunctionDeclaration
		lastUpdate: 	3626354749
		result: 	9 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniInterpreterTestCase>>#testFunctionDeclaration
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testFunctionDeclaration MiniInter...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testFunctionDeclaration
		lastUpdate: 	3626354749
		result: 	9 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set(MiniInterpreterTestCase)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testFunctionDeclaration MiniInter...etc...
		errorSelected: 	MiniInterpreterTestCase>>#testFunctionDeclaration
		lastUpdate: 	3626354749
		result: 	9 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testFunctionDeclaration' 'MiniInterpreterTes...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(637@364) mouseUp 143504066 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testFunctionDeclaration' 'MiniInterpreterTes...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(637@364) mouseUp 143504066 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testFunctionDeclaration' 'MiniInterpreterTes...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(637@364) mouseUp 143504066 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testFunctionDeclaration' 'MiniInterpreterTes...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(637@364) mouseUp 143504066 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	143504066
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(637@364)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(637@364) mouseUp 143504066 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testFunctionDeclaration' 'MiniInterpreterTes...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(637@364) mouseUp 143504066 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(637@364) mouseUp 143504066 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(637@364) mouseUp 143504066 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(637@364) mouseUp 143504066 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	143504066
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(637@364)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(637@364) mouseUp 143504066 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(637@364) mouseUp 143504066 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil



--- The full stack ---
MiniVoidScope>>bindingFor:
[ self outerScope bindingFor: aName ] in MiniScope>>bindingFor:
Dictionary>>at:ifAbsent:
MiniScope>>bindingFor:
MiniEnvironment>>procedureNamed:
MiniInterpreterTestCase>>testFunctionDeclaration
MiniInterpreterTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniEnvironment>>hasVariableNamed:
30 November 2015 1:02:39.609891 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniEnvironment(Object)>>doesNotUnderstand: #hasVariableNamed:
	Receiver: a MiniEnvironment
	Arguments and temporary variables: 
		aMessage: 	hasVariableNamed: 'earl'
		exception: 	MessageNotUnderstood: MiniEnvironment>>hasVariableNamed:
		resumeValue: 	nil
	Receiver's instance variables: 
		variableScope: 	a MiniScope
		procedureScope: 	a MiniScope


MiniInterpreterTestCase>>testVariableDeclaration
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


MiniInterpreterTestCase(TestCase)>>performTest
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>runCase
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	nil
		visitor: 	a MiniInterpreter


[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	#()
		visitor: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MiniInterpreterTestCase(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


MiniInterpreterTestCase(TestCase)>>debug
	Receiver: MiniInterpreterTestCase>>#testVariableDeclaration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableDeclaration
		expectedFails: 	#()
		visitor: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(MiniInterpreterTestCase>>#testVariableDeclaration)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626359357
		result: 	10 run, 9 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	10 run, 9 passes, 0 skipped, 0 expected failures, 0 failures, 1 erro...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626359357
		result: 	10 run, 9 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626359357
		result: 	10 run, 9 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626359357
		result: 	10 run, 9 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	MiniInterpreterTestCase>>#testVariableDeclaration
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626359357
		result: 	10 run, 9 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(149159936) a SearchMorph(807403520...etc...
		categories: 	#(#'Mini-Environment-Tests' #'Mini-PrettyPrinter' #'Mini-Interprete...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'Mini-Interpreter')
		classes: 	{MiniInterpreterTestCase}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(MiniInterpreterTestCase>>#testVariableDeclaration)
		errorSelected: 	MiniInterpreterTestCase>>#testVariableDeclaration
		lastUpdate: 	3626359357
		result: 	10 run, 9 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		event: 	[(470@354) mouseUp 148112738 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		evt: 	[(470@354) mouseUp 148112738 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(470@354) mouseUp 148112738 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(470@354) mouseUp 148112738 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		timeStamp: 	148112738
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(470@354)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(470@354) mouseUp 148112738 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(470@354) mouseUp 148112738 nil]
		aMorph: 	a PluggableListMorph(657719296)
		localEvt: 	[(470@354) mouseUp 148112738 nil]
		index: 	2
		child: 	a TransformMorph(772538368)
		morphs: 	an Array(a TransformMorph(772538368))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(470@354) mouseUp 148112738 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(470@354) mouseUp 148112738 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	148112738
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(470@354)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(470@354) mouseUp 148112738 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(470@354) mouseUp 148112738 nil]
		aMorph: 	a PluggableListMorph(657719296)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(470@354) mouseUp 148112738 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(470@354) mouseUp 148112738 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(657719296)
	Arguments and temporary variables: 
		anEvent: 	[(470@354) mouseUp 148112738 nil]
	Receiver's instance variables: 
		bounds: 	(388.0@352.0) corner: (729.0@551.0)
		owner: 	a SystemWindow(149159936)
		submorphs: 	an Array(a TransformMorph(772538368))
		fullBounds: 	(388@352) corner: (729@551)
		color: 	Color white
		extension: 	a MorphExtension (922746880) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(690225152)
		scroller: 	a TransformMorph(772538368)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(207093760)
		list: 	#('MiniInterpreterTestCase>>#testVariableDeclaration')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(798490624)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(470@354) mouseUp 148112738 nil]
		focusHolder: 	a PluggableListMorph(657719296)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(470@356.0) corner: (486@372.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(470@356.0) corner: (486@372.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(657719296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(470@356) mouseOver nil nil]
		targetOffset: 	(82.0@2.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 148113160 470 356 0 0 0 1)
		lastKeyScanCode: 	216
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
MiniEnvironment(Object)>>doesNotUnderstand: #hasVariableNamed:
MiniInterpreterTestCase>>testVariableDeclaration
MiniInterpreterTestCase(TestCase)>>performTest
[ 
self setUp.
self performTest ] in MiniInterpreterTestCase(TestCase)>>runCase
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in MiniInterpreterTestCase(TestCase)>>debug
BlockClosure>>ensure:
MiniInterpreterTestCase(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "adaptToString:andSend:" is nil
30 November 2015 1:24:51.248891 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #adaptToString:andSend:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	adaptToString: #Mini andSend: #-
		exception: 	MessageNotUnderstood: receiver of "adaptToString:andSend:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

ByteSymbol(String)>>-
	Receiver: #Mini
	Arguments and temporary variables: 
		arg: 	nil
	Receiver's instance variables: 
#Mini

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Object
		subclass: #Mini - CTranslator
		instanceVariableNames: 's...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler(AbstractCompiler)>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'Object subclass: #Mini-CTranslator
		instanceVariableNames: ''st...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	^ Object
		subclass: #Mini - CTranslator
		instanceVariableNames: 's...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


PackageTreeNautilusUI class(Behavior)>>evaluate:
	Receiver: PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'Object subclass: #Mini-CTranslator
		instanceVariableNames: ''stream ...etc...
	Receiver's instance variables: 
		superclass: 	NautilusUI
		methodDict: 	a MethodDictionary(#addClassCategory->PackageTreeNautilusUI>>#addCl...etc...
		format: 	180
		layout: 	a FixedLayout
		instanceVariables: 	#(#packagePattern #searchWidget #packagePatternString)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PackageTreeNautilusUI
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Nautilus-Tree'
		traitComposition: 	{}
		localSelectors: 	nil


PackageTreeNautilusUI(AbstractTool)>>addClassIn:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aPackage: 	a RPackage(Mini-CTranslator)
		classSymbol: 	#NameOfSubclass
		systemCategory: 	#'Mini-CTranslator'
		proposedSuperclass: 	Object
		classDefinition: 	'Object subclass: #Mini-CTranslator
		instanceVariableNames: '...etc...
		newClass: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(456916992)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(708050944)
		sourceCodePanel: 	a PanelMorph(592445440)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(311427072)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(708050944)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(24903680)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(329777152)
		packagePatternString: 	'mini'


PackageTreeNautilusUI>>addClassIn:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aPackage: 	a PackageTreePackageSelection
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(456916992)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(708050944)
		sourceCodePanel: 	a PanelMorph(592445440)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(311427072)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(708050944)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(24903680)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(329777152)
		packagePatternString: 	'mini'


PackageTreeNautilusUI(AbstractNautilusUI)>>addClass
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		package: 	a PackageTreePackageSelection
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(456916992)
		hierarchyClass: 	nil
		cachedHierarchy: 	nil
		sourceTextArea: 	a PluggableTextMorphWithLimits(708050944)
		sourceCodePanel: 	a PanelMorph(592445440)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(311427072)
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(708050944)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(24903680)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageTreeWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(329777152)
		packagePatternString: 	'mini'


[ target addClass ] in AbstractNautilusUI class>>classesFixMenu:
	Receiver: AbstractNautilusUI
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		superclass: 	AbstractTool
		methodDict: 	a MethodDictionary(size 381)
		format: 	166
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #window #hierarchyClass #cachedHierarchy #sourceTex...etc...
		organization: 	a ClassOrganization
		subclasses: 	{NautilusUI}
		name: 	#AbstractNautilusUI
		classPool: 	a Dictionary(#ClassesIconsCache->a WeakIdentityKeyDictionary(MiniEnv...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Nautilus
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ target addClass ]
	Arguments and temporary variables: 
		anArg: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>classesFixMenu:
		startpc: 	251
		numArgs: 	0


[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(870580224)'Add Class...'
	Arguments and temporary variables: 
		evt: 	[(740@145) mouseUp 149430551 nil]
		w: 	a WorldMorph(511705088) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(681.0@141.0) corner: (805.0@158.0)
		owner: 	a MenuMorph(263979008)
		submorphs: 	#()
		fullBounds: 	(681.0@141.0) corner: (805.0@158.0)
		color: 	Color black
		extension: 	a MorphExtension (893386752)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'Add Class...'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ target addClass ]
		selector: 	#cull:
		arguments: 	an Array(a PackageTreeNautilusUI)
		icon: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'n, c'


BlockClosure>>ensure:
	Receiver: [ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	134
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(s...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(870580224)'Add Class...'
	Arguments and temporary variables: 
		evt: 	[(740@145) mouseUp 149430551 nil]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(681.0@141.0) corner: (805.0@158.0)
		owner: 	a MenuMorph(263979008)
		submorphs: 	#()
		fullBounds: 	(681.0@141.0) corner: (805.0@158.0)
		color: 	Color black
		extension: 	a MorphExtension (893386752)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'Add Class...'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ target addClass ]
		selector: 	#cull:
		arguments: 	an Array(a PackageTreeNautilusUI)
		icon: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'n, c'


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(870580224)'Add Class...'
	Arguments and temporary variables: 
		evt: 	[(740@145) mouseUp 149430551 nil]
	Receiver's instance variables: 
		bounds: 	(681.0@141.0) corner: (805.0@158.0)
		owner: 	a MenuMorph(263979008)
		submorphs: 	#()
		fullBounds: 	(681.0@141.0) corner: (805.0@158.0)
		color: 	Color black
		extension: 	a MorphExtension (893386752)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'Add Class...'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ target addClass ]
		selector: 	#cull:
		arguments: 	an Array(a PackageTreeNautilusUI)
		icon: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'n, c'


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(870580224)'Add Class...'
	Arguments and temporary variables: 
		anEvent: 	[(740@145) mouseUp 149430551 nil]
	Receiver's instance variables: 
		bounds: 	(681.0@141.0) corner: (805.0@158.0)
		owner: 	a MenuMorph(263979008)
		submorphs: 	#()
		fullBounds: 	(681.0@141.0) corner: (805.0@158.0)
		color: 	Color black
		extension: 	a MorphExtension (893386752)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'Add Class...'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ target addClass ]
		selector: 	#cull:
		arguments: 	an Array(a PackageTreeNautilusUI)
		icon: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'n, c'


MouseButtonEvent>>sentTo:
	Receiver: [(740@145) mouseUp 149430551 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(870580224)'Add Class...'
	Receiver's instance variables: 
		timeStamp: 	149430551
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(740@145)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(870580224)'Add Class...'
	Arguments and temporary variables: 
		anEvent: 	[(740@145) mouseUp 149430551 nil]
	Receiver's instance variables: 
		bounds: 	(681.0@141.0) corner: (805.0@158.0)
		owner: 	a MenuMorph(263979008)
		submorphs: 	#()
		fullBounds: 	(681.0@141.0) corner: (805.0@158.0)
		color: 	Color black
		extension: 	a MorphExtension (893386752)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'Add Class...'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ target addClass ]
		selector: 	#cull:
		arguments: 	an Array(a PackageTreeNautilusUI)
		icon: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'n, c'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(740@145) mouseUp 149430551 nil]
		aMorph: 	a ToggleMenuItemMorph(870580224)'Add Class...'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(740@145) mouseUp 149430551 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(740@145) mouseUp 149430551 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	149430551
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(740@145)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(740@145) mouseUp 149430551 nil]
		aMorph: 	a ToggleMenuItemMorph(870580224)'Add Class...'
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(740@145) mouseUp 149430551 nil]
		aMorph: 	a ToggleMenuItemMorph(870580224)'Add Class...'
	Receiver's instance variables: 
		morph: 	nil


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(870580224)'Add Class...'
	Arguments and temporary variables: 
		anEvent: 	[(740@145) mouseUp 149430551 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(681.0@141.0) corner: (805.0@158.0)
		owner: 	a MenuMorph(263979008)
		submorphs: 	#()
		fullBounds: 	(681.0@141.0) corner: (805.0@158.0)
		color: 	Color black
		extension: 	a MorphExtension (893386752)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'Add Class...'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ target addClass ]
		selector: 	#cull:
		arguments: 	an Array(a PackageTreeNautilusUI)
		icon: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'n, c'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(740@145) mouseUp 149430551 nil]
		aMorph: 	a MenuMorph(263979008)
		localEvt: 	[(740@145) mouseUp 149430551 nil]
		index: 	3
		child: 	a ToggleMenuItemMorph(870580224)'Add Class...'
		morphs: 	an Array(a ToggleMenuItemMorph(653262848)'Find Method...' a ToggleMenuI...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(740@145) mouseUp 149430551 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(740@145) mouseUp 149430551 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	149430551
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(740@145)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(740@145) mouseUp 149430551 nil]
		aMorph: 	a MenuMorph(263979008)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(740@145) mouseUp 149430551 nil]
		aMorph: 	a MenuMorph(263979008)
	Receiver's instance variables: 
		morph: 	nil


MenuMorph(Morph)>>processEvent:using:
	Receiver: a MenuMorph(263979008)
	Arguments and temporary variables: 
		anEvent: 	[(740@145) mouseUp 149430551 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(676.0@100.0) corner: (810.0@202.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(653262848)'Find Method...' a ToggleMe...etc...
		fullBounds: 	(676.0@100.0) corner: (810.0@202.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (300941312) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a ClassWidget
		selectedItem: 	a ToggleMenuItemMorph(870580224)'Add Class...'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(653262848)'Find Method......etc...
		basicColor: 	nil


MenuMorph(Morph)>>processEvent:
	Receiver: a MenuMorph(263979008)
	Arguments and temporary variables: 
		anEvent: 	[(740@145) mouseUp 149430551 nil]
	Receiver's instance variables: 
		bounds: 	(676.0@100.0) corner: (810.0@202.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(653262848)'Find Method...' a ToggleMe...etc...
		fullBounds: 	(676.0@100.0) corner: (810.0@202.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (300941312) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a ClassWidget
		selectedItem: 	a ToggleMenuItemMorph(870580224)'Add Class...'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(653262848)'Find Method......etc...
		basicColor: 	nil


MenuMorph>>handleFocusEvent:
	Receiver: a MenuMorph(263979008)
	Arguments and temporary variables: 
		evt: 	[(740@145) mouseUp 149430551 nil]
	Receiver's instance variables: 
		bounds: 	(676.0@100.0) corner: (810.0@202.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(653262848)'Find Method...' a ToggleMe...etc...
		fullBounds: 	(676.0@100.0) corner: (810.0@202.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (300941312) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a ClassWidget
		selectedItem: 	a ToggleMenuItemMorph(870580224)'Add Class...'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(653262848)'Find Method......etc...
		basicColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(740@145) mouseUp 149430551 nil]
		focusHolder: 	a MenuMorph(263979008)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(663@284.0) corner: (679@300.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(663@284.0) corner: (679@300.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(663@284) mouseOver nil nil]
		targetOffset: 	(35.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 149444863 663 284 0 0 0 1)
		lastKeyScanCode: 	76
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(740@145) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1366@705)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(456916992) a Sys...etc...
		fullBounds: 	(0@0) corner: (1366@705)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(740@145) mouseUp 149430551 nil]
		focusHolder: 	a MenuMorph(263979008)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(638@279.0) corner: (654@295.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(638@279.0) corner: (654@295.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(638@279) mouseOver nil nil]
		targetOffset: 	(35.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 149444894 638 279 0 0 0 1)
		lastKeyScanCode: 	76
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #adaptToString:andSend:
ByteSymbol(String)>>-
UndefinedObject>>DoIt
OpalCompiler>>evaluate
OpalCompiler(AbstractCompiler)>>evaluate:
PackageTreeNautilusUI class(Behavior)>>evaluate:
PackageTreeNautilusUI(AbstractTool)>>addClassIn:
PackageTreeNautilusUI>>addClassIn:
PackageTreeNautilusUI(AbstractNautilusUI)>>addClass
[ target addClass ] in AbstractNautilusUI class>>classesFixMenu:
BlockClosure>>cull:
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MiniCTranslator>>visitMiniProcedureSectionNode:
30 November 2015 1:37:36.337891 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

MiniCTranslator(Object)>>doesNotUnderstand: #visitMiniProcedureSectionNode:
	Receiver: a MiniCTranslator
	Arguments and temporary variables: 
		aMessage: 	visitMiniProcedureSectionNode: a MiniProcedureSectionNode
		exception: 	MessageNotUnderstood: MiniCTranslator>>visitMiniProcedureSectionNode...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProcedureSectionNode>>accept:
	Receiver: a MiniProcedureSectionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniCTranslator
	Receiver's instance variables: 
		procedures: 	an OrderedCollection(a MiniFunctionNode)


MiniCTranslator>>visitMiniProgramNode:
	Receiver: a MiniCTranslator
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniCTranslator
	Receiver's instance variables: 
		name: 	<Factorials>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	a MiniCompoundStatementNode


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Factorials>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	a MiniCompoundStatementNode


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniCTranslator new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(107479040)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(107479040)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(169345024)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(107479040)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (967@50)
		owner: 	a TransformWithLayoutMorph(290979840)
		submorphs: 	an Array(a RubPrimarySelectionMorph(55312384) a RubCursor(586940416)...etc...
		fullBounds: 	(0@0) corner: (967@50)
		color: 	Color transparent
		extension: 	a MorphExtension (582483968) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(252706816)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(586940416)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(460587008))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(169345024)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(877920256))(a DropList...etc...
		lastStepTime: 	2109295
		lastStepMessage: 	nil
		lastCycleTime: 	2109284
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(586940416)))
		lastAlarmTime: 	2109295
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1366@705)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(288620544) a St...etc...
		fullBounds: 	(0@0) corner: (1366@705)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(877920256))(a DropList...etc...
		lastStepTime: 	2109295
		lastStepMessage: 	nil
		lastCycleTime: 	2109284
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(586940416)))
		lastAlarmTime: 	2109295
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(877920256))(a DropList...etc...
		lastStepTime: 	2109295
		lastStepMessage: 	nil
		lastCycleTime: 	2109284
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(586940416)))
		lastAlarmTime: 	2109295
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1366@705)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(288620544) a St...etc...
		fullBounds: 	(0@0) corner: (1366@705)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MiniCTranslator(Object)>>doesNotUnderstand: #visitMiniProcedureSectionNode:
MiniProcedureSectionNode>>accept:
MiniCTranslator>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Improper store into indexable object
30 November 2015 1:46:09.472891 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

ByteString(Object)>>error:
	Receiver: '#include <stdio.h>
fact7 = integer
fact9 = integer
integer _factorial( n = integer ) {
if...etc...
	Arguments and temporary variables: 
		aString: 	'Improper store into indexable object'
	Receiver's instance variables: 
'#include <stdio.h>
fact7 = integer
fact9 = integer
integer _factorial( n = integer ) {
if...etc...

ByteString(Object)>>errorImproperStore
	Receiver: '#include <stdio.h>
fact7 = integer
fact9 = integer
integer _factorial( n = integer ) {
if...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
'#include <stdio.h>
fact7 = integer
fact9 = integer
integer _factorial( n = integer ) {
if...etc...

ByteString>>at:put:
	Receiver: '#include <stdio.h>
fact7 = integer
fact9 = integer
integer _factorial( n = integer ) {
if...etc...
	Arguments and temporary variables: 
		index: 	93
		aCharacter: 	'=='
	Receiver's instance variables: 
'#include <stdio.h>
fact7 = integer
fact9 = integer
integer _factorial( n = integer ) {
if...etc...

WriteStream>>nextPut:
	Receiver: a WriteStream
	Arguments and temporary variables: 
		anObject: 	'=='
	Receiver's instance variables: 
		collection: 	'#include <stdio.h>
fact7 = integer
fact9 = integer
integer _factor...etc...
		position: 	93
		readLimit: 	51
		writeLimit: 	1024


MiniCTranslator>>visitMiniRelEqualNode:
	Receiver: a MiniCTranslator
	Arguments and temporary variables: 
		anEqualNode: 	a MiniRelEqualNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniRelEqualNode>>accept:
	Receiver: a MiniRelEqualNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniCTranslator
	Receiver's instance variables: 
a MiniRelEqualNode

MiniCTranslator>>visitMiniRelationNode:
	Receiver: a MiniCTranslator
	Arguments and temporary variables: 
		aRelationNode: 	a MiniRelationNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniRelationNode>>accept:
	Receiver: a MiniRelationNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniCTranslator
	Receiver's instance variables: 
		arg1: 	<n>
		arg2: 	<0>
		relation: 	a MiniRelEqualNode


MiniCTranslator>>visitMiniIfElseNode:
	Receiver: a MiniCTranslator
	Arguments and temporary variables: 
		anIfElseNode: 	a MiniIfElseNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniIfElseNode>>accept:
	Receiver: a MiniIfElseNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniCTranslator
	Receiver's instance variables: 
		condition: 	a MiniRelationNode
		trueStatements: 	a MiniAssignmentNode
		falseStatements: 	a MiniAssignmentNode


MiniCTranslator>>visitMiniFunctionNode:
	Receiver: a MiniCTranslator
	Arguments and temporary variables: 
		aFunctionNode: 	a MiniFunctionNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniFunctionNode>>accept:
	Receiver: a MiniFunctionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniCTranslator
	Receiver's instance variables: 
		heading: 	a MiniFunctionHeadingNode
		statements: 	a MiniIfElseNode


[ :each | 
each accept: self.
self stream tab: self indentLevel ] in MiniCTranslator>>visitMiniProcedureSectionNode:
	Receiver: a MiniCTranslator
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
		each: 	a MiniFunctionNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


OrderedCollection>>do:
	Receiver: an OrderedCollection(a MiniFunctionNode)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each accept: self.
self stream tab: self indentLevel ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a MiniFunctionNode)
		firstIndex: 	1
		lastIndex: 	1


MiniCTranslator>>visitMiniProcedureSectionNode:
	Receiver: a MiniCTranslator
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProcedureSectionNode>>accept:
	Receiver: a MiniProcedureSectionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniCTranslator
	Receiver's instance variables: 
		procedures: 	an OrderedCollection(a MiniFunctionNode)


MiniCTranslator>>visitMiniProgramNode:
	Receiver: a MiniCTranslator
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	0


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniCTranslator
	Receiver's instance variables: 
		name: 	<Factorials>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	a MiniCompoundStatementNode


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Factorials>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	a MiniCompoundStatementNode


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniCTranslator new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(175898624)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(175898624)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(242221056)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(175898624)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (967@50)
		owner: 	a TransformWithLayoutMorph(369885184)
		submorphs: 	an Array(a RubPrimarySelectionMorph(31981568) a RubCursor(661389312)...etc...
		fullBounds: 	(0@0) corner: (967@50)
		color: 	Color transparent
		extension: 	a MorphExtension (662962176) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(331612160)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(661389312)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(153354240))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(242221056)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#browseClassVars 801374208))(...etc...
		lastStepTime: 	2622538
		lastStepMessage: 	nil
		lastCycleTime: 	2622525
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(661389312)))
		lastAlarmTime: 	2622538
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1366@705)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(932708352) a St...etc...
		fullBounds: 	(0@0) corner: (1366@705)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#browseClassVars 801374208))(...etc...
		lastStepTime: 	2622538
		lastStepMessage: 	nil
		lastCycleTime: 	2622525
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(661389312)))
		lastAlarmTime: 	2622538
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#browseClassVars 801374208))(...etc...
		lastStepTime: 	2622538
		lastStepMessage: 	nil
		lastCycleTime: 	2622525
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(661389312)))
		lastAlarmTime: 	2622538
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1366@705)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(932708352) a St...etc...
		fullBounds: 	(0@0) corner: (1366@705)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ByteString(Object)>>error:
ByteString(Object)>>errorImproperStore
ByteString>>at:put:
WriteStream>>nextPut:
MiniCTranslator>>visitMiniRelEqualNode:
MiniRelEqualNode>>accept:
MiniCTranslator>>visitMiniRelationNode:
MiniRelationNode>>accept:
MiniCTranslator>>visitMiniIfElseNode:
MiniIfElseNode>>accept:
MiniCTranslator>>visitMiniFunctionNode:
MiniFunctionNode>>accept:
[ :each | 
each accept: self.
self stream tab: self indentLevel ] in MiniCTranslator>>visitMiniProcedureSectionNode:
OrderedCollection>>do:
MiniCTranslator>>visitMiniProcedureSectionNode:
MiniProcedureSectionNode>>accept:
MiniCTranslator>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Attempt to set the position of a PositionableStream out of bounds
30 November 2015 1:47:08.807891 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40623]

WriteStream(Object)>>error:
	Receiver: a WriteStream
	Arguments and temporary variables: 
		aString: 	'Attempt to set the position of a PositionableStream out of bounds'
	Receiver's instance variables: 
		collection: 	'#include <stdio.h>
fact7 = integer
fact9 = integer
integer _factor...etc...
		position: 	164
		readLimit: 	164
		writeLimit: 	1024


WriteStream(PositionableStream)>>positionError
	Receiver: a WriteStream
	Arguments and temporary variables: 

	Receiver's instance variables: 
		collection: 	'#include <stdio.h>
fact7 = integer
fact9 = integer
integer _factor...etc...
		position: 	164
		readLimit: 	164
		writeLimit: 	1024


WriteStream(PositionableStream)>>position:
	Receiver: a WriteStream
	Arguments and temporary variables: 
		anInteger: 	166
	Receiver's instance variables: 
		collection: 	'#include <stdio.h>
fact7 = integer
fact9 = integer
integer _factor...etc...
		position: 	164
		readLimit: 	164
		writeLimit: 	1024


WriteStream>>position:
	Receiver: a WriteStream
	Arguments and temporary variables: 
		anInteger: 	166
	Receiver's instance variables: 
		collection: 	'#include <stdio.h>
fact7 = integer
fact9 = integer
integer _factor...etc...
		position: 	164
		readLimit: 	164
		writeLimit: 	1024


WriteStream(PositionableStream)>>skip:
	Receiver: a WriteStream
	Arguments and temporary variables: 
		anInteger: 	2
	Receiver's instance variables: 
		collection: 	'#include <stdio.h>
fact7 = integer
fact9 = integer
integer _factor...etc...
		position: 	164
		readLimit: 	164
		writeLimit: 	1024


MiniCTranslator>>visitMiniProcedureSectionNode:
	Receiver: a MiniCTranslator
	Arguments and temporary variables: 
		aProcSectionNode: 	a MiniProcedureSectionNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	-2


MiniProcedureSectionNode>>accept:
	Receiver: a MiniProcedureSectionNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniCTranslator
	Receiver's instance variables: 
		procedures: 	an OrderedCollection(a MiniFunctionNode)


MiniCTranslator>>visitMiniProgramNode:
	Receiver: a MiniCTranslator
	Arguments and temporary variables: 
		aProgramNode: 	a MiniProgramNode
	Receiver's instance variables: 
		stream: 	a WriteStream
		indentLevel: 	-2


MiniProgramNode>>accept:
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 
		aVisitor: 	a MiniCTranslator
	Receiver's instance variables: 
		name: 	<Factorials>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	a MiniCompoundStatementNode


MiniProgramNode>>DoIt
	Receiver: a MiniProgramNode
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	<Factorials>
		varSection: 	a MiniVariableSectionNode
		procSection: 	a MiniProcedureSectionNode
		main: 	a MiniCompoundStatementNode


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self accept: MiniCTranslator new
		source: 	a ReadStream
		context: 	nil
		receiver: 	a MiniProgramNode
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a MiniProgramNode
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(175898624)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(175898624)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(242221056)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(175898624)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (967@50)
		owner: 	a TransformWithLayoutMorph(369885184)
		submorphs: 	an Array(a RubPrimarySelectionMorph(31981568) a RubCursor(661389312)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (662962176) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(331612160)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(661389312)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(707264512))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(242221056)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(485752832))(a DropList...etc...
		lastStepTime: 	2681895
		lastStepMessage: 	nil
		lastCycleTime: 	2681895
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(661389312)))
		lastAlarmTime: 	2681895
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1366@705)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(932708352) a St...etc...
		fullBounds: 	(0@0) corner: (1366@705)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(485752832))(a DropList...etc...
		lastStepTime: 	2681895
		lastStepMessage: 	nil
		lastCycleTime: 	2681895
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(661389312)))
		lastAlarmTime: 	2681895
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1366@705)
		canvas: 	a FormCanvas on: DisplayScreen(1366x705x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(485752832))(a DropList...etc...
		lastStepTime: 	2681895
		lastStepMessage: 	nil
		lastCycleTime: 	2681895
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(661389312)))
		lastAlarmTime: 	2681895
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1366@705)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(932708352) a St...etc...
		fullBounds: 	(0@0) corner: (1366@705)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
WriteStream(Object)>>error:
WriteStream(PositionableStream)>>positionError
WriteStream(PositionableStream)>>position:
WriteStream>>position:
WriteStream(PositionableStream)>>skip:
MiniCTranslator>>visitMiniProcedureSectionNode:
MiniProcedureSectionNode>>accept:
MiniCTranslator>>visitMiniProgramNode:
MiniProgramNode>>accept:
MiniProgramNode>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

